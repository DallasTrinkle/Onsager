

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>GFcalc &mdash; Onsager 1.2.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="Onsager 1.2.1 documentation" href="../index.html"/>
        <link rel="up" title="Module code" href="index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Onsager
          

          
          </a>

          
            
            
              <div class="version">
                1.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../includeme.html">Onsager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../includeme.html#references">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../includeme.html#contributors">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../includeme.html#support">Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crystal.html">Crystal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CrystalStars.html">CrystalStars</a></li>
<li class="toctree-l1"><a class="reference internal" href="../supercell.html">Supercell</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PowerExpansion.html">PowerExpansion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GFcalc.html">GFcalc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OnsagerCalc.html">OnsagerCalc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../automator.html">Automator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks.html">Notebooks</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Onsager</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>GFcalc</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for GFcalc</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">GFcalc module</span>

<span class="sd">Code to compute the lattice Green function for diffusion; this entails inverting</span>
<span class="sd">the &quot;diffusion&quot; matrix, which is infinite, singular, and has translational</span>
<span class="sd">invariance. The solution involves fourier transforming to reciprocal space,</span>
<span class="sd">inverting, and inverse fourier transforming back to real (lattice) space. The</span>
<span class="sd">complication is that the inversion produces a second order pole which must be</span>
<span class="sd">treated analytically. Subtracting off the pole then produces a discontinuity at</span>
<span class="sd">the gamma-point (q=0), which also should be treated analytically. Then, the</span>
<span class="sd">remaining function can be numerically inverse fourier transformed.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Dallas R. Trinkle&#39;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">onsager</span> <span class="k">import</span> <span class="n">PowerExpansion</span> <span class="k">as</span> <span class="n">PE</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">linalg</span> <span class="k">as</span> <span class="n">LA</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">hyp1f1</span><span class="p">,</span> <span class="n">gamma</span>

<span class="c1"># two quick shortcuts</span>
<span class="n">T3D</span> <span class="o">=</span> <span class="n">PE</span><span class="o">.</span><span class="n">Taylor3D</span>
<span class="n">factorial</span> <span class="o">=</span> <span class="n">PE</span><span class="o">.</span><span class="n">factorial</span>


<span class="c1"># Some &quot;helper objects&quot;; mostly collected here so that YAML has full access to them</span>

<span class="k">class</span> <span class="nc">Fnl_p</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">pm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exponential cutoff function in Fourier space (p)</span>

<span class="sd">        :param n: power</span>
<span class="sd">        :param pm: pmax value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inv_pmax</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">pm</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">p</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_pmax</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Fnl_u</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">pm</span><span class="p">,</span> <span class="n">prefactor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverse Fourier transform of exponential cutoff function into real space (u)</span>

<span class="sd">        :param n: power</span>
<span class="sd">        :param l: angular momentum</span>
<span class="sd">        :param pm: pmax value</span>
<span class="sd">        :param prefactor: V/sqrt(d1 d2 d3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">l</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">=</span> <span class="n">l</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">half_pm</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">pm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pre</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span> <span class="o">**</span> <span class="n">l</span> <span class="o">*</span> <span class="n">prefactor</span> <span class="o">*</span> <span class="p">(</span><span class="n">pm</span> <span class="o">**</span> <span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="n">l</span><span class="p">))</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> \
                   <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">**</span> <span class="mf">1.5</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="n">l</span><span class="p">))</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre</span> <span class="o">*</span> <span class="n">u</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">*</span> <span class="n">hyp1f1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">half_pm</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>


<div class="viewcode-block" id="GFCrystalcalc"><a class="viewcode-back" href="../GFcalc.html#GFcalc.GFCrystalcalc">[docs]</a><span class="k">class</span> <span class="nc">GFCrystalcalc</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class calculator for the Green function, designed to work with the Crystal class.</span>

<span class="sd">    This computes the bare vacancy GF. It requires a crystal, chemical identity for the</span>
<span class="sd">    vacancy, list of symmetry unique sites (to define energies / entropies uniquely), and</span>
<span class="sd">    a corresponding jumpnetwork for that vacancy.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="GFCrystalcalc.__init__"><a class="viewcode-back" href="../GFcalc.html#GFcalc.GFCrystalcalc.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crys</span><span class="p">,</span> <span class="n">chem</span><span class="p">,</span> <span class="n">sitelist</span><span class="p">,</span> <span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">Nmax</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes our calculator with the appropriate topology / connectivity. Doesn&#39;t</span>
<span class="sd">        require, at this point, the site probabilities or transition rates to be known.</span>

<span class="sd">        :param crys: Crystal object</span>
<span class="sd">        :param chem: index identifying the diffusing species</span>
<span class="sd">        :param sitelist: list, grouped into Wyckoff common positions, of unique sites</span>
<span class="sd">        :param jumpnetwork: list of unique transitions as lists of ((i,j), dx)</span>
<span class="sd">        :param Nmax: maximum range as estimator for kpt mesh generation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this is really just used by loadHDF5() to circumvent __init__</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">crys</span><span class="p">,</span> <span class="n">chem</span><span class="p">,</span> <span class="n">sitelist</span><span class="p">,</span> <span class="n">jumpnetwork</span><span class="p">)):</span> <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crys</span> <span class="o">=</span> <span class="n">crys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chem</span> <span class="o">=</span> <span class="n">chem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span> <span class="o">=</span> <span class="n">sitelist</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># self.N = sum(1 for w in sitelist for i in w)</span>
        <span class="c1"># self.invmap = [0 for w in sitelist for i in w]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">sitelist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ndiff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">networkcount</span><span class="p">(</span><span class="n">jumpnetwork</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="c1"># if self.Ndiff&gt;1:</span>
        <span class="c1">#     raise NotImplementedError(&#39;Cannot currently have {} disconnected networks&#39;.format(self.Ndiff))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sitelist</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">w</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">invmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NG</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">G</span><span class="p">)</span>  <span class="c1"># number of group operations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grouparray</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexpair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BreakdownGroups</span><span class="p">()</span>
        <span class="c1"># note: currently, we don&#39;t store jumpnetwork. If we want to rewrite the class</span>
        <span class="c1"># to allow a new kpoint mesh to be generated &quot;on the fly&quot;, we&#39;d need to store</span>
        <span class="c1"># a copy for regeneration</span>
        <span class="c1"># self.jumpnetwork = jumpnetwork</span>
        <span class="c1"># generate a kptmesh: now we try to make the mesh more &quot;uniform&quot; ??</span>
        <span class="n">bmagn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">crys</span><span class="o">.</span><span class="n">reciplatt</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">crys</span><span class="o">.</span><span class="n">reciplatt</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
        <span class="n">bmagn</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">bmagn</span><span class="p">),</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
        <span class="c1"># make sure we have even meshes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kptgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Nmax</span> <span class="o">*</span> <span class="n">b</span><span class="p">))</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bmagn</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kpts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wts</span> <span class="o">=</span> <span class="n">crys</span><span class="o">.</span><span class="n">reducekptmesh</span><span class="p">(</span><span class="n">crys</span><span class="o">.</span><span class="n">fullkptmesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kptgrid</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nkpt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kpts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># generate the Fourier transformation for each jump</span>
        <span class="c1"># also includes the multiplicity for the onsite terms (site expansion)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">FTjumps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SEjumps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FourierTransformJumps</span><span class="p">(</span><span class="n">jumpnetwork</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kpts</span><span class="p">)</span>
        <span class="c1"># generate the Taylor expansion coefficients for each jump</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T3Djumps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TaylorExpandJumps</span><span class="p">(</span><span class="n">jumpnetwork</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="c1"># tuple of the Wyckoff site indices for each jump (needed to make symmrate)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jumppairs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">invmap</span><span class="p">[</span><span class="n">jumplist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">invmap</span><span class="p">[</span><span class="n">jumplist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
                               <span class="k">for</span> <span class="n">jumplist</span> <span class="ow">in</span> <span class="n">jumpnetwork</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>  <span class="c1"># we don&#39;t yet know the diffusivity</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="GFCrystalcalc.networkcount"><a class="viewcode-back" href="../GFcalc.html#GFcalc.GFCrystalcalc.networkcount">[docs]</a>    <span class="k">def</span> <span class="nf">networkcount</span><span class="p">(</span><span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a count of how many separate connected networks there are&quot;&quot;&quot;</span>
        <span class="n">jngraph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">jlist</span> <span class="ow">in</span> <span class="n">jumpnetwork</span><span class="p">:</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dx</span> <span class="ow">in</span> <span class="n">jlist</span><span class="p">:</span>
                <span class="n">jngraph</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">connectivity</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># had been a list... if we want to return the list of sets</span>
        <span class="n">disconnected</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)}</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">disconnected</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1"># take the &quot;first&quot; element out, and find everything it&#39;s connected to:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">disconnected</span><span class="p">)</span>
            <span class="n">cset</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">}</span>
            <span class="n">disconnected</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">clen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cset</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">cset</span><span class="o">.</span><span class="n">copy</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">disconnected</span><span class="o">.</span><span class="n">copy</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">jngraph</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">]:</span>
                            <span class="n">cset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                            <span class="n">disconnected</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="c1"># check if we&#39;ve stopped adding new members:</span>
                <span class="k">if</span> <span class="n">clen</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cset</span><span class="p">):</span> <span class="k">break</span>
            <span class="n">connectivity</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># connectivity.append(cset)  # if we want to keep lists of connectivity sets</span>
        <span class="k">return</span> <span class="n">connectivity</span></div>

    <span class="c1"># this is part of our *class* definition:</span>
    <span class="n">__HDF5list__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;Ndiff&#39;</span><span class="p">,</span> <span class="s1">&#39;invmap&#39;</span><span class="p">,</span> <span class="s1">&#39;NG&#39;</span><span class="p">,</span> <span class="s1">&#39;grouparray&#39;</span><span class="p">,</span> <span class="s1">&#39;indexpair&#39;</span><span class="p">,</span> <span class="s1">&#39;kptgrid&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;kpts&#39;</span><span class="p">,</span> <span class="s1">&#39;wts&#39;</span><span class="p">,</span> <span class="s1">&#39;Nkpt&#39;</span><span class="p">,</span> <span class="s1">&#39;FTjumps&#39;</span><span class="p">,</span> <span class="s1">&#39;SEjumps&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;GFcalc for crystal (chemistry=</span><span class="si">{}</span><span class="s1">):</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s1">kpt grid: </span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">,</span>
                                                                                  <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="p">,</span>
                                                                                  <span class="bp">self</span><span class="o">.</span><span class="n">kptgrid</span><span class="p">,</span>
                                                                                  <span class="bp">self</span><span class="o">.</span><span class="n">Nkpt</span><span class="p">)</span>

<div class="viewcode-block" id="GFCrystalcalc.addhdf5"><a class="viewcode-back" href="../GFcalc.html#GFcalc.GFCrystalcalc.addhdf5">[docs]</a>    <span class="k">def</span> <span class="nf">addhdf5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">HDF5group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an HDF5 representation of object into an HDF5group (needs to already exist).</span>

<span class="sd">        Example: if f is an open HDF5, then GFcalc.addhdf5(f.create_group(&#39;GFcalc&#39;)) will</span>
<span class="sd">        (1) create the group named &#39;GFcalc&#39;, and then (2) put the GFcalc representation in that group.</span>

<span class="sd">        :param HDF5group: HDF5 group</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">HDF5group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">HDF5group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;crystal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
        <span class="n">HDF5group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;chem&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chem</span>
        <span class="c1"># arrays that we can deal with:</span>
        <span class="k">for</span> <span class="n">internal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__HDF5list__</span><span class="p">:</span>
            <span class="n">HDF5group</span><span class="p">[</span><span class="n">internal</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">internal</span><span class="p">)</span>
        <span class="c1"># note: we don&#39;t store sitelist; we reconstruct it from invmap</span>
        <span class="c1"># we need to deal with T3Djumps and jumppairs separately</span>
        <span class="n">NT3Djumps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T3Djumps</span><span class="p">)</span>
        <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;NT3Djumps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">NT3Djumps</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t3d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T3Djumps</span><span class="p">):</span>
            <span class="n">coeffstr</span> <span class="o">=</span> <span class="s1">&#39;T3Djump-</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">t3d</span><span class="o">.</span><span class="n">addhdf5</span><span class="p">(</span><span class="n">HDF5group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">coeffstr</span><span class="p">))</span>
        <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;jumppairs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumppairs</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="GFCrystalcalc.loadhdf5"><a class="viewcode-back" href="../GFcalc.html#GFcalc.GFCrystalcalc.loadhdf5">[docs]</a>    <span class="k">def</span> <span class="nf">loadhdf5</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">crys</span><span class="p">,</span> <span class="n">HDF5group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new GFcalc from an HDF5 group.</span>

<span class="sd">        :param crys: crystal object--MUST BE PASSED IN as it is not stored with the GFcalc</span>
<span class="sd">        :param HDFgroup: HDF5 group</span>
<span class="sd">        :return GFcalc: new GFcalc object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">GFcalc</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># initialize</span>
        <span class="n">GFcalc</span><span class="o">.</span><span class="n">crys</span> <span class="o">=</span> <span class="n">crys</span>
        <span class="n">GFcalc</span><span class="o">.</span><span class="n">chem</span> <span class="o">=</span> <span class="n">HDF5group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;chem&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">internal</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__HDF5list__</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">GFcalc</span><span class="p">,</span> <span class="n">internal</span><span class="p">,</span> <span class="n">HDF5group</span><span class="p">[</span><span class="n">internal</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">GFcalc</span><span class="o">.</span><span class="n">T3Djumps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;NT3Djumps&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
            <span class="n">coeffstr</span> <span class="o">=</span> <span class="s1">&#39;T3Djump-</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">GFcalc</span><span class="o">.</span><span class="n">T3Djumps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T3D</span><span class="o">.</span><span class="n">loadhdf5</span><span class="p">(</span><span class="n">HDF5group</span><span class="p">[</span><span class="n">coeffstr</span><span class="p">]))</span>
        <span class="c1"># construct sitelist and jumppairs</span>
        <span class="n">GFcalc</span><span class="o">.</span><span class="n">sitelist</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">GFcalc</span><span class="o">.</span><span class="n">invmap</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">GFcalc</span><span class="o">.</span><span class="n">invmap</span><span class="p">):</span>
            <span class="n">GFcalc</span><span class="o">.</span><span class="n">sitelist</span><span class="p">[</span><span class="n">site</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">GFcalc</span><span class="o">.</span><span class="n">jumppairs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;jumppairs&#39;</span><span class="p">])</span>
        <span class="n">GFcalc</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">GFcalc</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>  <span class="c1"># we don&#39;t yet know the diffusivity</span>
        <span class="k">return</span> <span class="n">GFcalc</span></div>

<div class="viewcode-block" id="GFCrystalcalc.FourierTransformJumps"><a class="viewcode-back" href="../GFcalc.html#GFcalc.GFCrystalcalc.FourierTransformJumps">[docs]</a>    <span class="k">def</span> <span class="nf">FourierTransformJumps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">kpts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the Fourier transform coefficients for each jump</span>

<span class="sd">        :param jumpnetwork: list of unique transitions, as lists of ((i,j), dx)</span>
<span class="sd">        :param N: number of sites</span>
<span class="sd">        :param kpts: array[Nkpt][3], in Cartesian (same coord. as dx)</span>
<span class="sd">        :return FTjumps: array[Njump][Nkpt][Nsite][Nsite] of FT of the jump network</span>
<span class="sd">        :return SEjumps: array[Nsite][Njump] multiplicity of jump on each site</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">FTjumps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">jumpnetwork</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nkpt</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">SEjumps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">jumpnetwork</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">J</span><span class="p">,</span> <span class="n">jumplist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">jumpnetwork</span><span class="p">):</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dx</span> <span class="ow">in</span> <span class="n">jumplist</span><span class="p">:</span>
                <span class="n">FTjumps</span><span class="p">[</span><span class="n">J</span><span class="p">,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">kpts</span><span class="p">,</span> <span class="n">dx</span><span class="p">))</span>
                <span class="n">SEjumps</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">J</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">FTjumps</span><span class="p">,</span> <span class="n">SEjumps</span></div>

<div class="viewcode-block" id="GFCrystalcalc.TaylorExpandJumps"><a class="viewcode-back" href="../GFcalc.html#GFcalc.GFCrystalcalc.TaylorExpandJumps">[docs]</a>    <span class="k">def</span> <span class="nf">TaylorExpandJumps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the Taylor expansion coefficients for each jump</span>

<span class="sd">        :param jumpnetwork: list of unique transitions, as lists of ((i,j), dx)</span>
<span class="sd">        :param N: number of sites</span>
<span class="sd">        :return T3Djumps: list of Taylor3D expansions of the jump network</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">T3D</span><span class="p">()</span>  <span class="c1"># need to do just to initialize the class; if already initialized, won&#39;t do anything</span>
        <span class="c1"># Taylor expansion coefficients for exp(1j*x) = (1j)^n/n!</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span> <span class="o">**</span> <span class="n">n</span> <span class="o">/</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T3D</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
        <span class="n">T3Djumps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">jumplist</span> <span class="ow">in</span> <span class="n">jumpnetwork</span><span class="p">:</span>
            <span class="c1"># coefficients; we use tuples because we&#39;ll be successively adding to the coefficients in place</span>
            <span class="n">c</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">T3D</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T3D</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dx</span> <span class="ow">in</span> <span class="n">jumplist</span><span class="p">:</span>
                <span class="n">pexp</span> <span class="o">=</span> <span class="n">T3D</span><span class="o">.</span><span class="n">powexp</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T3D</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">2</span><span class="p">])[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">pre</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">T3D</span><span class="o">.</span><span class="n">powercoeff</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">pexp</span><span class="p">)[:</span><span class="n">T3D</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span>
            <span class="n">T3Djumps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T3D</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">T3Djumps</span></div>

<div class="viewcode-block" id="GFCrystalcalc.BreakdownGroups"><a class="viewcode-back" href="../GFcalc.html#GFcalc.GFCrystalcalc.BreakdownGroups">[docs]</a>    <span class="k">def</span> <span class="nf">BreakdownGroups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes in a crystal, and a chemistry, and constructs the indexing breakdown for each</span>
<span class="sd">        (i,j) pair.</span>
<span class="sd">        :return grouparray: array[NG][3][3] of the NG group operations</span>
<span class="sd">        :return indexpair: array[N][N][NG][2] of the index pair for each group operation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grouparray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">NG</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">indexpair</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">NG</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ng</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">G</span><span class="p">):</span>
            <span class="n">grouparray</span><span class="p">[</span><span class="n">ng</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">cartrot</span><span class="p">[:,</span> <span class="p">:]</span>
            <span class="n">indexmap</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">indexmap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                    <span class="n">indexpair</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ng</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">indexpair</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ng</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">indexmap</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">indexmap</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">grouparray</span><span class="p">,</span> <span class="n">indexpair</span></div>

<div class="viewcode-block" id="GFCrystalcalc.SymmRates"><a class="viewcode-back" href="../GFcalc.html#GFcalc.GFCrystalcalc.SymmRates">[docs]</a>    <span class="k">def</span> <span class="nf">SymmRates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">betaene</span><span class="p">,</span> <span class="n">preT</span><span class="p">,</span> <span class="n">betaeneT</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of lists of symmetrized rates, matched to jumpnetwork&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pT</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">betaene</span><span class="p">[</span><span class="n">w0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">betaene</span><span class="p">[</span><span class="n">w1</span><span class="p">]</span> <span class="o">-</span> <span class="n">beT</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="n">w0</span><span class="p">]</span> <span class="o">*</span> <span class="n">pre</span><span class="p">[</span><span class="n">w1</span><span class="p">])</span>
                         <span class="k">for</span> <span class="p">(</span><span class="n">w0</span><span class="p">,</span> <span class="n">w1</span><span class="p">),</span> <span class="n">pT</span><span class="p">,</span> <span class="n">beT</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumppairs</span><span class="p">,</span> <span class="n">preT</span><span class="p">,</span> <span class="n">betaeneT</span><span class="p">)])</span></div>

<div class="viewcode-block" id="GFCrystalcalc.SetRates"><a class="viewcode-back" href="../GFcalc.html#GFcalc.GFCrystalcalc.SetRates">[docs]</a>    <span class="k">def</span> <span class="nf">SetRates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">betaene</span><span class="p">,</span> <span class="n">preT</span><span class="p">,</span> <span class="n">betaeneT</span><span class="p">,</span> <span class="n">pmaxerror</span><span class="o">=</span><span class="mf">1.e-8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (Re)sets the rates, given the prefactors and Arrhenius factors for the sites and</span>
<span class="sd">        transitions, using the ordering according to sitelist and jumpnetwork. Initiates all of</span>
<span class="sd">        the calculations so that GF calculation is (fairly) efficient for each input.</span>

<span class="sd">        :param pre: list of prefactors for site probabilities</span>
<span class="sd">        :param betaene: list of beta*E (energy/kB T) for each site</span>
<span class="sd">        :param preT: list of prefactors for transition states</span>
<span class="sd">        :param betaeneT: list of beta*ET (energy/kB T) for each transition state</span>
<span class="sd">        :param pmaxerror: parameter controlling error from pmax value. Should be same order as integration error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symmrate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SymmRates</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">betaene</span><span class="p">,</span> <span class="n">preT</span><span class="p">,</span> <span class="n">betaeneT</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxrate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmrate</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symmrate</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxrate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">escape</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SEjumps</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">J</span><span class="p">]</span> <span class="o">*</span> <span class="n">pretrans</span> <span class="o">/</span> <span class="n">pre</span><span class="p">[</span><span class="n">wi</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">betaene</span><span class="p">[</span><span class="n">wi</span><span class="p">]</span> <span class="o">-</span> <span class="n">BET</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">J</span><span class="p">,</span> <span class="n">pretrans</span><span class="p">,</span> <span class="n">BET</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="n">preT</span><span class="p">,</span> <span class="n">betaeneT</span><span class="p">))</span>
                                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">wi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">invmap</span><span class="p">)])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxrate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega_qij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symmrate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">FTjumps</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega_qij</span><span class="p">[:]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span>  <span class="c1"># adds it to every point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega_Taylor</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">symmrate</span> <span class="o">*</span> <span class="n">expansion</span>
                                <span class="k">for</span> <span class="n">symmrate</span><span class="p">,</span> <span class="n">expansion</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symmrate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T3Djumps</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega_Taylor</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span>

        <span class="c1"># 1. Diagonalize gamma point value; use to rotate to diffusive / relaxive, and reduce</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DiagGamma</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">Ndiff</span><span class="p">],</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span><span class="s2">&quot;Did not find </span><span class="si">{}</span><span class="s2"> equilibrium solution to rates?&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ndiff</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega_Taylor_rotate</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega_Taylor</span><span class="o">.</span><span class="n">ldot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vr</span><span class="o">.</span><span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="n">rdot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vr</span><span class="p">)</span>
        <span class="n">oT_dd</span><span class="p">,</span> <span class="n">oT_dr</span><span class="p">,</span> <span class="n">oT_rd</span><span class="p">,</span> <span class="n">oT_rr</span><span class="p">,</span> <span class="n">oT_D</span><span class="p">,</span> <span class="n">etav</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BlockRotateOmegaTaylor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega_Taylor_rotate</span><span class="p">)</span>
        <span class="c1"># 2. Calculate D and eta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Diffusivity</span><span class="p">(</span><span class="n">oT_D</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">biascorrection</span><span class="p">(</span><span class="n">etav</span><span class="p">)</span>
        <span class="c1"># 3. Spatially rotate the Taylor expansion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">e</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxrate</span><span class="p">)</span>
        <span class="c1"># had been 1e-11; changed to 1e-7 to reflect likely integration accuracy of k-point grids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxrate</span><span class="p">))</span> <span class="k">for</span> <span class="n">G</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">BZG</span><span class="p">])</span> <span class="o">/</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pmaxerror</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qptrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pqtrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uxtrans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qptrans</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pqtrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">uxtrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">powtrans</span> <span class="o">=</span> <span class="n">T3D</span><span class="o">.</span><span class="n">rotatedirections</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qptrans</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">[</span><span class="n">oT_dd</span><span class="p">,</span> <span class="n">oT_dr</span><span class="p">,</span> <span class="n">oT_rd</span><span class="p">,</span> <span class="n">oT_rr</span><span class="p">,</span> <span class="n">oT_D</span><span class="p">]:</span>
            <span class="n">t</span><span class="o">.</span><span class="n">irotate</span><span class="p">(</span><span class="n">powtrans</span><span class="p">)</span>  <span class="c1"># rotate in place</span>
            <span class="n">t</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">oT_D</span><span class="o">.</span><span class="n">coefflist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span><span class="s2">&quot;Problem isotropizing D?&quot;</span><span class="p">)</span>
        <span class="c1"># 4. Invert Taylor expansion using block inversion formula, and truncate at n=0</span>
        <span class="n">gT_rotate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BlockInvertOmegaTaylor</span><span class="p">(</span><span class="n">oT_dd</span><span class="p">,</span> <span class="n">oT_dr</span><span class="p">,</span> <span class="n">oT_rd</span><span class="p">,</span> <span class="n">oT_rr</span><span class="p">,</span> <span class="n">oT_D</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g_Taylor</span> <span class="o">=</span> <span class="p">(</span><span class="n">gT_rotate</span><span class="o">.</span><span class="n">ldot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vr</span><span class="p">))</span><span class="o">.</span><span class="n">rdot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vr</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g_Taylor</span><span class="o">.</span><span class="n">separate</span><span class="p">()</span>
        <span class="n">g_Taylor_fnlp</span> <span class="o">=</span> <span class="p">{(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span> <span class="n">Fnl_p</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmax</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_Taylor</span><span class="o">.</span><span class="n">nl</span><span class="p">()}</span>
        <span class="n">prefactor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">volume</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g_Taylor_fnlu</span> <span class="o">=</span> <span class="p">{(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span> <span class="n">Fnl_u</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmax</span><span class="p">,</span> <span class="n">prefactor</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_Taylor</span><span class="o">.</span><span class="n">nl</span><span class="p">()}</span>
        <span class="c1"># 5. Invert Fourier expansion</span>
        <span class="n">gsc_qij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega_qij</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">qind</span><span class="p">,</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kpts</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                <span class="c1"># gamma point... need to treat separately</span>
                <span class="n">gsc_qij</span><span class="p">[</span><span class="n">qind</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmax</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> \
                                <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vr</span><span class="p">[:,</span> <span class="n">n</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">vr</span><span class="p">[:,</span> <span class="n">n</span><span class="p">])</span>
                                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ndiff</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># invert, subtract off Taylor expansion to leave semicontinuum piece</span>
                <span class="n">gsc_qij</span><span class="p">[</span><span class="n">qind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega_qij</span><span class="p">[</span><span class="n">qind</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span> \
                                <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_Taylor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pqtrans</span><span class="p">,</span> <span class="n">q</span><span class="p">),</span> <span class="n">g_Taylor_fnlp</span><span class="p">)</span>
        <span class="c1"># 6. Slice the pieces we want for fast(er) evaluation (since we specify i and j in evaluation)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gsc_ijq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nkpt</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gsc_ijq</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">gsc_qij</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="c1"># since we can&#39;t make an array, use tuples of tuples to do gT_ij[i][j]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gT_ij</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g_Taylor</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span><span class="o">.</span><span class="n">separate</span><span class="p">()</span>
                                 <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span>
                           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span></div>

<div class="viewcode-block" id="GFCrystalcalc.exp_dxq"><a class="viewcode-back" href="../GFcalc.html#GFcalc.GFCrystalcalc.exp_dxq">[docs]</a>    <span class="k">def</span> <span class="nf">exp_dxq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the array of exp(-i q.dx) evaluated over the q-points, and accounting for symmetry</span>

<span class="sd">        :param dx: vector</span>
<span class="sd">        :return exp(-i q.dx): array of :math:`\\exp(-i \\cdot dx)`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># kpts[k,3] .. g_dx_array[NR, 3]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kpts</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span></div>

<div class="viewcode-block" id="GFCrystalcalc.__call__"><a class="viewcode-back" href="../GFcalc.html#GFcalc.GFCrystalcalc.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">dx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the Green function from site i to site j, separated by vector dx</span>

<span class="sd">        :param i: site index</span>
<span class="sd">        :param j: site index</span>
<span class="sd">        :param dx: vector pointing from i to j (can include lattice contributions)</span>
<span class="sd">        :return G: Green function value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="ow">is</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need to SetRates first&quot;</span><span class="p">)</span>
        <span class="c1"># evaluate Fourier transform component (now with better space group treatment!)</span>
        <span class="n">gIFT</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">gop</span><span class="p">,</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grouparray</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexpair</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]):</span>
            <span class="n">gIFT</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsc_ijq</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_dxq</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">gop</span><span class="p">,</span> <span class="n">dx</span><span class="p">)))</span>
        <span class="n">gIFT</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">NG</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">gIFT</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span><span class="s2">&quot;Got complex IFT? </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gIFT</span><span class="p">))</span>
        <span class="c1"># evaluate Taylor expansion component:</span>
        <span class="n">gTaylor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gT_ij</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">](</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uxtrans</span><span class="p">,</span> <span class="n">dx</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_Taylor_fnlu</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">gTaylor</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span><span class="s2">&quot;Got complex IFT from Taylor? </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gTaylor</span><span class="p">))</span>
        <span class="c1"># combine:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">gIFT</span> <span class="o">+</span> <span class="n">gTaylor</span><span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxrate</span></div>

<div class="viewcode-block" id="GFCrystalcalc.DiagGamma"><a class="viewcode-back" href="../GFcalc.html#GFcalc.GFCrystalcalc.DiagGamma">[docs]</a>    <span class="k">def</span> <span class="nf">DiagGamma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omega</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Diagonalize the gamma point (q=0) term</span>

<span class="sd">        :param omega: optional; the Taylor expansion to use. If None, use self.omega_Taylor</span>
<span class="sd">        :return r: array of eigenvalues, sorted from 0 to decreasing values.</span>
<span class="sd">        :return vr: array of eigenvectors where vr[:,i] is the vector for eigenvalue r[i]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">omega</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">omega</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega_Taylor</span>
        <span class="n">gammacoeff</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span> <span class="ow">in</span> <span class="n">omega</span><span class="o">.</span><span class="n">coefflist</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Taylor expansion has terms below n=0?&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">l</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n=0 term has angular dependence? l != 0&quot;</span><span class="p">)</span>
                <span class="n">gammacoeff</span> <span class="o">=</span> <span class="o">-</span><span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">gammacoeff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># missing onsite term--indicates that it&#39;s been reduced to 0</span>
            <span class="c1"># should ONLY happen if we have a Bravais lattice, e.g.</span>
            <span class="n">gammacoeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">vr</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">gammacoeff</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">r</span><span class="p">,</span> <span class="n">vr</span></div>

<div class="viewcode-block" id="GFCrystalcalc.Diffusivity"><a class="viewcode-back" href="../GFcalc.html#GFcalc.GFCrystalcalc.Diffusivity">[docs]</a>    <span class="k">def</span> <span class="nf">Diffusivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omega_Taylor_D</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the diffusivity, or compute it if it&#39;s not already known. Uses omega_Taylor_D</span>
<span class="sd">        to compute with maximum efficiency.</span>

<span class="sd">        :param omega_Taylor_D: Taylor expansion of the diffusivity component</span>
<span class="sd">        :return D: diffusivity [3,3] array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="ow">is</span> <span class="ow">not</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">omega_Taylor_D</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="ow">is</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">omega_Taylor_D</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need omega_Taylor_D value&quot;</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">omega_Taylor_D</span><span class="o">.</span><span class="n">coefflist</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Reduced Taylor expansion for D doesn&#39;t begin with n==2&quot;</span><span class="p">)</span>
            <span class="n">DTr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">Ndiff</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># first up: constant term (if present)</span>
                <span class="n">D</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">DTr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># next: l == 2 contributions</span>
                <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># done in this way so that we get the 1/2 for the off-diagonal, and the 1 for diagonal</span>
                    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">)):</span>
                        <span class="n">ind</span> <span class="o">=</span> <span class="n">T3D</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">t</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">t</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>  <span class="c1"># count the powers</span>
                        <span class="n">D</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">DTr</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
                        <span class="n">D</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">DTr</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="c1"># note: the &quot;D&quot; constructed this way will be negative! (as it is -q.D.q)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">D</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxrate</span></div>

<div class="viewcode-block" id="GFCrystalcalc.biascorrection"><a class="viewcode-back" href="../GFcalc.html#GFcalc.GFCrystalcalc.biascorrection">[docs]</a>    <span class="k">def</span> <span class="nf">biascorrection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">etav</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the bias correction, or compute it if it&#39;s not already known. Uses etav to compute.</span>

<span class="sd">        :param etav: Taylor expansion of the bias correction</span>
<span class="sd">        :return eta: [N,3] array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">etav</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">etav</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">eta</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">etav</span><span class="o">.</span><span class="n">coefflist</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Reduced Taylor expansion for etav doesn&#39;t begin with n==1&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">T3D</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
                                   <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">T3D</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
                                   <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">T3D</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])):</span>
                        <span class="n">eta</span><span class="p">[:,</span> <span class="n">d</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vr</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ndiff</span><span class="p">:],</span> <span class="n">c</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="p">:])[:,</span> <span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span>
                                         <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ndiff</span><span class="p">))</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">Ndiff</span>
        <span class="k">return</span> <span class="n">eta</span></div>

<div class="viewcode-block" id="GFCrystalcalc.BlockRotateOmegaTaylor"><a class="viewcode-back" href="../GFcalc.html#GFcalc.GFCrystalcalc.BlockRotateOmegaTaylor">[docs]</a>    <span class="k">def</span> <span class="nf">BlockRotateOmegaTaylor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omega_Taylor_rotate</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns block partitioned Taylor expansion of a rotated omega Taylor expansion.</span>

<span class="sd">        :param omega_Taylor_rotate: rotated into diffusive [0] / relaxive [1:] basis</span>
<span class="sd">        :param dd: diffusive/diffusive block (upper left)</span>
<span class="sd">        :param dr: diffusive/relaxive block (lower left)</span>
<span class="sd">        :param rd: relaxive/diffusive block (upper right)</span>
<span class="sd">        :param rr: relaxive/relaxive block (lower right)</span>
<span class="sd">        :param D: :math:`dd - dr (rr)^{-1} rd` (diffusion)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ND</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ndiff</span>  <span class="c1"># previously had been 1.</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="n">omega_Taylor_rotate</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ND</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">ND</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">dr</span> <span class="o">=</span> <span class="n">omega_Taylor_rotate</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ND</span><span class="p">,</span> <span class="n">ND</span><span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">rd</span> <span class="o">=</span> <span class="n">omega_Taylor_rotate</span><span class="p">[</span><span class="n">ND</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">ND</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">rr</span> <span class="o">=</span> <span class="n">omega_Taylor_rotate</span><span class="p">[</span><span class="n">ND</span><span class="p">:,</span> <span class="n">ND</span><span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">[</span><span class="n">dd</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">rd</span><span class="p">,</span> <span class="n">rr</span><span class="p">]:</span> <span class="n">t</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">&gt;</span> <span class="n">ND</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">dd</span> <span class="o">-</span> <span class="n">dr</span> <span class="o">*</span> <span class="n">rr</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span> <span class="o">*</span> <span class="n">rd</span>
            <span class="n">etav</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span> <span class="o">*</span> <span class="n">rd</span>
            <span class="n">etav</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">etav</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">D</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">T3D</span><span class="o">.</span><span class="n">Lmax</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">D</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">dd</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">rd</span><span class="p">,</span> <span class="n">rr</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">etav</span></div>

<div class="viewcode-block" id="GFCrystalcalc.BlockInvertOmegaTaylor"><a class="viewcode-back" href="../GFcalc.html#GFcalc.GFCrystalcalc.BlockInvertOmegaTaylor">[docs]</a>    <span class="k">def</span> <span class="nf">BlockInvertOmegaTaylor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dd</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">rd</span><span class="p">,</span> <span class="n">rr</span><span class="p">,</span> <span class="n">D</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns block inverted omega as a Taylor expansion, up to Nmax = 0 (discontinuity</span>
<span class="sd">        correction). Needs to be rotated such that leading order of D is isotropic.</span>

<span class="sd">        :param dd: diffusive/diffusive block (upper left)</span>
<span class="sd">        :param dr: diffusive/relaxive block (lower left)</span>
<span class="sd">        :param rd: relaxive/diffusive block (upper right)</span>
<span class="sd">        :param rr: relaxive/relaxive block (lower right)</span>
<span class="sd">        :param D: :math:`dd - dr (rr)^{-1} rd` (diffusion)</span>
<span class="sd">        :return gT: Taylor expansion of g in block form, and reduced (collected terms)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ND</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ndiff</span>  <span class="c1"># previously had been 1.</span>
        <span class="n">gT</span> <span class="o">=</span> <span class="n">T3D</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span>  <span class="c1"># where we&#39;ll place our Taylor expansion</span>
        <span class="n">D_inv</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>
        <span class="n">gT</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ND</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">ND</span><span class="p">]</span> <span class="o">=</span> <span class="n">D_inv</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">&gt;</span> <span class="n">ND</span><span class="p">:</span>
            <span class="n">rr_inv</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>
            <span class="n">gT</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ND</span><span class="p">,</span> <span class="n">ND</span><span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">D_inv</span> <span class="o">*</span> <span class="n">dr</span> <span class="o">*</span> <span class="n">rr_inv</span><span class="p">)</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">gT</span><span class="p">[</span><span class="n">ND</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">ND</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">rr_inv</span> <span class="o">*</span> <span class="n">rd</span> <span class="o">*</span> <span class="n">D_inv</span><span class="p">)</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">gT</span><span class="p">[</span><span class="n">ND</span><span class="p">:,</span> <span class="n">ND</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rr_inv</span> <span class="o">+</span> <span class="n">rr_inv</span> <span class="o">*</span> <span class="n">rd</span> <span class="o">*</span> <span class="n">D_inv</span> <span class="o">*</span> <span class="n">dr</span> <span class="o">*</span> <span class="n">rr_inv</span><span class="p">)</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gT</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span></div></div>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Dallas R. Trinkle.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.2.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>