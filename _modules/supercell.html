

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>supercell &mdash; Onsager 1.4 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=0ed52906"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Onsager
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../includeme.html">Onsager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../InputOutput.html">Input and output for Onsager transport calculation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks.html">Example Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">Modules</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Onsager</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">supercell</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for supercell</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Supercell class</span>

<span class="sd">Class to store supercells of crystals. A supercell is a lattice model of a crystal, with</span>
<span class="sd">periodically repeating unit cells. In that framework we can</span>

<span class="sd">1. add/remove/substitute atoms</span>
<span class="sd">2. find the transformation map between two different representations of the same supercell</span>
<span class="sd">3. output POSCAR format (possibly other formats?)</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Dallas R. Trinkle&#39;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">collections</span><span class="o">,</span> <span class="nn">copy</span><span class="o">,</span> <span class="nn">itertools</span><span class="o">,</span> <span class="nn">warnings</span><span class="o">,</span> <span class="nn">yaml</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Integral</span>
<span class="kn">from</span> <span class="nn">onsager</span> <span class="kn">import</span> <span class="n">crystal</span><span class="p">,</span> <span class="n">cluster</span>


<div class="viewcode-block" id="Supercell">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell">[docs]</a>
<span class="k">class</span> <span class="nc">Supercell</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class that defines a Supercell of a crystal.</span>

<span class="sd">    Takes in a crystal, a supercell (3x3 integer matrix). We can identify sites</span>
<span class="sd">    as interstitial sites, and specify if we&#39;ll have solutes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Supercell.__init__">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crys</span><span class="p">,</span> <span class="n">superlatt</span><span class="p">,</span> <span class="n">interstitial</span><span class="o">=</span><span class="p">(),</span> <span class="n">Nsolute</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">empty</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">NOSYM</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize our supercell to an empty supercell.</span>

<span class="sd">        :param crys: crystal object</span>
<span class="sd">        :param superlatt: 3x3 integer matrix</span>
<span class="sd">        :param interstitial: (optional) list/tuple of indices that correspond to interstitial sites</span>
<span class="sd">        :param Nsolute: (optional) number of substitutional solute elements to consider; default=0</span>
<span class="sd">        :param empty: (optional) designed to allow &quot;copy&quot; to work--skips all derived info</span>
<span class="sd">        :param NOSYM: (optional) does not do symmetry analysis (intended ONLY for testing purposes)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crys</span> <span class="o">=</span> <span class="n">crys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">superlatt</span> <span class="o">=</span> <span class="n">superlatt</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interstitial</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">interstitial</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nchem</span> <span class="o">=</span> <span class="n">crys</span><span class="o">.</span><span class="n">Nchem</span> <span class="o">+</span> <span class="n">Nsolute</span> <span class="k">if</span> <span class="n">Nsolute</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">crys</span><span class="o">.</span><span class="n">Nchem</span>
        <span class="k">if</span> <span class="n">empty</span><span class="p">:</span> <span class="k">return</span>
        <span class="c1"># everything else that follows is &quot;derived&quot; from those initial parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">superlatt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">N</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atomindices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexatom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">atomindices</span><span class="p">,</span> \
                                           <span class="p">{</span><span class="n">ci</span><span class="p">:</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">ci</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">atomindices</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chemistry</span> <span class="o">=</span> <span class="p">[</span><span class="n">crys</span><span class="o">.</span><span class="n">chemistry</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">crys</span><span class="o">.</span><span class="n">Nchem</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nchem</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chemistry</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;v&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Wyckofflist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wyckoffchem</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomindices</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">wset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wyckofflist</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">wset</span><span class="p">:</span> <span class="k">break</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Wyckofflist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">wset</span><span class="p">:</span>
                <span class="c1"># grab the set of (c,i) of Wyckoff sets (next returns first that matches, None if none):</span>
                <span class="n">indexset</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">iset</span> <span class="k">for</span> <span class="n">iset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">Wyckoff</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="n">iset</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Wyckofflist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">indexatom</span><span class="p">[</span><span class="n">ci</span><span class="p">]</span> <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">indexset</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Wyckoffchem</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">chemistry</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">invsuper</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">translist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transdict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maketrans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">superlatt</span><span class="p">)</span>
        <span class="c1"># self.transdict = {tuple(t):n for n,t in enumerate(self.translist)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">occ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">makesites</span><span class="p">(),</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chemorder</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nchem</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">NOSYM</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([</span><span class="n">crystal</span><span class="o">.</span><span class="n">GroupOp</span><span class="o">.</span><span class="n">ident</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">])])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gengroup</span><span class="p">()</span></div>


    <span class="c1"># some attributes we want to do equate, others we want deepcopy. Equate should not be modified.</span>
    <span class="n">__copyattr__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;lattice&#39;</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;chemistry&#39;</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="s1">&#39;invsuper&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;Wyckofflist&#39;</span><span class="p">,</span> <span class="s1">&#39;Wyckoffchem&#39;</span><span class="p">,</span> <span class="s1">&#39;occ&#39;</span><span class="p">,</span> <span class="s1">&#39;chemorder&#39;</span><span class="p">)</span>
    <span class="n">__eqattr__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;atomindices&#39;</span><span class="p">,</span> <span class="s1">&#39;indexatom&#39;</span><span class="p">,</span> <span class="s1">&#39;translist&#39;</span><span class="p">,</span> <span class="s1">&#39;transdict&#39;</span><span class="p">,</span> <span class="s1">&#39;pos&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Supercell.copy">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.copy">[docs]</a>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a copy of the supercell; initializes, then copies over ``__copyattr__`` and</span>
<span class="sd">        ``__eqattr__``.</span>

<span class="sd">        :return: new supercell object, copy of the original</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">supercopy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">superlatt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interstitial</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nchem</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">Nchem</span><span class="p">,</span>
                                   <span class="n">empty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__copyattr__</span><span class="p">:</span> <span class="nb">setattr</span><span class="p">(</span><span class="n">supercopy</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__eqattr__</span><span class="p">:</span> <span class="nb">setattr</span><span class="p">(</span><span class="n">supercopy</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">supercopy</span></div>


<div class="viewcode-block" id="Supercell.__eq__">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.__eq__">[docs]</a>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if two supercells are equal; this means they should have the same occupancy.</span>
<span class="sd">        *and* the same ordering</span>

<span class="sd">        :param other: supercell for comparison</span>
<span class="sd">        :return: True if same crystal, supercell, occupancy, and ordering; False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">superlatt</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">superlatt</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">interstitial</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">interstitial</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">occ</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">occ</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemorder</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">chemorder</span></div>


<div class="viewcode-block" id="Supercell.__ne__">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.__ne__">[docs]</a>
    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Inequality == not __eq__&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>


<div class="viewcode-block" id="Supercell.stoichiometry">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.stoichiometry">[docs]</a>
    <span class="k">def</span> <span class="nf">stoichiometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a string representing the current stoichiometry&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">c</span> <span class="o">+</span> <span class="s1">&#39;_i(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
                         <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interstitial</span>
                         <span class="k">else</span> <span class="n">c</span> <span class="o">+</span> <span class="s1">&#39;(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
                         <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">chemistry</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">chemorder</span><span class="p">)])</span></div>


<div class="viewcode-block" id="Supercell.__str__">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.__str__">[docs]</a>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Human readable version of supercell&quot;&quot;&quot;</span>
        <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Supercell of crystal:</span><span class="se">\n</span><span class="si">{crys}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">crys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="p">)</span>
        <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot;Supercell vectors:</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s2">Chemistry: &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">superlatt</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="nb">str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometry</span><span class="p">()</span>
        <span class="nb">str</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Kroger-Vink: &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">KrogerVink</span><span class="p">()</span>
        <span class="nb">str</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Positions:</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="nb">str</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">u</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemistry</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">occ</span><span class="p">)])</span>
        <span class="nb">str</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Ordering:</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="nb">str</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">u</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">ulist</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chemistry</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">occposlist</span><span class="p">())</span>
                          <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">ulist</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">str</span></div>


<div class="viewcode-block" id="Supercell.__mul__">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.__mul__">[docs]</a>
    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiply by a GroupOp; returns a new supercell (constructed via copy).</span>

<span class="sd">        :param other: must be a GroupOp (and *should* be a GroupOp of the supercell!)</span>
<span class="sd">        :return: rotated supercell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">crystal</span><span class="o">.</span><span class="n">GroupOp</span><span class="p">):</span> <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="n">gsuper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">gsuper</span> <span class="o">*=</span> <span class="n">other</span>
        <span class="k">return</span> <span class="n">gsuper</span></div>


<div class="viewcode-block" id="Supercell.__rmul__">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.__rmul__">[docs]</a>
    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiply by a GroupOp; returns a new supercell (constructed via copy).</span>

<span class="sd">        :param other: must be a GroupOp (and *should* be a GroupOp of the supercell!)</span>
<span class="sd">        :return: rotated supercell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">crystal</span><span class="o">.</span><span class="n">GroupOp</span><span class="p">):</span> <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>


<div class="viewcode-block" id="Supercell.__imul__">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.__imul__">[docs]</a>
    <span class="k">def</span> <span class="fm">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiply by a GroupOp, in place.</span>

<span class="sd">        :param other: must be a GroupOp (and *should* be a GroupOp of the supercell!)</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">crystal</span><span class="o">.</span><span class="n">GroupOp</span><span class="p">):</span> <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="c1"># This requires some careful manipulation: we need to modify (1) occ, and (2) chemorder</span>
        <span class="n">indexmap</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">indexmap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">gocc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">gind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indexmap</span><span class="p">):</span>
            <span class="n">gocc</span><span class="p">[</span><span class="n">gind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">occ</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">occ</span> <span class="o">=</span> <span class="n">gocc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chemorder</span> <span class="o">=</span> <span class="p">[[</span><span class="n">indexmap</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">clist</span><span class="p">]</span> <span class="k">for</span> <span class="n">clist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemorder</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Supercell.index">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.index">[docs]</a>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the index that corresponds to the position *closest* to pos in the supercell.</span>
<span class="sd">        Done in direct coordinates of the supercell, using periodic boundary conditions.</span>

<span class="sd">        :param pos: 3-vector</span>
<span class="sd">        :param threshold: (optional) minimum squared &quot;distance&quot; in supercell for a match; default=1.</span>
<span class="sd">        :return index: index of closest position</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span><span class="p">,</span> <span class="n">dist2</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">):</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">crystal</span><span class="o">.</span><span class="n">inhalf</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">delta</span> <span class="o">*</span> <span class="n">delta</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d2</span> <span class="o">&lt;</span> <span class="n">dist2</span><span class="p">:</span> <span class="n">index</span><span class="p">,</span> <span class="n">dist2</span> <span class="o">=</span> <span class="n">ind</span><span class="p">,</span> <span class="n">d2</span>
        <span class="k">return</span> <span class="n">index</span></div>


<div class="viewcode-block" id="Supercell.__getitem__">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.__getitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Index into supercell</span>

<span class="sd">        :param key: index (either an int, a slice, or a position)</span>
<span class="sd">        :return: chemical occupation at that point</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">occ</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">occ</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Inappropriate key </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span></div>


<div class="viewcode-block" id="Supercell.__setitem__">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.__setitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set specific composition for site; uses same indexing as __getitem__</span>

<span class="sd">        :param key: index (either an int, a slice, or a position)</span>
<span class="sd">        :param value: chemical occupation at that point</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span> <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span> <span class="n">index</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span> <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setocc</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="Supercell.__sane__">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.__sane__">[docs]</a>
    <span class="k">def</span> <span class="nf">__sane__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if supercell occupation and chemorder are consistent&quot;&quot;&quot;</span>
        <span class="n">occset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">clist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chemorder</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">clist</span><span class="p">:</span>
                <span class="c1"># check that occupancy (from chemorder) is correct:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">occ</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">!=</span> <span class="n">c</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
                <span class="c1"># record as an occupied state</span>
                <span class="n">occset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
        <span class="c1"># now make sure that every site *not* in occset is, in fact, vacant</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">occ</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">occset</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="Supercell.maketrans">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.maketrans">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">maketrans</span><span class="p">(</span><span class="n">superlatt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes in a supercell matrix, and returns a list of all translations of the unit</span>
<span class="sd">        cell that remain inside the supercell</span>

<span class="sd">        :param superlatt: 3x3 integer matrix</span>
<span class="sd">        :return size: integer, corresponding to number of unit cells</span>
<span class="sd">        :return invsuper: integer matrix inverse of supercell (needs to be divided by size)</span>
<span class="sd">        :return translist: list of integer vectors (to be divided by ``size``) corresponding</span>
<span class="sd">            to unit cell positions</span>
<span class="sd">        :return transdict: dictionary of tuples and their corresponding index (inverse of trans)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">superlatt</span><span class="p">))))</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="s1">&#39;Tried to use a singular supercell.&#39;</span><span class="p">)</span>
        <span class="n">invsuper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">superlatt</span><span class="p">)</span> <span class="o">*</span> <span class="n">size</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">maxN</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">superlatt</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">translist</span><span class="p">,</span> <span class="n">transdict</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">nvect</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">n0</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">))</span>
                      <span class="k">for</span> <span class="n">n0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">maxN</span><span class="p">,</span> <span class="n">maxN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">maxN</span><span class="p">,</span> <span class="n">maxN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">maxN</span><span class="p">,</span> <span class="n">maxN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]:</span>
            <span class="n">tv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">invsuper</span><span class="p">,</span> <span class="n">nvect</span><span class="p">)</span> <span class="o">%</span> <span class="n">size</span>
            <span class="n">ttup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tv</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ttup</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">transdict</span><span class="p">:</span>
                <span class="n">transdict</span><span class="p">[</span><span class="n">ttup</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">translist</span><span class="p">)</span>
                <span class="n">translist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tv</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">translist</span><span class="p">)</span> <span class="o">!=</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span>
                <span class="s1">&#39;Somehow did not generate the correct number of translations? </span><span class="si">{}</span><span class="s1">!=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">translist</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">size</span><span class="p">,</span> <span class="n">invsuper</span><span class="p">,</span> <span class="n">translist</span><span class="p">,</span> <span class="n">transdict</span></div>


<div class="viewcode-block" id="Supercell.makesites">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.makesites">[docs]</a>
    <span class="k">def</span> <span class="nf">makesites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the array corresponding to the sites; the indexing is based on the translations</span>
<span class="sd">        and the atomindices in crys. These may not all be filled when the supercell is finished.</span>

<span class="sd">        :return pos: array [N*size, 3] of supercell positions in direct coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">invsize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="n">basislist</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">invsuper</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomindices</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">crystal</span><span class="o">.</span><span class="n">incell</span><span class="p">((</span><span class="n">t</span> <span class="o">+</span> <span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="n">invsize</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">translist</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">basislist</span><span class="p">])</span></div>


<div class="viewcode-block" id="Supercell.gengroup">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.gengroup">[docs]</a>
    <span class="k">def</span> <span class="nf">gengroup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the group operations internal to the supercell</span>

<span class="sd">        :return G: set of GroupOps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Glist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">unittranslist</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">superlatt</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">translist</span><span class="p">]</span>
        <span class="n">invsize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="k">for</span> <span class="n">g0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">G</span><span class="p">:</span>
            <span class="n">Rsuper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">invsuper</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g0</span><span class="o">.</span><span class="n">rot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">superlatt</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">Rsuper</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s1">&#39;Broken symmetry? GroupOp:</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s1">not a symmetry operation of supercell?</span><span class="se">\n</span><span class="s1">Rsuper=</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g0</span><span class="p">,</span>
                                                                                                                <span class="n">Rsuper</span><span class="p">),</span>
                    <span class="ne">RuntimeWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># divide out the size (in inverse superlatt). Should still be an integer matrix (and hence, a symmetry)</span>
                <span class="n">Rsuper</span> <span class="o">//=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
            <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">unittranslist</span><span class="p">:</span>
                <span class="c1"># first, make the corresponding group operation by adding the unit cell translation:</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">g0</span> <span class="o">+</span> <span class="n">u</span>
                <span class="c1"># translation vector *in the supercell*; go ahead and keep it inside the supercell, too.</span>
                <span class="n">tsuper</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">invsuper</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">trans</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span> <span class="n">invsize</span>
                <span class="c1"># finally: indexmap!!</span>
                <span class="n">indexmap</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">R</span> <span class="ow">in</span> <span class="n">unittranslist</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomindices</span><span class="p">:</span>
                        <span class="n">Rp</span><span class="p">,</span> <span class="n">ci1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">g_pos</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">ci</span><span class="p">)</span>
                        <span class="c1"># A little confusing, but:</span>
                        <span class="c1"># [n]^-1*Rp -&gt; translation, but needs to be mod self.size</span>
                        <span class="c1"># convert to a tuple, to the index into transdict</span>
                        <span class="c1"># THEN multiply by self.N, and add the index of the new Wyckoff site. Whew!</span>
                        <span class="n">indexmap</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">transdict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">invsuper</span><span class="p">,</span> <span class="n">Rp</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexatom</span><span class="p">[</span><span class="n">ci1</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">indexmap</span><span class="p">))</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span><span class="s1">&#39;Did not produce a correct index mapping for GroupOp:</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
                <span class="n">Glist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">crystal</span><span class="o">.</span><span class="n">GroupOp</span><span class="p">(</span><span class="n">rot</span><span class="o">=</span><span class="n">Rsuper</span><span class="p">,</span> <span class="n">cartrot</span><span class="o">=</span><span class="n">g0</span><span class="o">.</span><span class="n">cartrot</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="n">tsuper</span><span class="p">,</span>
                                             <span class="n">indexmap</span><span class="o">=</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">indexmap</span><span class="p">),)))</span>
        <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">Glist</span><span class="p">)</span></div>


<div class="viewcode-block" id="Supercell.definesolute">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.definesolute">[docs]</a>
    <span class="k">def</span> <span class="nf">definesolute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">chemistry</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the name of the chemistry of chemical index c. Only works for substitutional solutes.</span>

<span class="sd">        :param c: index</span>
<span class="sd">        :param chemistry: string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">Nchem</span> <span class="ow">or</span> <span class="n">c</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nchem</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Trying to set the chemistry for a lattice atom / vacancy&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chemistry</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">chemistry</span></div>


<div class="viewcode-block" id="Supercell.setocc">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.setocc">[docs]</a>
    <span class="k">def</span> <span class="nf">setocc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the occupancy of position indexed by ind, to chemistry c. Used by all the other algorithms.</span>

<span class="sd">        :param ind: integer index</span>
<span class="sd">        :param c: chemistry index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">or</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">Nchem</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Trying to occupy with a non-defined chemistry: </span><span class="si">{}</span><span class="s1"> out of range&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
        <span class="n">corig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">occ</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">corig</span> <span class="o">!=</span> <span class="n">c</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">corig</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># remove from chemorder list (if not vacancy)</span>
                <span class="n">co</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemorder</span><span class="p">[</span><span class="n">corig</span><span class="p">]</span>
                <span class="n">co</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">co</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ind</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># add to chemorder list (if not vacancy)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">chemorder</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="c1"># finally: set the occupancy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">occ</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span></div>


<div class="viewcode-block" id="Supercell.fillperiodic">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.fillperiodic">[docs]</a>
    <span class="k">def</span> <span class="nf">fillperiodic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ci</span><span class="p">,</span> <span class="n">Wyckoff</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Occupies all of the (Wyckoff) sites corresponding to chemical index with the appropriate chemistry.</span>

<span class="sd">        :param ci: tuple of (chem, index) in crystal</span>
<span class="sd">        :param Wyckoff: (optional) if False, *only* occupy the specific tuple, but still periodically</span>
<span class="sd">        :return self:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ci</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexatom</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Tuple </span><span class="si">{}</span><span class="s1"> not a corresponding atom index&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ci</span><span class="p">))</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexatom</span><span class="p">[</span><span class="n">ci</span><span class="p">]</span>
        <span class="n">indlist</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">nset</span> <span class="k">for</span> <span class="n">nset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wyckofflist</span> <span class="k">if</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">nset</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">Wyckoff</span> <span class="k">else</span> <span class="p">(</span><span class="n">ind</span><span class="p">,)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="n">i</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indlist</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setocc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ci</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Supercell.occposlist">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.occposlist">[docs]</a>
    <span class="k">def</span> <span class="nf">occposlist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of lists of occupied positions, in (chem)order.</span>

<span class="sd">        :return occposlist: list of lists of supercell coord. positions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">clist</span><span class="p">]</span> <span class="k">for</span> <span class="n">clist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemorder</span><span class="p">]</span></div>


<div class="viewcode-block" id="Supercell.defect_chemmapping">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.defect_chemmapping">[docs]</a>
    <span class="k">def</span> <span class="nf">defect_chemmapping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a ``chemmapping`` dictionary corresponding to defects&quot;&quot;&quot;</span>
        <span class="n">chemmapping</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">Nchem</span><span class="p">):</span>
            <span class="c1"># start with anything on a site being &quot;occupied&quot;</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nchem</span><span class="p">)}</span>
            <span class="c1"># if it&#39;s an interstitial, vacancy == unoccupied; if its native, native chem == unoccupied</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interstitial</span><span class="p">:</span>
                <span class="n">cmap</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># vacancies are &quot;unoccupied&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cmap</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># &quot;correct&quot; site</span>
            <span class="n">chemmapping</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmap</span>
        <span class="k">return</span> <span class="n">chemmapping</span></div>


<div class="viewcode-block" id="Supercell.POSCAR">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.POSCAR">[docs]</a>
    <span class="k">def</span> <span class="nf">POSCAR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stoichiometry</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a VASP-style POSCAR, returned as a string.</span>

<span class="sd">        :param name: (optional) name to use for first list</span>
<span class="sd">        :param stoichiometry: (optional) if True, append stoichiometry to name</span>
<span class="sd">        :return POSCAR: string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">POSCAR</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">name</span>
        <span class="k">if</span> <span class="n">stoichiometry</span><span class="p">:</span> <span class="n">POSCAR</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometry</span><span class="p">()</span>
        <span class="n">POSCAR</span> <span class="o">+=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">1.0</span>
<span class="si">{a[0][0]:21.16f}</span><span class="s2"> </span><span class="si">{a[1][0]:21.16f}</span><span class="s2"> </span><span class="si">{a[2][0]:21.16f}</span>
<span class="si">{a[0][1]:21.16f}</span><span class="s2"> </span><span class="si">{a[1][1]:21.16f}</span><span class="s2"> </span><span class="si">{a[2][1]:21.16f}</span>
<span class="si">{a[0][2]:21.16f}</span><span class="s2"> </span><span class="si">{a[1][2]:21.16f}</span><span class="s2"> </span><span class="si">{a[2][2]:21.16f}</span>
<span class="s2">&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span>
        <span class="n">POSCAR</span> <span class="o">+=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clist</span><span class="p">))</span> <span class="k">for</span> <span class="n">clist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemorder</span><span class="p">])</span>
        <span class="n">POSCAR</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Direct</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">POSCAR</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot; </span><span class="si">{u[0]:19.16f}</span><span class="s2"> </span><span class="si">{u[1]:19.16f}</span><span class="s2"> </span><span class="si">{u[2]:19.16f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="n">u</span><span class="p">)</span>
                             <span class="k">for</span> <span class="n">clist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">occposlist</span><span class="p">()</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">clist</span><span class="p">])</span>
        <span class="c1"># needs a trailing newline</span>
        <span class="k">return</span> <span class="n">POSCAR</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span></div>


<div class="viewcode-block" id="Supercell.POSCAR_occ">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.POSCAR_occ">[docs]</a>
    <span class="k">def</span> <span class="nf">POSCAR_occ</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">POSCAR_str</span><span class="p">,</span> <span class="n">EMPTY_SUPER</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">disp_threshold</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">latt_threshold</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes in a POSCAR_str, and sets the occupancy of the supercell accordingly.</span>
<span class="sd">        Note: if we want to read a POSCAR from a file instead, the proper usage is</span>

<span class="sd">        ::</span>

<span class="sd">            with open(POSCAR_filename, &quot;r&quot;) as f:</span>
<span class="sd">                sup.from_POSCAR(f.read())</span>

<span class="sd">        Warning: there is only minimal validity checking; it makes a strong assumption</span>
<span class="sd">        that a reasonable POSCAR file is being given, and that the sites should correspond</span>
<span class="sd">        to the supercell object. Should that not be the case, the behavior is unspecified.</span>

<span class="sd">        :param POSCAR_str: string form of a POSCAR</span>
<span class="sd">        :param EMPTY_SUPER: initialize supercell by emptying it first (default=True)</span>
<span class="sd">        :param disp_threshold: threshold for difference in position to raise an error, in</span>
<span class="sd">            unit cell coordinates. For a negative value, we compute a value that is ~0.1A.</span>
<span class="sd">            If you do *not* want this check to be meaningful, choose a value &gt;sqrt(3)=1.733</span>
<span class="sd">        :param latt_threshold: threshold for supercell lattice check, in units of strain.</span>
<span class="sd">            For a negative values **do not check**.</span>
<span class="sd">        :return: name from the POSCAR</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">POSCAR_list</span> <span class="o">=</span> <span class="n">POSCAR_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>  <span class="c1"># break into lines</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">POSCAR_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">a0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">POSCAR_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">alist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">alist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">astr</span><span class="p">)</span> <span class="k">for</span> <span class="n">astr</span> <span class="ow">in</span> <span class="p">(</span><span class="n">POSCAR_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">split</span><span class="p">()]))</span>
        <span class="n">super_latt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">super_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">super_latt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">latt_threshold</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">super_latt</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">super_latt</span><span class="p">)</span>  <span class="c1"># metric tensor</span>
            <span class="n">super_metric</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span>  <span class="c1"># supercell metric tensor</span>
            <span class="n">max_diff</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">metric</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">super_metric</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">super_metric</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">super_metric</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
                           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">max_diff</span> <span class="o">&gt;</span> <span class="n">latt_threshold</span><span class="o">*</span><span class="n">latt_threshold</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="se">\n</span><span class="s1"> (supercell) and</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s1"> (POSCAR)</span><span class="se">\n</span><span class="s1">differ by </span><span class="si">{}</span><span class="s1"> &gt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">super_latt</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                                                                      <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">max_diff</span><span class="p">),</span> <span class="n">latt_threshold</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">disp_threshold</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># try to make a fairly liberal choice, based on the dimensions of the</span>
            <span class="c1"># supercell; essentially, this is ~0.1A</span>
            <span class="n">disp_threshold</span> <span class="o">=</span> <span class="mf">0.1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">super_latt</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">super_latt</span><span class="p">))))</span>
        <span class="c1"># we should probably do a sanity check: are we trying to occupy with a sensible</span>
        <span class="c1"># supercell? for now, we&#39;ll skip this.</span>
        <span class="n">chemlist</span> <span class="o">=</span> <span class="p">(</span><span class="n">POSCAR_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="c1"># this optional (?) line may specify the chemical element ordering, or it may</span>
        <span class="c1"># just be the element numbers; if it&#39;s the former, we need to parse:</span>
        <span class="k">if</span> <span class="s1">&#39;0&#39;</span> <span class="o">&lt;=</span> <span class="n">chemlist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="s1">&#39;9&#39;</span><span class="p">:</span>
            <span class="n">chemident</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chemlist</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chemident</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chemistry</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">chemlist</span><span class="p">]</span>
            <span class="n">chemlist</span> <span class="o">=</span> <span class="p">(</span><span class="n">POSCAR_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">Nspecies</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">chemlist</span><span class="p">]</span>
        <span class="n">coord_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">POSCAR_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="c1"># check for &quot;selective dynamics&quot; switch</span>
        <span class="k">if</span> <span class="n">coord_type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">}:</span>
            <span class="n">coord_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">POSCAR_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">cart_coord</span> <span class="o">=</span> <span class="n">coord_type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;K&#39;</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">EMPTY_SUPER</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setocc</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># finally, read all of the entries...</span>
        <span class="k">for</span> <span class="n">N</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Nspecies</span><span class="p">,</span> <span class="n">chemident</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">ustr</span> <span class="o">=</span> <span class="p">(</span><span class="n">POSCAR_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">uvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">ustr</span><span class="p">[:</span><span class="mi">3</span><span class="p">]])</span>
                <span class="k">if</span> <span class="n">cart_coord</span><span class="p">:</span>
                    <span class="n">uvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">super_inv</span><span class="p">,</span> <span class="n">uvec</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">uvec</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">disp_threshold</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Unable to map </span><span class="si">{}</span><span class="s1"> into supercell&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">uvec</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setocc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">name</span></div>


    <span class="n">__vacancyformat__</span> <span class="o">=</span> <span class="s2">&quot;v_</span><span class="si">{sitechem}</span><span class="s2">&quot;</span>
    <span class="n">__interstitialformat__</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{chem}</span><span class="s2">_i&quot;</span>
    <span class="n">__antisiteformat__</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{chem}</span><span class="s2">_</span><span class="si">{sitechem}</span><span class="s2">&quot;</span>

<div class="viewcode-block" id="Supercell.defectindices">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.defectindices">[docs]</a>
    <span class="k">def</span> <span class="nf">defectindices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dictionary that corresponds to the &quot;defect&quot; content of the supercell.</span>

<span class="sd">        :return defects: dictionary, keyed by defect type, with a set of indices of corresponding defects</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">adddefect</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">defects</span><span class="p">:</span>
                <span class="n">defects</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">defects</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">index</span><span class="p">])</span>

        <span class="n">defects</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">sitechem</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chemistry</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomindices</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">wset</span><span class="p">,</span> <span class="n">chem</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Wyckofflist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wyckoffchem</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">wset</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomindices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interstitial</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                        <span class="n">ind</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="n">i</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">occ</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">adddefect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__interstitialformat__</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chem</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chemistry</span><span class="p">[</span><span class="n">c</span><span class="p">]),</span> <span class="n">ind</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sc</span> <span class="o">=</span> <span class="n">sitechem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                        <span class="n">ind</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="n">i</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">occ</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemistry</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="n">sc</span><span class="p">:</span>
                            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vacancyformat__</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sitechem</span><span class="o">=</span><span class="n">sitechem</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> \
                                <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> \
                                <span class="bp">self</span><span class="o">.</span><span class="n">__antisiteformat__</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chem</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chemistry</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">sitechem</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span>
                            <span class="n">adddefect</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">defects</span></div>


<div class="viewcode-block" id="Supercell.KrogerVink">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.KrogerVink">[docs]</a>
    <span class="k">def</span> <span class="nf">KrogerVink</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempt to make a &quot;simple&quot; string based on the defectindices, using Kroger-Vink notation.</span>
<span class="sd">        That is, we identify: vacancies, antisites, and interstitial sites, and return a string.</span>
<span class="sd">        NOTE: there is no relative charges, so this is a pseudo-KV notation.</span>

<span class="sd">        :return KV: string representation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">defects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defectindices</span><span class="p">()</span>
        <span class="k">return</span> <span class="s1">&#39;+&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">defects</span><span class="p">[</span><span class="n">name</span><span class="p">]),</span> <span class="n">name</span><span class="p">)</span>
                         <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">defects</span><span class="p">[</span><span class="n">name</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">name</span>
                         <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">defects</span><span class="o">.</span><span class="n">keys</span><span class="p">())])</span></div>


<div class="viewcode-block" id="Supercell.reorder">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.reorder">[docs]</a>
    <span class="k">def</span> <span class="nf">reorder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapping</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reorder (in place) the occupied sites. Does not change the occupancies, only the ordering</span>
<span class="sd">        for &quot;presentation&quot;.</span>

<span class="sd">        :param mapping: list of maps; will make newchemorder[c][i] = chemorder[c][mapping[c][i]]</span>
<span class="sd">        :return self:</span>

<span class="sd">        If mapping is not a proper permutation, raises ValueError.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">neworder</span> <span class="o">=</span> <span class="p">[[</span><span class="n">clist</span><span class="p">[</span><span class="n">cmap</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clist</span><span class="p">))]</span>
                    <span class="k">for</span> <span class="n">clist</span><span class="p">,</span> <span class="n">cmap</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chemorder</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chemorder</span><span class="p">,</span> <span class="n">oldorder</span> <span class="o">=</span> <span class="n">neworder</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemorder</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sane__</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chemorder</span> <span class="o">=</span> <span class="n">oldorder</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Mapping </span><span class="si">{}</span><span class="s1"> is not a proper permutation&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mapping</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Supercell.equivalencemap">
<a class="viewcode-back" href="../supercell.html#supercell.Supercell.equivalencemap">[docs]</a>
    <span class="k">def</span> <span class="nf">equivalencemap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the superlatt ``other`` we want to find a group operation that transforms ``self``</span>
<span class="sd">        into other. This is a GroupOp *along* with an index mapping of chemorder. The index</span>
<span class="sd">        mapping is to get the occposlist to match up:</span>
<span class="sd">        ``(g*self).occposlist()[c][mapping[c][i]] == other.occposlist()[c][i]``</span>
<span class="sd">        (We can write a similar expression using chemorder, since chemorder indexes into pos).</span>
<span class="sd">        We&#39;re going to return both g and mapping.</span>

<span class="sd">        *Remember:* ``g`` does not change the presentation ordering; ``mapping`` is</span>
<span class="sd">        necessary for full equivalence. If no such equivalence, return ``None,None``.</span>

<span class="sd">        :param other: Supercell</span>
<span class="sd">        :return g: GroupOp to transform sites from ``self`` to ``other``</span>
<span class="sd">        :return mapping: list of maps, such that (g*self).chemorder[c][mapping[c][i]] == other.chemorder[c][i]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1. check that our defects even match up:</span>
        <span class="n">selfdefects</span><span class="p">,</span> <span class="n">otherdefects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defectindices</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">defectindices</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">selfdefects</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">otherdefects</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">otherdefects</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span> <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">otherdefects</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">selfdefects</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">selfdefects</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span> <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># 2. identify the shortest common set of defects:</span>
        <span class="n">defcount</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">selfdefects</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">deftype</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">defcount</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">defcount</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>  <span class="c1"># key to min value from dictionary</span>
        <span class="n">shortset</span><span class="p">,</span> <span class="n">matchset</span> <span class="o">=</span> <span class="n">selfdefects</span><span class="p">[</span><span class="n">deftype</span><span class="p">],</span> <span class="n">otherdefects</span><span class="p">[</span><span class="n">deftype</span><span class="p">]</span>

        <span class="n">mapping</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">gocc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">occ</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">:</span>
            <span class="c1"># 3. check against the shortest list of defects:</span>
            <span class="n">indexmap</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">indexmap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">indexmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">matchset</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">shortset</span><span class="p">):</span> <span class="k">continue</span>
            <span class="c1"># 4. having checked that shortlist, check the full mapping:</span>
            <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">gind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indexmap</span><span class="p">):</span>
                <span class="n">gocc</span><span class="p">[</span><span class="n">gind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">occ</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">gocc</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">occ</span><span class="p">):</span> <span class="k">continue</span>
            <span class="c1"># 5. we have a winner. Now it&#39;s all up to getting the mapping; done with index()</span>
            <span class="n">gorder</span> <span class="o">=</span> <span class="p">[[</span><span class="n">indexmap</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">clist</span><span class="p">]</span> <span class="k">for</span> <span class="n">clist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemorder</span><span class="p">]</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">gclist</span><span class="p">,</span> <span class="n">otherlist</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gorder</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">chemorder</span><span class="p">):</span>
                <span class="n">mapping</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">gclist</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">otherlist</span><span class="p">])</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">mapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mapping</span>
        <span class="k">return</span> <span class="n">g</span><span class="p">,</span> <span class="n">mapping</span></div>
</div>



<div class="viewcode-block" id="ClusterSupercell">
<a class="viewcode-back" href="../supercell.html#supercell.ClusterSupercell">[docs]</a>
<span class="k">class</span> <span class="nc">ClusterSupercell</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class that defines a Supercell of a crystal for purposes of evaluating a cluster expansion.</span>
<span class="sd">    We intend to use this with Monte Carlo sampling.</span>

<span class="sd">    Takes in a crystal, a supercell (3x3 integer matrix). We can identify sites</span>
<span class="sd">    as spectator sites (that is, they can have different occupancies, but we do not intend</span>
<span class="sd">    for those to change during a Monte Carlo simulation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ClusterSupercell.__init__">
<a class="viewcode-back" href="../supercell.html#supercell.ClusterSupercell.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crys</span><span class="p">,</span> <span class="n">superlatt</span><span class="p">,</span> <span class="n">spectator</span><span class="o">=</span><span class="p">()):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize our supercell to an empty supercell.</span>

<span class="sd">        :param crys: crystal object</span>
<span class="sd">        :param superlatt: 3x3 integer matrix</span>
<span class="sd">        :param spectator: list of indices of chemistries that will be considered &quot;spectators&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crys</span> <span class="o">=</span> <span class="n">crys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">superlatt</span> <span class="o">=</span> <span class="n">superlatt</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectator</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">spectator</span><span class="p">)]</span>  <span class="c1"># only keep unique values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectator</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mobile</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">crys</span><span class="o">.</span><span class="n">Nchem</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectator</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nchem</span> <span class="o">=</span> <span class="n">crys</span><span class="o">.</span><span class="n">Nchem</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectator</span><span class="p">)</span>
        <span class="c1"># everything else that follows is &quot;derived&quot; from those initial parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">superlatt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectatorindices</span> <span class="o">=</span> <span class="p">[(</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectator</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">crys</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">c</span><span class="p">]))]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mobileindices</span> <span class="o">=</span> <span class="p">[(</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mobile</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">crys</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">c</span><span class="p">]))]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexspectator</span> <span class="o">=</span> <span class="p">{</span><span class="n">ci</span><span class="p">:</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">ci</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectatorindices</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexmobile</span> <span class="o">=</span> <span class="p">{</span><span class="n">ci</span><span class="p">:</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">ci</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mobileindices</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nspec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nmobile</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectatorindices</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mobileindices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">invsuper</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">translist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transdict</span> <span class="o">=</span> <span class="n">Supercell</span><span class="o">.</span><span class="n">maketrans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">superlatt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">specpos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mobilepos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">makesites</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Rveclist</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">superlatt</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">translist</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vacancy</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># assume there no vacancy</span></div>

        <span class="c1"># self.pos, self.occ = self.makesites(), -1 * np.ones(self.N * self.size, dtype=int)</span>

<div class="viewcode-block" id="ClusterSupercell.addvacancy">
<a class="viewcode-back" href="../supercell.html#supercell.ClusterSupercell.addvacancy">[docs]</a>
    <span class="k">def</span> <span class="nf">addvacancy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds a vacancy into the mobile species at a specific index&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vacancy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i_ind</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i_ind</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i_ind</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nmobile</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is out of range; should be between 0 and </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nmobile</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vacancy</span> <span class="o">=</span> <span class="n">i_ind</span></div>


<div class="viewcode-block" id="ClusterSupercell.makesites">
<a class="viewcode-back" href="../supercell.html#supercell.ClusterSupercell.makesites">[docs]</a>
    <span class="k">def</span> <span class="nf">makesites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the array corresponding to the sites; the indexing is based on the translations</span>
<span class="sd">        and the atomindices in crys. These may not all be filled when the supercell is finished.</span>

<span class="sd">        :return pos: array [N*size, 3] of supercell positions in direct coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">invsize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="n">specbasislist</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">invsuper</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectatorindices</span><span class="p">]</span>
        <span class="n">mobilebasislist</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">invsuper</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mobileindices</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">crystal</span><span class="o">.</span><span class="n">incell</span><span class="p">((</span><span class="n">t</span> <span class="o">+</span> <span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="n">invsize</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">translist</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">specbasislist</span><span class="p">]),</span> \
               <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">crystal</span><span class="o">.</span><span class="n">incell</span><span class="p">((</span><span class="n">t</span> <span class="o">+</span> <span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="n">invsize</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">translist</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">mobilebasislist</span><span class="p">])</span></div>


<div class="viewcode-block" id="ClusterSupercell.incell">
<a class="viewcode-back" href="../supercell.html#supercell.ClusterSupercell.incell">[docs]</a>
    <span class="k">def</span> <span class="nf">incell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Map a lattice vector into a translation vector in the cell&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">invsuper</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span></div>


<div class="viewcode-block" id="ClusterSupercell.ciR">
<a class="viewcode-back" href="../supercell.html#supercell.ClusterSupercell.ciR">[docs]</a>
    <span class="k">def</span> <span class="nf">ciR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">mobile</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the chem/index and lattice vector for a specific indexed position</span>

<span class="sd">        :param ind: index of site</span>
<span class="sd">        :param mobile: True if mobile; false if spectator</span>
<span class="sd">        :return ci: (c, i) index</span>
<span class="sd">        :return R: lattice vector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mobile</span><span class="p">:</span>
            <span class="n">N</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nmobile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mobileindices</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">N</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nspec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectatorindices</span>
        <span class="k">return</span> <span class="n">indices</span><span class="p">[</span><span class="n">ind</span> <span class="o">%</span> <span class="n">N</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rveclist</span><span class="p">[</span><span class="n">ind</span> <span class="o">//</span> <span class="n">N</span><span class="p">]</span></div>


<div class="viewcode-block" id="ClusterSupercell.index">
<a class="viewcode-back" href="../supercell.html#supercell.ClusterSupercell.index">[docs]</a>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">ci</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the index that corresponds to a position specified by a lattice vector R and</span>
<span class="sd">        a chem/index (c,i). We also need to specify if its in the spectator basis or mobile basis.</span>

<span class="sd">        :param R: lattice vector</span>
<span class="sd">        :param ci: (c, i) index</span>
<span class="sd">        :return ind: index of site in our position</span>
<span class="sd">        :return mobile: boolean; True if mobile, False if spectator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ci</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexmobile</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transdict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">incell</span><span class="p">(</span><span class="n">R</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nmobile</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexmobile</span><span class="p">[</span><span class="n">ci</span><span class="p">],</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transdict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">incell</span><span class="p">(</span><span class="n">R</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nspec</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexspectator</span><span class="p">[</span><span class="n">ci</span><span class="p">],</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="ClusterSupercell.indexpos">
<a class="viewcode-back" href="../supercell.html#supercell.ClusterSupercell.indexpos">[docs]</a>
    <span class="k">def</span> <span class="nf">indexpos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">CARTESIAN</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the index that corresponds to the position *closest* to pos in the supercell.</span>
<span class="sd">        Done in direct coordinates of the supercell, using periodic boundary conditions.</span>

<span class="sd">        :param pos: 3-vector</span>
<span class="sd">        :param threshold: (optional) minimum squared &quot;distance&quot; in supercell for a match; default=1.</span>
<span class="sd">        :return index: index of closest position</span>
<span class="sd">        :return mobile: boolean; True if mobile, False if spectator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span><span class="p">,</span> <span class="n">dist2</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specpos</span><span class="p">):</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">crystal</span><span class="o">.</span><span class="n">inhalf</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">delta</span> <span class="o">*</span> <span class="n">delta</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d2</span> <span class="o">&lt;</span> <span class="n">dist2</span><span class="p">:</span> <span class="n">index</span><span class="p">,</span> <span class="n">dist2</span> <span class="o">=</span> <span class="n">ind</span><span class="p">,</span> <span class="n">d2</span>
        <span class="n">dspec_min</span> <span class="o">=</span> <span class="n">dist2</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mobilepos</span><span class="p">):</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">crystal</span><span class="o">.</span><span class="n">inhalf</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">delta</span> <span class="o">*</span> <span class="n">delta</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d2</span> <span class="o">&lt;</span> <span class="n">dist2</span><span class="p">:</span> <span class="n">index</span><span class="p">,</span> <span class="n">dist2</span> <span class="o">=</span> <span class="n">ind</span><span class="p">,</span> <span class="n">d2</span>
        <span class="c1"># if dist2 is smaller than dspec_min, it&#39;s mobile:</span>
        <span class="k">return</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">dist2</span> <span class="o">&lt;</span> <span class="n">dspec_min</span><span class="p">)</span></div>


<div class="viewcode-block" id="ClusterSupercell.expiqx">
<a class="viewcode-back" href="../supercell.html#supercell.ClusterSupercell.expiqx">[docs]</a>
    <span class="k">def</span> <span class="nf">expiqx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a Fourier transform matrix for our mobile species</span>

<span class="sd">        :return: exp( I q[i] . x[j]) as a matrix</span>
<span class="sd">        :return: gamma_index of the gamma point (0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we need to get the rlv this way:</span>
        <span class="n">size</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">qtranslist</span><span class="p">,</span> <span class="n">transdict</span> <span class="o">=</span> <span class="n">Supercell</span><span class="o">.</span><span class="n">maketrans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">superlatt</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">invsize</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">size</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">phase</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">superlatt</span><span class="p">,</span> <span class="n">u</span><span class="p">),</span> <span class="n">q</span><span class="o">*</span><span class="n">invsize</span><span class="p">))</span>
                          <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mobilepos</span><span class="p">]</span>
                         <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">qtranslist</span><span class="p">]),</span> \
               <span class="n">transdict</span><span class="p">[(</span><span class="mi">0</span><span class="p">,)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">dim</span><span class="p">]</span></div>


<div class="viewcode-block" id="ClusterSupercell.Supercell_occ">
<a class="viewcode-back" href="../supercell.html#supercell.ClusterSupercell.Supercell_occ">[docs]</a>
    <span class="k">def</span> <span class="nf">Supercell_occ</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sup</span><span class="p">,</span> <span class="n">chemmapping</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes in a Supercell object (that is assumed to be consistent with this supercell!)</span>
<span class="sd">        and produces the corresponding occupancy vectors for *this* supercell, using a</span>
<span class="sd">        specific chemical mapping (described below).</span>

<span class="sd">        In a Supercell object, each *site* has a &quot;native&quot; chemistry; moreover, those sites</span>
<span class="sd">        may be occupied by everything from a vacancy (-1) to a different chemical element (&gt;=0).</span>
<span class="sd">        We need to define how that happens, since ClusterSupercells only have occupancies of 0 or 1.</span>

<span class="sd">        ``chemmapping`` is a dictionary of dictionaries. ``chemmapping[csite][cocc]`` = 0 or 1</span>
<span class="sd">        to dictate what the occupancy for a site *should* be if chemistry of type ``cocc`` occurs</span>
<span class="sd">        on a site with native chemistry ``csite``.</span>

<span class="sd">        If the ``chemmapping`` is None, we use a default &quot;defect&quot; occupancy mapping; namely,</span>
<span class="sd">        if ``csite`` != Interstitial, then we use 0 when ``csite==cocc``, 1 otherwise; and</span>
<span class="sd">        if ``csite`` == Interstitial, we use 0 when ``csite==-1``, 1 otherwise. See</span>
<span class="sd">        ``Supercell.defect_chemmapping()``</span>

<span class="sd">        :param sup: Supercell object, with appropriate chemical occupancies</span>
<span class="sd">        :param chemmapping: mapping of chemical identities to occupancy variables.</span>
<span class="sd">        :return mocc: mobile occupancy vector</span>
<span class="sd">        :return socc: spectator occupancy vector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">chemmapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chemmapping</span> <span class="o">=</span> <span class="n">sup</span><span class="o">.</span><span class="n">defect_chemmapping</span><span class="p">()</span>
        <span class="n">mocc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nmobile</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">socc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nspec</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># now, we just run through the positions in *this* supercell, and get the occupancy</span>
        <span class="c1"># in the other supercell. Consistency is key!</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mobilepos</span><span class="p">):</span>
            <span class="n">csite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mobileindices</span><span class="p">[</span><span class="n">ind</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nmobile</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># get the site chemistry</span>
            <span class="n">cocc</span> <span class="o">=</span> <span class="n">sup</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>  <span class="c1"># get the occupancy chemistry</span>
            <span class="n">mocc</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">chemmapping</span><span class="p">[</span><span class="n">csite</span><span class="p">][</span><span class="n">cocc</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specpos</span><span class="p">):</span>
            <span class="n">csite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectatorindices</span><span class="p">[</span><span class="n">ind</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nspec</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># get the site chemistry</span>
            <span class="n">cocc</span> <span class="o">=</span> <span class="n">sup</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>  <span class="c1"># get the occupancy chemistry</span>
            <span class="n">socc</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">chemmapping</span><span class="p">[</span><span class="n">csite</span><span class="p">][</span><span class="n">cocc</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">mocc</span><span class="p">,</span> <span class="n">socc</span></div>


<div class="viewcode-block" id="ClusterSupercell.evalcluster">
<a class="viewcode-back" href="../supercell.html#supercell.ClusterSupercell.evalcluster">[docs]</a>
    <span class="k">def</span> <span class="nf">evalcluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mocc</span><span class="p">,</span> <span class="n">socc</span><span class="p">,</span> <span class="n">clusters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate a cluster expansion for a given mobile occupancy and spectator occupancy.</span>
<span class="sd">        Indexing corresponds to ``mobilepos`` and ``specpos``. The clusters are input as a</span>
<span class="sd">        list of lists of clusters (where it is assumed that all of the clusters in a given</span>
<span class="sd">        sublist have equal coefficients (i.e., grouped by symmetry). We return a vector</span>
<span class="sd">        of length Nclusters + 1; each entry is the number of times each cluster appears,</span>
<span class="sd">        and the *last* entry is equal to the size of the supercell (which would be an</span>
<span class="sd">        &quot;empty&quot; cluster). This can then be dotted into the vector of values to get the</span>
<span class="sd">        cluster expansion value.</span>

<span class="sd">        :param mocc: mobile occupancy vector (0 or 1 only)</span>
<span class="sd">        :param socc: spectator occupancy vector (0 or 1 only)</span>
<span class="sd">        :param clusters: list of lists (or sets) of Cluster objects</span>
<span class="sd">        :return: clustercount: count of how many of each cluster is in this supercell.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">isocc</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">ci</span><span class="p">):</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">mob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">ci</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mob</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">mocc</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">socc</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>

        <span class="c1"># treatment for vacancy clusters...</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vacancy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># sanity check:</span>
            <span class="k">if</span> <span class="n">mocc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vacancy</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeWarning</span><span class="p">(</span><span class="s1">&#39;Supercell contains a vacancy at </span><span class="si">{}</span><span class="s1"> but mobile occupancy == 1?&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vacancy</span><span class="p">))</span>
            <span class="n">ci_vac</span><span class="p">,</span> <span class="n">R_vac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ciR</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vacancy</span><span class="p">)</span>

        <span class="n">clustercount</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">clustercount</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="k">for</span> <span class="n">mc</span><span class="p">,</span> <span class="n">clusterlist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">clust</span> <span class="ow">in</span> <span class="n">clusterlist</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">clust</span><span class="o">.</span><span class="n">__vacancy__</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vacancy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">continue</span>
                    <span class="k">elif</span> <span class="n">clust</span><span class="o">.</span><span class="n">vacancy</span><span class="p">()</span><span class="o">.</span><span class="n">ci</span> <span class="o">!=</span> <span class="n">ci_vac</span><span class="p">:</span> <span class="k">continue</span>
                    <span class="n">Rveclist</span> <span class="o">=</span> <span class="p">[</span><span class="n">R_vac</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Rveclist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rveclist</span>
                <span class="k">for</span> <span class="n">R</span> <span class="ow">in</span> <span class="n">Rveclist</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">isocc</span><span class="p">(</span><span class="n">R</span> <span class="o">+</span> <span class="n">site</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span><span class="p">)</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">clust</span><span class="p">):</span>
                        <span class="n">clustercount</span><span class="p">[</span><span class="n">mc</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">clustercount</span></div>


<div class="viewcode-block" id="ClusterSupercell.expandcluster_matrices">
<a class="viewcode-back" href="../supercell.html#supercell.ClusterSupercell.expandcluster_matrices">[docs]</a>
    <span class="k">def</span> <span class="nf">expandcluster_matrices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">socc</span><span class="p">,</span> <span class="n">clusters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expand a cluster expansion for a given spectator occupancy into matrices of indices.</span>
<span class="sd">        This is designed for rapid evaluation for a fixed spectator occupancy. The clusters are</span>
<span class="sd">        input as a list of lists of clusters (i.e., grouped by symmetry). We return a list of</span>
<span class="sd">        lists of integer matrices of indices. This can then be used to efficiently evaluate cluster</span>
<span class="sd">        counts for a given mobile occupancy. The given row of indices must be all 1 in order to</span>
<span class="sd">        increment the particular cluster count.</span>

<span class="sd">        :param socc: spectator occupancy vector (0 or 1 only)</span>
<span class="sd">        :param clusters: list of lists (or sets) of Cluster objects</span>
<span class="sd">        :return: clustermatrices: list of lists of matrices of indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># treatment for vacancy clusters...</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vacancy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># sanity check:</span>
            <span class="n">ci_vac</span><span class="p">,</span> <span class="n">R_vac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ciR</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vacancy</span><span class="p">)</span>

        <span class="n">clustermatrices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">clusterlist</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="n">clmat_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">clust</span> <span class="ow">in</span> <span class="n">clusterlist</span><span class="p">:</span>
                <span class="n">cl_indices</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="n">clust</span><span class="o">.</span><span class="n">__vacancy__</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vacancy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">continue</span>
                    <span class="k">elif</span> <span class="n">clust</span><span class="o">.</span><span class="n">vacancy</span><span class="p">()</span><span class="o">.</span><span class="n">ci</span> <span class="o">!=</span> <span class="n">ci_vac</span><span class="p">:</span> <span class="k">continue</span>
                    <span class="n">Rveclist</span> <span class="o">=</span> <span class="p">[</span><span class="n">R_vac</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Rveclist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rveclist</span>
                <span class="k">for</span> <span class="n">R</span> <span class="ow">in</span> <span class="n">Rveclist</span><span class="p">:</span>
                    <span class="c1"># list of indices, and whether the particular set is &quot;active&quot;</span>
                    <span class="n">ind</span><span class="p">,</span> <span class="n">active</span> <span class="o">=</span> <span class="p">[],</span> <span class="kc">True</span>
                    <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">clust</span><span class="p">:</span>
                        <span class="n">n</span><span class="p">,</span> <span class="n">mob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">R</span> <span class="o">+</span> <span class="n">site</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">mob</span><span class="p">:</span>
                            <span class="n">ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">active</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">socc</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">active</span><span class="p">:</span>
                        <span class="n">cl_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                <span class="n">clmat_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cl_indices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
            <span class="n">clustermatrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clmat_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">clustermatrices</span></div>


<div class="viewcode-block" id="ClusterSupercell.evalTScluster">
<a class="viewcode-back" href="../supercell.html#supercell.ClusterSupercell.evalTScluster">[docs]</a>
    <span class="k">def</span> <span class="nf">evalTScluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mocc</span><span class="p">,</span> <span class="n">socc</span><span class="p">,</span> <span class="n">TSclusters</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="n">final</span><span class="p">,</span> <span class="n">dx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate a TS cluster expansion for a given mobile occupancy and spectator occupancy.</span>
<span class="sd">        Indexing corresponds to ``mobilepos`` and ``specpos``. The clusters are input as a</span>
<span class="sd">        list of lists of clusters (where it is assumed that all of the clusters in a given</span>
<span class="sd">        sublist have equal coefficients (i.e., grouped by symmetry). We return a vector</span>
<span class="sd">        of length Nclusters; each entry is the number of times each cluster appears.</span>
<span class="sd">        This can then be dotted into the vector of values to get the cluster expansion value.</span>
<span class="sd">        This is evaluated for the transition where the mobile species at ``initial`` jumps</span>
<span class="sd">        to the position at ``final``. Requires mocc[initial] == 1 and mocc[final] == 0</span>

<span class="sd">        :param mocc: mobile occupancy vector (0 or 1 only)</span>
<span class="sd">        :param socc: spectator occupancy vector (0 or 1 only)</span>
<span class="sd">        :param TSclusters: list of lists (or sets) of (transition state) Cluster objects</span>
<span class="sd">        :param initial: index of initial state</span>
<span class="sd">        :param final: index of final state</span>
<span class="sd">        :param dx: displacement vector (necessary to deal with PBC)</span>
<span class="sd">        :return: clustercount: count of how many of each cluster is in this supercell.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">isocc</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">ci</span><span class="p">):</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">mob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">ci</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mob</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">vacancy</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Checked the occupancy for the vacancy?&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">mocc</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">socc</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>

        <span class="n">clustercount</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">TSclusters</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">vacancy</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vacancy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vacancy</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">initial</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vacancy</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeWarning</span><span class="p">(</span><span class="s1">&#39;Attempting to evaluate in cell with vacancy at &#39;</span>
                                     <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> but TS= </span><span class="si">{}</span><span class="s1">-&gt;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vacancy</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="n">final</span><span class="p">))</span>
                <span class="c1"># return clustercount  # we can only evaluate this meaningfully for our vacancy</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">mocc</span><span class="p">[</span><span class="n">initial</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">mocc</span><span class="p">[</span><span class="n">final</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">clustercount</span>  <span class="c1"># trivial result...</span>
        <span class="n">ci_i</span><span class="p">,</span> <span class="n">Ri</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ciR</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
        <span class="n">ci_j</span><span class="p">,</span> <span class="n">Rj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ciR</span><span class="p">(</span><span class="n">final</span><span class="p">)</span>
        <span class="c1"># need to fix this so that it matches dx!!</span>
        <span class="c1"># dR = Rj - Ri</span>
        <span class="n">chem</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">ci_i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ci_i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ci_j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">invlatt</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">chem</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">chem</span><span class="p">][</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">cs_i0</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">ClusterSite</span><span class="p">(</span><span class="n">ci_i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">cs_j0</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">ClusterSite</span><span class="p">(</span><span class="n">ci_j</span><span class="p">,</span> <span class="n">dR</span><span class="p">)</span>
        <span class="n">cs_i1</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">ClusterSite</span><span class="p">(</span><span class="n">ci_i</span><span class="p">,</span> <span class="o">-</span><span class="n">dR</span><span class="p">)</span>
        <span class="n">cs_j1</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">ClusterSite</span><span class="p">(</span><span class="n">ci_j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">mc</span><span class="p">,</span> <span class="n">clusterlist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">TSclusters</span><span class="p">):</span>
            <span class="c1"># if next(iter(clusterlist)).__vacancy__:</span>
            <span class="c1">#     raise NotImplementedError(&#39;TS cluster evaluation for vacancy jumps not currently implemented&#39;)</span>
            <span class="k">for</span> <span class="n">clust</span> <span class="ow">in</span> <span class="n">clusterlist</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">cs_i0</span><span class="p">,</span> <span class="n">cs_j0</span><span class="p">)</span> <span class="o">==</span> <span class="n">clust</span><span class="o">.</span><span class="n">transitionstate</span><span class="p">():</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">isocc</span><span class="p">(</span><span class="n">Ri</span> <span class="o">+</span> <span class="n">site</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span><span class="p">)</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">clust</span><span class="p">):</span>
                        <span class="n">clustercount</span><span class="p">[</span><span class="n">mc</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">vacancy</span> <span class="ow">and</span> <span class="p">(</span><span class="n">cs_j1</span><span class="p">,</span> <span class="n">cs_i1</span><span class="p">)</span> <span class="o">==</span> <span class="n">clust</span><span class="o">.</span><span class="n">transitionstate</span><span class="p">():</span>
                <span class="c1"># elif (cs_j1, cs_i1) == clust.transitionstate():</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">isocc</span><span class="p">(</span><span class="n">Rj</span> <span class="o">+</span> <span class="n">site</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span><span class="p">)</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">clust</span><span class="p">):</span>
                        <span class="n">clustercount</span><span class="p">[</span><span class="n">mc</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">clustercount</span></div>


<div class="viewcode-block" id="ClusterSupercell.clusterevaluator">
<a class="viewcode-back" href="../supercell.html#supercell.ClusterSupercell.clusterevaluator">[docs]</a>
    <span class="k">def</span> <span class="nf">clusterevaluator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">socc</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the information necessary for an (efficient) cluster evaluator,</span>
<span class="sd">        for a given spectator occupancy, set of clusters, and values for those clusters.</span>

<span class="sd">        :param socc: spectator occupancy vector (0 or 1 only)</span>
<span class="sd">        :param clusters: list of lists (or sets) of Cluster objects</span>
<span class="sd">        :param values: vector of values for the clusters; if it is longer than the</span>
<span class="sd">          list of clusters by one, the last values is assumed to be the constant value.</span>
<span class="sd">        :return siteinteract: list of lists of interactions for each site</span>
<span class="sd">        :return interact: list of interaction values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">E0</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">):</span>
            <span class="n">E0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Ninteract</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">interact</span><span class="p">,</span> <span class="n">interdict</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">{}</span>
        <span class="n">siteinteract</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nmobile</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vacancy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ci_vac</span><span class="p">,</span> <span class="n">R_vac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ciR</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vacancy</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">clusterlist</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">clust</span> <span class="ow">in</span> <span class="n">clusterlist</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">clust</span><span class="o">.</span><span class="n">__vacancy__</span><span class="p">:</span>
                    <span class="c1"># do we have a vacancy in the right place?</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vacancy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">continue</span>
                    <span class="k">elif</span> <span class="n">clust</span><span class="o">.</span><span class="n">vacancy</span><span class="p">()</span><span class="o">.</span><span class="n">ci</span> <span class="o">!=</span> <span class="n">ci_vac</span><span class="p">:</span> <span class="k">continue</span>
                    <span class="c1"># now, set it up!</span>
                    <span class="n">Rveclist</span> <span class="o">=</span> <span class="p">[</span><span class="n">R_vac</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Rveclist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rveclist</span>
                <span class="c1"># split into mobile and spectator</span>
                <span class="n">mobilesites</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">clust</span> <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexmobile</span><span class="p">]</span>
                <span class="n">specsites</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">clust</span> <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexspectator</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">R</span> <span class="ow">in</span> <span class="n">Rveclist</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">socc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">R</span> <span class="o">+</span> <span class="n">site</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">specsites</span><span class="p">):</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mobilesites</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># spectator only == constant</span>
                            <span class="n">E0</span> <span class="o">+=</span> <span class="n">value</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">intertuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">R</span> <span class="o">+</span> <span class="n">site</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">mobilesites</span><span class="p">))</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vacancy</span> <span class="ow">in</span> <span class="n">intertuple</span><span class="p">:</span>
                                <span class="k">continue</span>
                            <span class="k">if</span> <span class="n">intertuple</span> <span class="ow">in</span> <span class="n">interdict</span><span class="p">:</span>
                                <span class="c1"># if we&#39;ve already seen this particular interaction, add to the value</span>
                                <span class="n">interact</span><span class="p">[</span><span class="n">interdict</span><span class="p">[</span><span class="n">intertuple</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">value</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># new interaction!</span>
                                <span class="n">interact</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                                <span class="n">interdict</span><span class="p">[</span><span class="n">intertuple</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ninteract</span>
                                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">intertuple</span><span class="p">:</span>
                                    <span class="n">siteinteract</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Ninteract</span><span class="p">)</span>
                                <span class="n">Ninteract</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># add on our constant term</span>
        <span class="n">interact</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">siteinteract</span><span class="p">,</span> <span class="n">interact</span></div>


<div class="viewcode-block" id="ClusterSupercell.jumpnetworkevaluator">
<a class="viewcode-back" href="../supercell.html#supercell.ClusterSupercell.jumpnetworkevaluator">[docs]</a>
    <span class="k">def</span> <span class="nf">jumpnetworkevaluator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">socc</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">chem</span><span class="p">,</span> <span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">KRAvalues</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                             <span class="n">TSclusters</span><span class="o">=</span><span class="p">(),</span> <span class="n">TSvalues</span><span class="o">=</span><span class="p">(),</span>
                             <span class="n">siteinteract</span><span class="o">=</span><span class="p">(),</span> <span class="n">interact</span><span class="o">=</span><span class="p">()):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build out an efficient jump network evaluator. Similar inputs to ``clusterevaluator``,</span>
<span class="sd">        with the addition of a jumpnetwork and energies. The interactions can be appended</span>
<span class="sd">        onto existing interactions, if included. The information about all of the</span>
<span class="sd">        transitions is: initial state, final state, delta x.</span>

<span class="sd">        :param socc: spectator occupancy vector (0 or 1 only)</span>
<span class="sd">        :param clusters: list of lists (or sets) of Cluster objects</span>
<span class="sd">        :param values: vector of values for the clusters; if it is longer than the</span>
<span class="sd">          list of clusters by one, the last values is assumed to be the constant value.</span>
<span class="sd">        :param chem: index of species that transitions</span>
<span class="sd">        :param jumpnetwork: list of lists of jumps; each is ((i, j), dx) where ``i`` and ``j`` are</span>
<span class="sd">          unit cell indices for species ``chem``</span>
<span class="sd">        :param KRAvalues: list of &quot;KRA&quot; values for barriers (relative to average energy of endpoints);</span>
<span class="sd">          if ``TSclusters`` are used, choosing 0 is more straightforward.</span>
<span class="sd">        :param TSclusters: (optional) list of transition state cluster expansion terms; this is</span>
<span class="sd">          always added on to KRAvalues (thus using 0 is recommended if TSclusters are also used)</span>
<span class="sd">        :param TSvalues: (optional) values for TS cluster expansion entries</span>
<span class="sd">        :param siteinteract: (optional) list of lists of interactions for each site, to append</span>
<span class="sd">        :param interact: (optional) list of interaction values, to append</span>

<span class="sd">        :return siteinteract: list of lists of interactions for each site</span>
<span class="sd">        :return interact: list of interaction values</span>
<span class="sd">        :return jumps: list of ((initial, final), dx)</span>
<span class="sd">        :return interactrange: range of indices to count in interact for each jump; for the nth</span>
<span class="sd">          jump, sum over interactrange[n-1]:interactrange[n]; interactrange[-1] == range for energy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">KRAvalues</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">KRAvalues</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">jumpnetwork</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incorrect length for KRAvalues: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">KRAvalues</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">KRAvalues</span> <span class="o">=</span> <span class="n">KRAvalues</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">jumpnetwork</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incorrect length for values: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">TSclusters</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">TSvalues</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incorrect length for TSvalues: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">TSvalues</span><span class="p">))</span>
        <span class="n">siteinteract</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">siteinteract</span><span class="p">)</span>
        <span class="n">interact</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">interact</span><span class="p">)</span>
        <span class="n">Ninteract</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">interact</span><span class="p">)</span>
        <span class="n">Ninteract0</span> <span class="o">=</span> <span class="n">Ninteract</span>  <span class="c1"># we store this now, so that we can make interactrange[-1] = Ninteract0</span>
        <span class="c1"># &quot;flatten&quot; the clusters for more efficient operations:</span>
        <span class="c1"># clusterinteract[(c,i)] = list of ([cs list], value) of interactions centered on (c, i)</span>
        <span class="c1"># NOTE: in order to maintain detailed balance, we use half the energy difference of the</span>
        <span class="c1"># initial and final states, so we go ahead and multiply by 0.5 here for efficiency.</span>
        <span class="n">clusterinteract</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">clusterlist</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">clust</span> <span class="ow">in</span> <span class="n">clusterlist</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">cs</span> <span class="ow">in</span> <span class="n">clust</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cs</span><span class="o">.</span><span class="n">ci</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexmobile</span><span class="p">:</span>
                        <span class="c1"># get the list of other sites, and split into mobile and spectator:</span>
                        <span class="n">cllist</span> <span class="o">=</span> <span class="n">clust</span> <span class="o">-</span> <span class="n">cs</span>
                        <span class="n">mobilesites</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">cllist</span> <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexmobile</span><span class="p">]</span>
                        <span class="n">specsites</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">cllist</span> <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexspectator</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">cs</span><span class="o">.</span><span class="n">ci</span> <span class="ow">in</span> <span class="n">clusterinteract</span><span class="p">:</span>
                            <span class="n">clusterinteract</span><span class="p">[</span><span class="n">cs</span><span class="o">.</span><span class="n">ci</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mobilesites</span><span class="p">,</span> <span class="n">specsites</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">value</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">clusterinteract</span><span class="p">[</span><span class="n">cs</span><span class="o">.</span><span class="n">ci</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">mobilesites</span><span class="p">,</span> <span class="n">specsites</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">value</span><span class="p">)]</span>
        <span class="c1"># &quot;flatten&quot; the TS clusters. To simplify, we put in both forward and backward jumps</span>
        <span class="n">TSclusterinteract</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">TSclusterlist</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">TSclusters</span><span class="p">,</span> <span class="n">TSvalues</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">TSclust</span> <span class="ow">in</span> <span class="n">TSclusterlist</span><span class="p">:</span>
                <span class="n">TS</span> <span class="o">=</span> <span class="n">TSclust</span><span class="o">.</span><span class="n">transitionstate</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">TS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ci</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexmobile</span> <span class="ow">and</span> <span class="n">TS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ci</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexmobile</span><span class="p">:</span>
                    <span class="n">R0</span> <span class="o">=</span> <span class="n">TS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">R</span>
                    <span class="n">TS0</span> <span class="o">=</span> <span class="p">(</span><span class="n">TS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">R0</span><span class="p">,</span> <span class="n">TS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">R0</span><span class="p">)</span>
                    <span class="n">mobilesites</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span> <span class="o">-</span> <span class="n">R0</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">TSclust</span> <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexmobile</span><span class="p">]</span>
                    <span class="n">specsites</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span> <span class="o">-</span> <span class="n">R0</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">TSclust</span> <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexspectator</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">TS0</span> <span class="ow">in</span> <span class="n">TSclusterinteract</span><span class="p">:</span>
                        <span class="n">TSclusterinteract</span><span class="p">[</span><span class="n">TS0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mobilesites</span><span class="p">,</span> <span class="n">specsites</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">TSclusterinteract</span><span class="p">[</span><span class="n">TS0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">mobilesites</span><span class="p">,</span> <span class="n">specsites</span><span class="p">,</span> <span class="n">value</span><span class="p">)]</span>
                    <span class="n">R1</span> <span class="o">=</span> <span class="n">TS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">R</span>
                    <span class="n">mobilesites</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span> <span class="o">-</span> <span class="n">R1</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">TSclust</span> <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexmobile</span><span class="p">]</span>
                    <span class="n">specsites</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span> <span class="o">-</span> <span class="n">R1</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">TSclust</span> <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexspectator</span><span class="p">]</span>
                    <span class="n">TS1</span> <span class="o">=</span> <span class="p">(</span><span class="n">TS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">R1</span><span class="p">,</span> <span class="n">TS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">R1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">TS1</span> <span class="ow">in</span> <span class="n">TSclusterinteract</span><span class="p">:</span>
                        <span class="n">TSclusterinteract</span><span class="p">[</span><span class="n">TS1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mobilesites</span><span class="p">,</span> <span class="n">specsites</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">TSclusterinteract</span><span class="p">[</span><span class="n">TS1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">mobilesites</span><span class="p">,</span> <span class="n">specsites</span><span class="p">,</span> <span class="n">value</span><span class="p">)]</span>
        <span class="c1"># we need to proceed one transition at a time</span>
        <span class="n">Njumps</span><span class="p">,</span> <span class="n">interactrange</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[]</span>
        <span class="n">jumps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">jn</span><span class="p">,</span> <span class="n">Etrans</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">KRAvalues</span><span class="p">):</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">j0</span><span class="p">),</span> <span class="n">deltax</span> <span class="ow">in</span> <span class="n">jn</span><span class="p">:</span>
                <span class="n">ci0</span><span class="p">,</span> <span class="n">cj0</span> <span class="o">=</span> <span class="p">(</span><span class="n">chem</span><span class="p">,</span> <span class="n">i0</span><span class="p">),</span> <span class="p">(</span><span class="n">chem</span><span class="p">,</span> <span class="n">j0</span><span class="p">)</span>
                <span class="c1"># to get final position, it&#39;s a bit more complex... need to use dx:</span>
                <span class="n">dR</span><span class="p">,</span> <span class="n">cj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">cart2pos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">pos2cart</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span> <span class="p">(</span><span class="n">chem</span><span class="p">,</span> <span class="n">i0</span><span class="p">))</span> <span class="o">+</span> <span class="n">deltax</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cj</span> <span class="o">!=</span> <span class="n">cj0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span>
                        <span class="s1">&#39;Transition (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">), </span><span class="si">{}</span><span class="s1"> did not land at correct site?</span><span class="se">\n</span><span class="si">{}</span><span class="s1"> != P{&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">j0</span><span class="p">,</span> <span class="n">deltax</span><span class="p">,</span> <span class="n">cj</span><span class="p">,</span>
                                                                                                <span class="n">cj0</span><span class="p">))</span>
                <span class="n">cs_i0</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">ClusterSite</span><span class="p">(</span><span class="n">ci0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
                <span class="c1"># NOTE: we will need the *reverse* endpoint for the initial state...</span>
                <span class="n">cs_i</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">ClusterSite</span><span class="p">(</span><span class="n">ci0</span><span class="p">,</span> <span class="o">-</span><span class="n">dR</span><span class="p">)</span>
                <span class="n">cs_j</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">ClusterSite</span><span class="p">(</span><span class="n">cj0</span><span class="p">,</span> <span class="n">dR</span><span class="p">)</span>
                <span class="c1"># construct sublists of cluster expansions that explicitly *exclude* our endpoints:</span>
                <span class="n">clusterinteract_ci0</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="o">-</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">clusterinteract</span><span class="p">[</span><span class="n">ci0</span><span class="p">]</span> <span class="k">if</span> <span class="n">cs_j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ms</span><span class="p">]</span>
                <span class="n">clusterinteract_cj0</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">clusterinteract</span><span class="p">[</span><span class="n">cj0</span><span class="p">]</span> <span class="k">if</span> <span class="n">cs_i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ms</span><span class="p">]</span>
                <span class="c1"># now, run through all lattice sites...</span>
                <span class="k">for</span> <span class="n">Ri</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rveclist</span><span class="p">:</span>
                    <span class="c1"># each possible *transition* is treated like its own mini-cluster expansion:</span>
                    <span class="n">E0</span> <span class="o">=</span> <span class="n">Etrans</span>
                    <span class="n">interdict</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">Ri</span><span class="p">,</span> <span class="n">ci0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">Rj</span> <span class="o">=</span> <span class="n">Ri</span> <span class="o">+</span> <span class="n">dR</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">Rj</span><span class="p">,</span> <span class="n">cj0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">jumps</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">deltax</span><span class="p">))</span>
                    <span class="c1"># now, to run through our clusters, adding interactions as appropriate:</span>
                    <span class="c1"># -0.5*Einitial +0.5*Efinal</span>
                    <span class="k">for</span> <span class="n">mobilesites</span><span class="p">,</span> <span class="n">specsites</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">Rsite</span> <span class="ow">in</span> <span class="p">[</span><span class="n">msssval</span> <span class="o">+</span> <span class="p">(</span><span class="n">Ri</span><span class="p">,)</span> <span class="k">for</span> <span class="n">msssval</span> <span class="ow">in</span> <span class="n">clusterinteract_ci0</span><span class="p">]</span> <span class="o">+</span> \
                                                                <span class="p">[</span><span class="n">msssval</span> <span class="o">+</span> <span class="p">(</span><span class="n">Rj</span><span class="p">,)</span> <span class="k">for</span> <span class="n">msssval</span> <span class="ow">in</span> <span class="n">clusterinteract_cj0</span><span class="p">]:</span>
                        <span class="c1"># if our initial point is also in our cluster, kick out now:</span>
                        <span class="c1"># if cs_i in mobilesites: continue</span>
                        <span class="c1"># check that all of the spectator sites are occupied:</span>
                        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">socc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">Rsite</span> <span class="o">+</span> <span class="n">site</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">specsites</span><span class="p">):</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mobilesites</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="c1"># spectator only == constant</span>
                                <span class="n">E0</span> <span class="o">+=</span> <span class="n">value</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">intertuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">Rsite</span> <span class="o">+</span> <span class="n">site</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                                                          <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">mobilesites</span><span class="p">))</span>
                                <span class="k">if</span> <span class="n">intertuple</span> <span class="ow">in</span> <span class="n">interdict</span><span class="p">:</span>
                                    <span class="c1"># if we&#39;ve already seen this particular interaction, add to the value</span>
                                    <span class="n">interact</span><span class="p">[</span><span class="n">interdict</span><span class="p">[</span><span class="n">intertuple</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">value</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="c1"># new interaction!</span>
                                    <span class="n">interact</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                                    <span class="n">interdict</span><span class="p">[</span><span class="n">intertuple</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ninteract</span>
                                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">intertuple</span><span class="p">:</span>
                                        <span class="n">siteinteract</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Ninteract</span><span class="p">)</span>
                                    <span class="n">Ninteract</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># finally, here is where we&#39;d put the code to include the KRA expansion...</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">cs_i0</span><span class="p">,</span> <span class="n">cs_j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">TSclusterinteract</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">mobilesites</span><span class="p">,</span> <span class="n">specsites</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">TSclusterinteract</span><span class="p">[</span><span class="n">cs_i0</span><span class="p">,</span> <span class="n">cs_j</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">socc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">Ri</span> <span class="o">+</span> <span class="n">site</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">specsites</span><span class="p">):</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mobilesites</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="c1"># spectator only == constant</span>
                                    <span class="n">E0</span> <span class="o">+=</span> <span class="n">value</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">intertuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                                        <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">Ri</span> <span class="o">+</span> <span class="n">site</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">mobilesites</span><span class="p">))</span>
                                    <span class="k">if</span> <span class="n">intertuple</span> <span class="ow">in</span> <span class="n">interdict</span><span class="p">:</span>
                                        <span class="c1"># if we&#39;ve already seen this particular interaction, add to the value</span>
                                        <span class="n">interact</span><span class="p">[</span><span class="n">interdict</span><span class="p">[</span><span class="n">intertuple</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">value</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="c1"># new interaction!</span>
                                        <span class="n">interact</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                                        <span class="n">interdict</span><span class="p">[</span><span class="n">intertuple</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ninteract</span>
                                        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">intertuple</span><span class="p">:</span>
                                            <span class="n">siteinteract</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Ninteract</span><span class="p">)</span>
                                        <span class="n">Ninteract</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># now add on our constant value...</span>
                    <span class="n">interact</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E0</span><span class="p">)</span>
                    <span class="n">Ninteract</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">interactrange</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Ninteract</span><span class="p">)</span>
                    <span class="n">Njumps</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">interactrange</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Ninteract0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">siteinteract</span><span class="p">,</span> <span class="n">interact</span><span class="p">,</span> <span class="n">jumps</span><span class="p">,</span> <span class="n">interactrange</span></div>


<div class="viewcode-block" id="ClusterSupercell.jumpnetworkevaluator_vacancy">
<a class="viewcode-back" href="../supercell.html#supercell.ClusterSupercell.jumpnetworkevaluator_vacancy">[docs]</a>
    <span class="k">def</span> <span class="nf">jumpnetworkevaluator_vacancy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">socc</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">chem</span><span class="p">,</span> <span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">KRAvalues</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                     <span class="n">TSclusters</span><span class="o">=</span><span class="p">(),</span> <span class="n">TSvalues</span><span class="o">=</span><span class="p">(),</span>
                                     <span class="n">siteinteract</span><span class="o">=</span><span class="p">(),</span> <span class="n">interact</span><span class="o">=</span><span class="p">()):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build out an efficient jump network evaluator for a vacancy. Similar inputs to</span>
<span class="sd">        ``jumpnetworkevaluator``. This is designed for a &quot;stationary&quot; vacancy, where we&#39;ll</span>
<span class="sd">        just look at its jumps in the supercell.</span>

<span class="sd">        :param socc: spectator occupancy vector (0 or 1 only)</span>
<span class="sd">        :param clusters: list of lists (or sets) of Cluster objects</span>
<span class="sd">        :param values: vector of values for the clusters; if it is longer than the</span>
<span class="sd">          list of clusters by one, the last values is assumed to be the constant value.</span>
<span class="sd">        :param chem: index of species that transitions</span>
<span class="sd">        :param jumpnetwork: list of lists of jumps; each is ((i, j), dx) where ``i`` and ``j`` are</span>
<span class="sd">          unit cell indices for species ``chem``</span>
<span class="sd">        :param KRAvalues: list of &quot;KRA&quot; values for barriers (relative to average energy of endpoints);</span>
<span class="sd">          if ``TSclusters`` are used, choosing 0 is more straightforward.</span>
<span class="sd">        :param TSclusters: (optional) list of transition state cluster expansion terms; this is</span>
<span class="sd">          always added on to KRAvalues (thus using 0 is recommended if TSclusters are also used)</span>
<span class="sd">        :param TSvalues: (optional) values for TS cluster expansion entries</span>
<span class="sd">        :param siteinteract: (optional) list of lists of interactions for each site, to append</span>
<span class="sd">        :param interact: (optional) list of interaction values, to append</span>

<span class="sd">        :return siteinteract: list of lists of interactions for each site</span>
<span class="sd">        :return interact: list of interaction values</span>
<span class="sd">        :return jumps: list of ((initial, final), dx)</span>
<span class="sd">        :return interactrange: range of indices to count in interact for each jump; for the nth</span>
<span class="sd">          jump, sum over interactrange[n-1]:interactrange[n]; interactrange[-1] == range for energy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">zerovec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vacancy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Supercell does not contain a vacancy; use `addvacancy()` first&#39;</span><span class="p">)</span>
        <span class="n">ci_vac</span><span class="p">,</span> <span class="n">R_vac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ciR</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vacancy</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ci_vac</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">chem</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Vacancy </span><span class="si">{}</span><span class="s1"> has chemistry </span><span class="si">{}</span><span class="s1"> not </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vacancy</span><span class="p">,</span> <span class="n">ci_vac</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">chem</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">KRAvalues</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">KRAvalues</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">jumpnetwork</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incorrect length for KRAvalues: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">KRAvalues</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">KRAvalues</span> <span class="o">=</span> <span class="n">KRAvalues</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">jumpnetwork</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incorrect length for values: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">TSclusters</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">TSvalues</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incorrect length for TSvalues: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">TSvalues</span><span class="p">))</span>
        <span class="n">siteinteract</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">siteinteract</span><span class="p">)</span>
        <span class="n">interact</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">interact</span><span class="p">)</span>
        <span class="n">Ninteract</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">interact</span><span class="p">)</span>
        <span class="n">Ninteract0</span> <span class="o">=</span> <span class="n">Ninteract</span>  <span class="c1"># we store this now, so that we can make interactrange[-1] = Ninteract0</span>
        <span class="c1"># &quot;flatten&quot; the clusters for more efficient operations:</span>
        <span class="c1"># clusterinteract[(c,i)] = list of ([cs list], value) of interactions centered on (c, i)</span>
        <span class="c1"># NOTE: in order to maintain detailed balance, we use half the energy difference of the</span>
        <span class="c1"># initial and final states, so we go ahead and multiply by 0.5 here for efficiency.</span>
        <span class="n">clusterinteract</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">vacclusterinteract</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">clusterlist</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">clust</span> <span class="ow">in</span> <span class="n">clusterlist</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">clust</span><span class="o">.</span><span class="n">__vacancy__</span><span class="p">:</span>
                    <span class="n">civ</span> <span class="o">=</span> <span class="n">clust</span><span class="o">.</span><span class="n">vacancy</span><span class="p">()</span><span class="o">.</span><span class="n">ci</span>
                    <span class="n">mobilesites</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">clust</span> <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexmobile</span><span class="p">]</span>
                    <span class="n">specsites</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">clust</span> <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexspectator</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">civ</span> <span class="ow">in</span> <span class="n">vacclusterinteract</span><span class="p">:</span>
                        <span class="n">vacclusterinteract</span><span class="p">[</span><span class="n">civ</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mobilesites</span><span class="p">,</span> <span class="n">specsites</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">value</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">vacclusterinteract</span><span class="p">[</span><span class="n">civ</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">mobilesites</span><span class="p">,</span> <span class="n">specsites</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">value</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">cs</span> <span class="ow">in</span> <span class="n">clust</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">cs</span><span class="o">.</span><span class="n">ci</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexmobile</span><span class="p">:</span>
                            <span class="c1"># get the list of other sites, and split into mobile and spectator:</span>
                            <span class="n">cs0</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">ClusterSite</span><span class="p">(</span><span class="n">cs</span><span class="o">.</span><span class="n">ci</span><span class="p">,</span> <span class="n">zerovec</span><span class="p">)</span>
                            <span class="n">cllist</span> <span class="o">=</span> <span class="n">clust</span> <span class="o">-</span> <span class="n">cs</span>
                            <span class="n">mobilesites</span> <span class="o">=</span> <span class="p">[</span><span class="n">cs0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">site</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">cllist</span> <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexmobile</span><span class="p">]</span>
                            <span class="n">specsites</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">cllist</span> <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexspectator</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">cs</span><span class="o">.</span><span class="n">ci</span> <span class="ow">in</span> <span class="n">clusterinteract</span><span class="p">:</span>
                                <span class="n">clusterinteract</span><span class="p">[</span><span class="n">cs</span><span class="o">.</span><span class="n">ci</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mobilesites</span><span class="p">,</span> <span class="n">specsites</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">value</span><span class="p">))</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">clusterinteract</span><span class="p">[</span><span class="n">cs</span><span class="o">.</span><span class="n">ci</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">mobilesites</span><span class="p">,</span> <span class="n">specsites</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">value</span><span class="p">)]</span>
        <span class="c1"># &quot;flatten&quot; the TS clusters. To simplify, we put in both forward and backward jumps</span>
        <span class="n">TSclusterinteract</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">TSclusterlist</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">TSclusters</span><span class="p">,</span> <span class="n">TSvalues</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">TSclust</span> <span class="ow">in</span> <span class="n">TSclusterlist</span><span class="p">:</span>
                <span class="c1"># just check that we&#39;re dealing with vacancies, with the right chemistry</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">TSclust</span><span class="o">.</span><span class="n">__vacancy__</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">TS</span> <span class="o">=</span> <span class="n">TSclust</span><span class="o">.</span><span class="n">transitionstate</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">TS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ci</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">chem</span> <span class="ow">or</span> <span class="n">TS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ci</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">chem</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">R0</span> <span class="o">=</span> <span class="n">TS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">R</span>
                <span class="n">TS0</span> <span class="o">=</span> <span class="p">(</span><span class="n">TS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">R0</span><span class="p">,</span> <span class="n">TS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">R0</span><span class="p">)</span>
                <span class="n">mobilesites</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span> <span class="o">-</span> <span class="n">R0</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">TSclust</span> <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexmobile</span><span class="p">]</span>
                <span class="n">specsites</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span> <span class="o">-</span> <span class="n">R0</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">TSclust</span> <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexspectator</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">TS0</span> <span class="ow">in</span> <span class="n">TSclusterinteract</span><span class="p">:</span>
                    <span class="n">TSclusterinteract</span><span class="p">[</span><span class="n">TS0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mobilesites</span><span class="p">,</span> <span class="n">specsites</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">TSclusterinteract</span><span class="p">[</span><span class="n">TS0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">mobilesites</span><span class="p">,</span> <span class="n">specsites</span><span class="p">,</span> <span class="n">value</span><span class="p">)]</span>
                <span class="c1"># Need to add &quot;reverse&quot; jumps to consider in our TS expansions (proper consideration of trans. state)</span>
                <span class="c1"># R1 = TS[1].R</span>
                <span class="c1"># TS1 = (TS[1] - R1, TS[0] - R1)</span>
                <span class="c1"># mobilesites = [site - R1 for site in TSclust if site.ci in self.indexmobile]</span>
                <span class="c1"># specsites = [site - R1 for site in TSclust if site.ci in self.indexspectator]</span>
                <span class="c1"># if TS1 in TSclusterinteract:</span>
                <span class="c1">#     TSclusterinteract[TS1].append((mobilesites, specsites, value))</span>
                <span class="c1"># else:</span>
                <span class="c1">#     TSclusterinteract[TS1] = [(mobilesites, specsites, value)]</span>
        <span class="c1"># we need to proceed one transition at a time</span>
        <span class="n">Njumps</span><span class="p">,</span> <span class="n">interactrange</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[]</span>
        <span class="n">jumps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">jn</span><span class="p">,</span> <span class="n">Etrans</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">KRAvalues</span><span class="p">):</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">j0</span><span class="p">),</span> <span class="n">deltax</span> <span class="ow">in</span> <span class="n">jn</span><span class="p">:</span>
                <span class="n">ci0</span><span class="p">,</span> <span class="n">cj0</span> <span class="o">=</span> <span class="p">(</span><span class="n">chem</span><span class="p">,</span> <span class="n">i0</span><span class="p">),</span> <span class="p">(</span><span class="n">chem</span><span class="p">,</span> <span class="n">j0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ci0</span> <span class="o">!=</span> <span class="n">ci_vac</span><span class="p">:</span> <span class="k">continue</span>
                <span class="c1"># to get final position, it&#39;s a bit more complex... need to use dx:</span>
                <span class="n">dR</span><span class="p">,</span> <span class="n">cj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">cart2pos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">pos2cart</span><span class="p">(</span><span class="n">zerovec</span><span class="p">,</span> <span class="p">(</span><span class="n">chem</span><span class="p">,</span> <span class="n">i0</span><span class="p">))</span> <span class="o">+</span> <span class="n">deltax</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cj</span> <span class="o">!=</span> <span class="n">cj0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span>
                        <span class="s1">&#39;Transition (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">), </span><span class="si">{}</span><span class="s1"> did not land at correct site?</span><span class="se">\n</span><span class="si">{}</span><span class="s1"> != P{&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">j0</span><span class="p">,</span> <span class="n">deltax</span><span class="p">,</span> <span class="n">cj</span><span class="p">,</span>
                                                                                                <span class="n">cj0</span><span class="p">))</span>
                <span class="n">cs_i0</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">ClusterSite</span><span class="p">(</span><span class="n">ci0</span><span class="p">,</span> <span class="n">zerovec</span><span class="p">)</span>
                <span class="c1"># NOTE: we will need the *reverse* endpoint for the initial state...</span>
                <span class="n">cs_i</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">ClusterSite</span><span class="p">(</span><span class="n">ci0</span><span class="p">,</span> <span class="o">-</span><span class="n">dR</span><span class="p">)</span>
                <span class="n">cs_j</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">ClusterSite</span><span class="p">(</span><span class="n">cj0</span><span class="p">,</span> <span class="n">dR</span><span class="p">)</span>
                <span class="c1"># Ri = R_vac</span>
                <span class="c1"># each possible *transition* is treated like its own mini-cluster expansion:</span>
                <span class="n">E0</span> <span class="o">=</span> <span class="n">Etrans</span>
                <span class="n">interdict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">R_vac</span><span class="p">,</span> <span class="n">ci0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vacancy</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Somehow did not correctly map to the vacancy? Should never happen&#39;</span><span class="p">)</span>
                <span class="n">Rj</span> <span class="o">=</span> <span class="n">R_vac</span> <span class="o">+</span> <span class="n">dR</span>
                <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">Rj</span><span class="p">,</span> <span class="n">cj0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">jumps</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">deltax</span><span class="p">))</span>

                <span class="c1"># construct sublists of cluster expansions based on the &quot;i&quot; site and the &quot;j&quot; site</span>
                <span class="c1"># half of these are for the initial, and half are for the final. For simplicity, we do</span>
                <span class="c1"># the vacancy based ones first.</span>
                <span class="c1"># clusterinteract_ci0 = [(ms, ss, val) for (ms, ss, val) in vacclusterinteract[ci0]]</span>
                <span class="c1"># clusterinteract_cj0 = [(ms, ss, val) for (ms, ss, val) in vacclusterinteract[cj0]]</span>
                <span class="c1"># clusterinteract_ci0 += [(ms, ss, -val) for (ms, ss, val) in clusterinteract[ci0] if cs_j not in ms]</span>
                <span class="c1"># clusterinteract_cj0 += [(ms, ss, -val) for (ms, ss, val) in clusterinteract[cj0] if cs_i not in ms]</span>

                <span class="c1"># we need to make an index mapping for our end-point state (the two sites that are switched!)</span>
                <span class="n">init_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nmobile</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
                <span class="n">rev_map</span> <span class="o">=</span> <span class="n">init_map</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">rev_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                <span class="n">rev_map</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                <span class="c1"># -0.5*Einitial + 0.5*Efinal: vac(initial), vac(final), solute(initial), solute(final)</span>
                <span class="n">clusterinteract_map</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="o">-</span><span class="n">val</span><span class="p">,</span> <span class="n">R_vac</span><span class="p">,</span> <span class="n">init_map</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">vacclusterinteract</span><span class="p">[</span><span class="n">ci0</span><span class="p">]]</span> <span class="o">+</span> \
                                      <span class="p">[(</span><span class="n">ms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="o">+</span><span class="n">val</span><span class="p">,</span> <span class="n">Rj</span><span class="p">,</span> <span class="n">rev_map</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">vacclusterinteract</span><span class="p">[</span><span class="n">cj0</span><span class="p">]]</span> <span class="o">+</span> \
                                      <span class="p">[(</span><span class="n">ms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="o">-</span><span class="n">val</span><span class="p">,</span> <span class="n">Rj</span><span class="p">,</span> <span class="n">init_map</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">clusterinteract</span><span class="p">[</span><span class="n">cj0</span><span class="p">]</span>
                                       <span class="k">if</span> <span class="n">cs_i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ms</span><span class="p">]</span> <span class="o">+</span> \
                                      <span class="p">[(</span><span class="n">ms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="o">+</span><span class="n">val</span><span class="p">,</span> <span class="n">R_vac</span><span class="p">,</span> <span class="n">rev_map</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">clusterinteract</span><span class="p">[</span><span class="n">ci0</span><span class="p">]</span>
                                       <span class="k">if</span> <span class="n">cs_j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ms</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">mobilesites</span><span class="p">,</span> <span class="n">specsites</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">Rsite</span><span class="p">,</span> <span class="n">mapping</span> <span class="ow">in</span> <span class="n">clusterinteract_map</span><span class="p">:</span>
                    <span class="c1"># if our endpoint is also in our cluster, kick out now:</span>
                    <span class="c1"># if cs_j in mobilesites: continue</span>
                    <span class="c1"># check that all of the spectator sites are occupied:</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">socc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">Rsite</span> <span class="o">+</span> <span class="n">site</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">specsites</span><span class="p">):</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mobilesites</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># spectator only == constant</span>
                            <span class="n">E0</span> <span class="o">+=</span> <span class="n">value</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">intertuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">mapping</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">Rsite</span> <span class="o">+</span> <span class="n">site</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
                                                      <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">mobilesites</span><span class="p">))</span>
                            <span class="k">if</span> <span class="n">intertuple</span> <span class="ow">in</span> <span class="n">interdict</span><span class="p">:</span>
                                <span class="c1"># if we&#39;ve already seen this particular interaction, add to the value</span>
                                <span class="n">interact</span><span class="p">[</span><span class="n">interdict</span><span class="p">[</span><span class="n">intertuple</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">value</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># new interaction!</span>
                                <span class="n">interact</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">+</span><span class="n">value</span><span class="p">)</span>
                                <span class="n">interdict</span><span class="p">[</span><span class="n">intertuple</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ninteract</span>
                                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">intertuple</span><span class="p">:</span>
                                    <span class="n">siteinteract</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Ninteract</span><span class="p">)</span>
                                <span class="n">Ninteract</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># finally, here is where we&#39;d put the code to include the KRA expansion...</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">cs_i0</span><span class="p">,</span> <span class="n">cs_j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">TSclusterinteract</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">mobilesites</span><span class="p">,</span> <span class="n">specsites</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">TSclusterinteract</span><span class="p">[</span><span class="n">cs_i0</span><span class="p">,</span> <span class="n">cs_j</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">socc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">R_vac</span> <span class="o">+</span> <span class="n">site</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">specsites</span><span class="p">):</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mobilesites</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="c1"># spectator only == constant</span>
                                <span class="n">E0</span> <span class="o">+=</span> <span class="n">value</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">intertuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                                    <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">R_vac</span> <span class="o">+</span> <span class="n">site</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">ci</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">mobilesites</span><span class="p">))</span>
                                <span class="k">if</span> <span class="n">intertuple</span> <span class="ow">in</span> <span class="n">interdict</span><span class="p">:</span>
                                    <span class="c1"># if we&#39;ve already seen this particular interaction, add to the value</span>
                                    <span class="n">interact</span><span class="p">[</span><span class="n">interdict</span><span class="p">[</span><span class="n">intertuple</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">value</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="c1"># new interaction!</span>
                                    <span class="n">interact</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                                    <span class="n">interdict</span><span class="p">[</span><span class="n">intertuple</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ninteract</span>
                                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">intertuple</span><span class="p">:</span>
                                        <span class="n">siteinteract</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Ninteract</span><span class="p">)</span>
                                    <span class="n">Ninteract</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># now add on our constant value...</span>
                <span class="n">interact</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E0</span><span class="p">)</span>
                <span class="n">Ninteract</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">interactrange</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Ninteract</span><span class="p">)</span>
                <span class="n">Njumps</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">interactrange</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Ninteract0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">siteinteract</span><span class="p">,</span> <span class="n">interact</span><span class="p">,</span> <span class="n">jumps</span><span class="p">,</span> <span class="n">interactrange</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017, Dallas R. Trinkle.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>