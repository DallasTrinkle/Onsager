

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>PowerExpansion &mdash; Onsager 1.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Onsager 1.1 documentation" href="../index.html"/>
        <link rel="up" title="Module code" href="index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Onsager
          

          
          </a>

          
            
            
              <div class="version">
                1.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../includeme.html">Onsager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../includeme.html#references">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../includeme.html#contributors">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../includeme.html#support">Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crystal.html">Crystal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CrystalStars.html">CrystalStars</a></li>
<li class="toctree-l1"><a class="reference internal" href="../supercell.html">Supercell</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PowerExpansion.html">PowerExpansion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GFcalc.html">GFcalc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OnsagerCalc.html">OnsagerCalc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../automator.html">Automator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks.html">Notebooks</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Onsager</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Module code</a> &raquo;</li>
      
    <li>PowerExpansion</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for PowerExpansion</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Power expansion class</span>

<span class="sd">Class to store and manipulate 3-dimensional Taylor (power) expansions of functions</span>
<span class="sd">Particularly useful for inverting the FT of the evolution matrix, and subtracting off</span>
<span class="sd">analytically calculated IFT for the Green function.</span>

<span class="sd">Really designed to get used by other code.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Dallas R. Trinkle&#39;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">factorial</span>


<div class="viewcode-block" id="Taylor3D"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D">[docs]</a><span class="k">class</span> <span class="nc">Taylor3D</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class that stores a Taylor expansion of a function in 3D, and defines some arithmetic</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># a whole series of sorts of automated computation for setup</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Taylor3D.makeindexPowerYlm"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.makeindexPowerYlm">[docs]</a>    <span class="k">def</span> <span class="nf">makeindexPowerYlm</span><span class="p">(</span><span class="n">Lmax</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analyzes the spherical harmonics and powers for a given Lmax; returns a</span>
<span class="sd">        series of index functions.</span>

<span class="sd">        :param Lmax: maximum l value to consider; equal to the sum of powers</span>
<span class="sd">        :return NYlm: number of Ylm coefficients</span>
<span class="sd">        :return Npower: number of power coefficients</span>
<span class="sd">        :return pow2ind[n1][n2][n3]: powers to index</span>
<span class="sd">        :return ind2pow[n]: powers for a given index</span>
<span class="sd">        :return Ylm2ind[l][m]: (l,m) to index</span>
<span class="sd">        :return ind2Ylm[lm]: (l,m) for a given index</span>
<span class="sd">        :return powlrange[l]: upper limit of power indices for a given l value; note: [-1] = 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first, the counts</span>
        <span class="n">NYlm</span> <span class="o">=</span> <span class="p">(</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">Npower</span> <span class="o">=</span> <span class="n">NYlm</span> <span class="o">+</span> <span class="p">((</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Lmax</span> <span class="o">*</span> <span class="p">(</span><span class="n">Lmax</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">//</span> <span class="mi">6</span>
        <span class="c1"># indexing arrays</span>
        <span class="n">powlrange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">powlrange</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pow2ind</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">ind2pow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Npower</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">Ylm2ind</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">ind2Ylm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NYlm</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># powers first; these are ordered by increasing l = n1+n2+n3</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">n1</span><span class="p">):</span>
                    <span class="n">n3</span> <span class="o">=</span> <span class="n">l</span> <span class="o">-</span> <span class="n">n1</span> <span class="o">-</span> <span class="n">n2</span>
                    <span class="n">pow2ind</span><span class="p">[</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>
                    <span class="n">ind2pow</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">ind2pow</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ind2pow</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n3</span>
                    <span class="n">ind</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">powlrange</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>
        <span class="c1"># next, Ylm values</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">l</span><span class="p">,</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">Ylm2ind</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>
                <span class="n">ind2Ylm</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">ind2Ylm</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span>
                <span class="n">ind</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">NYlm</span><span class="p">,</span> <span class="n">Npower</span><span class="p">,</span> <span class="n">pow2ind</span><span class="p">,</span> <span class="n">ind2pow</span><span class="p">,</span> <span class="n">Ylm2ind</span><span class="p">,</span> <span class="n">ind2Ylm</span><span class="p">,</span> <span class="n">powlrange</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Taylor3D.makeYlmpow"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.makeYlmpow">[docs]</a>    <span class="k">def</span> <span class="nf">makeYlmpow</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the expansion of the Ylm&#39;s in powers of x,y,z. Done via brute force.</span>

<span class="sd">        :return Ylmpow[lm, p]: expansion of each Ylm in powers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Ylmpow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">cls</span><span class="o">.</span><span class="n">NYlm</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Npower</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># do the positive m first; then easily swap to get the negative m</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">Ylm2ind</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">m</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="n">m</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span> <span class="o">/</span>
                                          <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="bp">True</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">l</span> <span class="o">+</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">zz</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span> <span class="o">/</span> \
                         <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">l</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="n">l</span> <span class="o">-</span> <span class="n">m</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="n">k</span><span class="p">,</span> <span class="bp">True</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">xy</span> <span class="o">=</span> <span class="n">factorial</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="bp">True</span><span class="p">))</span>
                        <span class="n">Ylmpow</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="n">l</span> <span class="o">-</span> <span class="n">m</span><span class="p">]]</span> <span class="o">=</span> <span class="n">pre</span> <span class="o">*</span> <span class="n">zz</span> <span class="o">*</span> <span class="n">xy</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.j</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">l</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">Ylm2ind</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span>
                <span class="n">indpos</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">Ylm2ind</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="o">-</span><span class="n">m</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">Npower</span><span class="p">):</span>
                    <span class="n">Ylmpow</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="n">Ylmpow</span><span class="p">[</span><span class="n">indpos</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Ylmpow</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Taylor3D.makepowYlm"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.makepowYlm">[docs]</a>    <span class="k">def</span> <span class="nf">makepowYlm</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the expansion of the powers in Ylm&#39;s. Done using recursion relations</span>
<span class="sd">        instead of direct calculation. Note: an alternative approach would be Gaussian</span>
<span class="sd">        quadrature.</span>

<span class="sd">        :return powYlm[p][lm]: expansion of powers in Ylm; uses indexing scheme above</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">powYlm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">cls</span><span class="o">.</span><span class="n">Npower</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">NYlm</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">Cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">Cm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">Sp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">Sm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># because this is for our recursion relations, we only need to work to Lmax-1 !</span>
        <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">l</span><span class="p">,</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">Cp</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">l</span> <span class="o">-</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)))</span>
            <span class="n">Sp</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">l</span> <span class="o">+</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># and -l &lt; m &lt; l:</span>
                <span class="n">Cm</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">l</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">m</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
                <span class="n">Sm</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">l</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>

        <span class="c1"># first, prime the pump with 1</span>
        <span class="n">powYlm</span><span class="p">[</span><span class="n">cls</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">cls</span><span class="o">.</span><span class="n">Ylm2ind</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n0</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="p">((</span><span class="n">n0</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span> <span class="k">for</span> <span class="n">n0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                           <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">n0</span> <span class="o">+</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span> <span class="o">&lt;=</span> <span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span><span class="p">):</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[</span><span class="n">n0</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">]</span>
            <span class="n">lmax</span> <span class="o">=</span> <span class="n">n0</span> <span class="o">+</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span>
            <span class="k">if</span> <span class="n">n2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># we can recurse up from n0, n1, n2-1</span>
                <span class="n">indlow</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[</span><span class="n">n0</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lmax</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">l</span><span class="p">,</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                    <span class="n">plm</span> <span class="o">=</span> <span class="n">powYlm</span><span class="p">[</span><span class="n">indlow</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Ylm2ind</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">]]</span>
                    <span class="n">powYlm</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Ylm2ind</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">Cp</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">plm</span>
                    <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="o">-</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">:</span>
                        <span class="n">powYlm</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Ylm2ind</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">Cm</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">plm</span>
            <span class="k">elif</span> <span class="n">n1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># we can recurse up from n0, n1-1, n2</span>
                <span class="n">indlow</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[</span><span class="n">n0</span><span class="p">,</span> <span class="n">n1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n2</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lmax</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">l</span><span class="p">,</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                    <span class="n">plm</span> <span class="o">=</span> <span class="n">powYlm</span><span class="p">[</span><span class="n">indlow</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Ylm2ind</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">]]</span>
                    <span class="n">powYlm</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Ylm2ind</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="mf">1.j</span> <span class="o">*</span> <span class="n">Sp</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">plm</span>
                    <span class="n">powYlm</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Ylm2ind</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="mf">1.j</span> <span class="o">*</span> <span class="n">Sp</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="o">-</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">plm</span>
                    <span class="c1"># if l&gt;0:</span>
                    <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">powYlm</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Ylm2ind</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="o">-</span><span class="mf">1.j</span> <span class="o">*</span> <span class="n">Sm</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">plm</span>
                    <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">powYlm</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Ylm2ind</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="o">-</span><span class="mf">1.j</span> <span class="o">*</span> <span class="n">Sm</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="o">-</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">plm</span>
            <span class="k">elif</span> <span class="n">n0</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># we can recurse up from n0-1, n1, n2</span>
                <span class="n">indlow</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[</span><span class="n">n0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lmax</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">l</span><span class="p">,</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                    <span class="n">plm</span> <span class="o">=</span> <span class="n">powYlm</span><span class="p">[</span><span class="n">indlow</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Ylm2ind</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">]]</span>
                    <span class="n">powYlm</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Ylm2ind</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">Sp</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">plm</span>
                    <span class="n">powYlm</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Ylm2ind</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">Sp</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="o">-</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">plm</span>
                    <span class="c1"># if l&gt;0:</span>
                    <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">powYlm</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Ylm2ind</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">Sm</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">plm</span>
                    <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">powYlm</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Ylm2ind</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">Sm</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="o">-</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">plm</span>
        <span class="k">return</span> <span class="n">powYlm</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Taylor3D.makeLprojections"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.makeLprojections">[docs]</a>    <span class="k">def</span> <span class="nf">makeLprojections</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs a series of projection matrices for each l component in our power series</span>

<span class="sd">        :return: projL[l][p][p&#39;]</span>
<span class="sd">            projection of powers containing *only* l component.</span>
<span class="sd">            -1 component = sum(l=0..Lmax, projL[l]) = simplification projection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">projL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Npower</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Npower</span><span class="p">))</span>
        <span class="n">projLYlm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">NYlm</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">NYlm</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">l</span><span class="p">,</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">lm</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">Ylm2ind</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span>
            <span class="n">projLYlm</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">lm</span><span class="p">,</span> <span class="n">lm</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># l,m is part of l</span>
            <span class="n">projLYlm</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">lm</span><span class="p">,</span> <span class="n">lm</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># all part of the sum</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">2</span><span class="p">):</span>
            <span class="c1"># projL[l] = np.dot(cls.powYlm, np.dot(projLYlm[l], cls.Ylmpow)).real</span>
            <span class="n">projL</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">Ylmpow</span><span class="p">,</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">projLYlm</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">cls</span><span class="o">.</span><span class="n">powYlm</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                                    <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">real</span>
        <span class="k">return</span> <span class="n">projL</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Taylor3D.makedirectmult"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.makedirectmult">[docs]</a>    <span class="k">def</span> <span class="nf">makedirectmult</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return direcmult[p][p&#39;]: index that corresponds to the multiplication of power indices p and p&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">directmult</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">cls</span><span class="o">.</span><span class="n">Npower</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Npower</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span> <span class="ow">in</span> <span class="p">((</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span> <span class="k">for</span> <span class="n">p0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">Npower</span><span class="p">)</span> <span class="k">for</span> <span class="n">p1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">Npower</span><span class="p">)):</span>
            <span class="n">nsum</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">ind2pow</span><span class="p">[</span><span class="n">p0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cls</span><span class="o">.</span><span class="n">ind2pow</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nsum</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span><span class="p">:</span>
                <span class="n">directmult</span><span class="p">[</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[</span><span class="n">nsum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nsum</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nsum</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">directmult</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Taylor3D.powexp"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.powexp">[docs]</a>    <span class="k">def</span> <span class="nf">powexp</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a vector u, normalize it and return the power expansion of uvec</span>

<span class="sd">        :param u[3]: vector to apply</span>
<span class="sd">        :param normalize: do we normalize u first?</span>
<span class="sd">        :return upow[Npower]: ux uy uz products of powers</span>
<span class="sd">        :return umagn: magnitude of u (if normalized)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">umagn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>
        <span class="n">upow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">Npower</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">umagn</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">:</span>
            <span class="n">upow</span><span class="p">[</span><span class="n">cls</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="n">umagn</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u0</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span> <span class="n">u0</span> <span class="o">/=</span> <span class="n">umagn</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">xyz</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">u0</span><span class="p">[:]</span>
            <span class="k">for</span> <span class="n">n0</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="p">((</span><span class="n">n0</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span> <span class="k">for</span> <span class="n">n0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                               <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                               <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                               <span class="k">if</span> <span class="n">n0</span> <span class="o">+</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span> <span class="o">&lt;=</span> <span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span><span class="p">):</span>
                <span class="n">upow</span><span class="p">[</span><span class="n">cls</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[</span><span class="n">n0</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="n">n0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">xyz</span><span class="p">[</span><span class="n">n1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">xyz</span><span class="p">[</span><span class="n">n2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">upow</span><span class="p">,</span> <span class="n">umagn</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">upow</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Taylor3D.makepowercoeff"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.makepowercoeff">[docs]</a>    <span class="k">def</span> <span class="nf">makepowercoeff</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make our power coefficients for our construct expansion method</span>

<span class="sd">        :return powercoeff[n][p]: vector we multiply by our power expansion to get the n&#39;th coefficients</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">powercoeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Npower</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">n0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">n0</span> <span class="o">+</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span><span class="p">:</span>
                        <span class="n">powercoeff</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[</span><span class="n">n0</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">]]</span> <span class="o">=</span> \
                            <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="bp">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">powercoeff</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Taylor3D.constructexpansion"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.constructexpansion">[docs]</a>    <span class="k">def</span> <span class="nf">constructexpansion</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">basis</span><span class="p">,</span> <span class="n">N</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">pre</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a &quot;basis&quot; for constructing an expansion -- list of vectors and matrices --</span>
<span class="sd">        and constructs the expansions up to power N (default = Lmax)</span>
<span class="sd">        Takes a direction expansion a and b, and returns the sum of the expansions.</span>

<span class="sd">        :param basis = list((coeffmatrix, vect)): expansions to create;</span>
<span class="sd">          sum(coeffmatrix * (vect*q)^n), for powers n = 0..N</span>
<span class="sd">        :param N: maximum power to consider; for N=-1, use Lmax</span>
<span class="sd">        :param pre: list of prefactors, defining the Taylor expansion. Default = 1</span>
<span class="sd">        :return list((n, lmax, powexpansion)),...: our expansion, as input to create</span>
<span class="sd">          Taylor3D objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">N</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span>
        <span class="k">if</span> <span class="n">pre</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">n</span><span class="p">],)</span> <span class="o">+</span> <span class="n">basis</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">))])</span>
        <span class="k">for</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">vect</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">:</span>
            <span class="n">pexp</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">powexp</span><span class="p">(</span><span class="n">vect</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">vnpow</span> <span class="o">=</span> <span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">powercoeff</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">pexp</span><span class="p">)[:</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span>
                <span class="n">cn</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">n</span><span class="p">]):</span>
                    <span class="n">cn</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">+=</span> <span class="n">pre</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">vnpow</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">*</span> <span class="n">coeff</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">c</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Taylor3D.rotatedirections"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.rotatedirections">[docs]</a>    <span class="k">def</span> <span class="nf">rotatedirections</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">qptrans</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a transformation matrix qptrans, where q[i] = sum_j qptrans[i][j] p[j], and</span>
<span class="sd">        returns the Npow x Npow transformation matrix for the new components in terms of</span>
<span class="sd">        the old.</span>
<span class="sd">        NOTE: This is more complex than one might first realize. If we only work with cases</span>
<span class="sd">        where all of the entries for a given power n have those same n (that is, not reduced),</span>
<span class="sd">        then this is straightforward. However, we run into problems with *reductions*: e.g.,</span>
<span class="sd">        for n=2, the power :math:`x^0 y^0 z^0` is, in reality, :math:`x^2+y^2+z^2`, and hence</span>
<span class="sd">        *it must be transformed* because we allow non-orthogonal transformation matrices.</span>

<span class="sd">        :param qptrans: 3x3 matrix</span>
<span class="sd">        :return npowtrans: [Lmax +1][Npow][Npow] transformation matrix [n][original pow][new pow]</span>
<span class="sd">            for each n from 0 up to Lmax</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">powtrans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">cls</span><span class="o">.</span><span class="n">Npower</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Npower</span><span class="p">))</span>
        <span class="c1"># l = 0 case</span>
        <span class="n">powtrans</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># single q value cases</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">qi_pow</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">powexp</span><span class="p">(</span><span class="n">qptrans</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">powtrans</span><span class="p">[</span><span class="n">cls</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">i</span><span class="p">)],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">powercoeff</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">qi_pow</span>
        <span class="c1"># pairs of q cases: we get qi^ni qj^nj by direct multiplication</span>
        <span class="c1"># triplet is done inside the loop: q1^n1 q2^n2 q3^n3 = (q1^n1 q2^n2) (q3^n3)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ni</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">powi</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">ni</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">i</span><span class="p">)]</span>
                    <span class="k">for</span> <span class="n">nj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">ni</span><span class="p">):</span>
                        <span class="n">powj</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">nj</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">j</span><span class="p">)]</span>
                        <span class="n">powij</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">ni</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">nj</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">j</span><span class="p">)]</span>
                        <span class="c1"># multiply the pair!</span>
                        <span class="k">for</span> <span class="n">pi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">ni</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">ni</span><span class="p">]):</span>
                            <span class="k">for</span> <span class="n">pj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">nj</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">nj</span><span class="p">]):</span>
                                <span class="n">powtrans</span><span class="p">[</span><span class="n">powij</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">directmult</span><span class="p">[</span><span class="n">pi</span><span class="p">,</span> <span class="n">pj</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">powtrans</span><span class="p">[</span><span class="n">powi</span><span class="p">,</span> <span class="n">pi</span><span class="p">]</span> <span class="o">*</span> <span class="n">powtrans</span><span class="p">[</span><span class="n">powj</span><span class="p">,</span> <span class="n">pj</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="c1"># do the triplet</span>
                            <span class="c1"># k = 2 (instead of explicitly writing another loop)</span>
                            <span class="k">for</span> <span class="n">nk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">ni</span> <span class="o">-</span> <span class="n">nj</span><span class="p">):</span>
                                <span class="n">powk</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nk</span><span class="p">]</span>
                                <span class="n">powijk</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[</span><span class="n">ni</span><span class="p">,</span> <span class="n">nj</span><span class="p">,</span> <span class="n">nk</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">pij</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">ni</span> <span class="o">+</span> <span class="n">nj</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">ni</span> <span class="o">+</span> <span class="n">nj</span><span class="p">]):</span>
                                    <span class="k">for</span> <span class="n">pk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">nk</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">nk</span><span class="p">]):</span>
                                        <span class="n">powtrans</span><span class="p">[</span><span class="n">powijk</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">directmult</span><span class="p">[</span><span class="n">pij</span><span class="p">,</span> <span class="n">pk</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">powtrans</span><span class="p">[</span><span class="n">powij</span><span class="p">,</span> <span class="n">pij</span><span class="p">]</span> <span class="o">*</span> <span class="n">powtrans</span><span class="p">[</span>
                                            <span class="n">powk</span><span class="p">,</span> <span class="n">pk</span><span class="p">]</span>
        <span class="n">npowtrans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Npower</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Npower</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">prange</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="n">npowtrans</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">prange</span><span class="p">,</span> <span class="n">prange</span><span class="p">]</span> <span class="o">=</span> <span class="n">powtrans</span><span class="p">[</span><span class="n">prange</span><span class="p">,</span> <span class="n">prange</span><span class="p">]</span>
            <span class="c1"># now, work on lower values (n-2, n-4, ...)</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">):</span>
                <span class="c1"># powers that sum up to m:</span>
                <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">n0</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="n">n0</span> <span class="o">-</span> <span class="n">n1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">n0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]:</span>
                    <span class="n">npowtrans</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[</span><span class="n">tup</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">npowtrans</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tup</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="p">:]</span> <span class="o">+</span> \
                                                        <span class="n">npowtrans</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tup</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="p">:]</span> <span class="o">+</span> \
                                                        <span class="n">npowtrans</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tup</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="n">npowtrans</span></div>

    <span class="c1"># for sorting our coefficient lists:</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__sortkey</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">entry</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">__INITIALIZED__</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="c1"># these are all *class* parameters, not object parameters: they are computed</span>
    <span class="c1"># and defined once for the entire class. It means that once, in your code, you *choose*</span>
    <span class="c1"># a value for Lmax, you are stuck with it. This is a choice: it makes compatibility between</span>
    <span class="c1"># the expansions easy, for a minor loss in flexibility.</span>
    <span class="c1"># Note: I believe, given the way we&#39;ve set this up, that it *could* be modified to</span>
    <span class="c1"># allow for Lmax to be *increased* as necessary, and all of the structures should be</span>
    <span class="c1"># &quot;backwards compatible&quot;. That said, this has not been tested.</span>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Taylor3D.__initTaylor3Dindexing__"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.__initTaylor3Dindexing__">[docs]</a>    <span class="k">def</span> <span class="nf">__initTaylor3Dindexing__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">Lmax</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This calls *all* the class methods defined above, and stores them *for the class*.</span>
<span class="sd">        This is intended to be done *once*</span>

<span class="sd">        :param Lmax: maximum power / orbital angular momentum</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">__INITIALIZED__</span><span class="p">:</span>
            <span class="c1"># we only need initialize our class once!</span>
            <span class="k">return</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">=</span> <span class="n">Lmax</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">NYlm</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Npower</span><span class="p">,</span> \
        <span class="n">cls</span><span class="o">.</span><span class="n">pow2ind</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">ind2pow</span><span class="p">,</span> \
        <span class="n">cls</span><span class="o">.</span><span class="n">Ylm2ind</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">ind2Ylm</span><span class="p">,</span> \
        <span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">makeindexPowerYlm</span><span class="p">(</span><span class="n">Lmax</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">Ylmpow</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">makeYlmpow</span><span class="p">()</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">powYlm</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">makepowYlm</span><span class="p">()</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">Lproj</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">makeLprojections</span><span class="p">()</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">directmult</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">makedirectmult</span><span class="p">()</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">powercoeff</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">makepowercoeff</span><span class="p">()</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">HDF5str</span> <span class="o">=</span> <span class="s1">&#39;coeff.{}.{}&#39;</span>  <span class="c1"># needed for addhdf5()</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__internallist__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;pow2ind&#39;</span><span class="p">,</span> <span class="s1">&#39;ind2pow&#39;</span><span class="p">,</span> <span class="s1">&#39;Ylm2ind&#39;</span><span class="p">,</span> <span class="s1">&#39;ind2Ylm&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;powlrange&#39;</span><span class="p">,</span> <span class="s1">&#39;Ylmpow&#39;</span><span class="p">,</span> <span class="s1">&#39;powYlm&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;Lproj&#39;</span><span class="p">,</span> <span class="s1">&#39;directmult&#39;</span><span class="p">,</span> <span class="s1">&#39;powercoeff&#39;</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__INITIALIZED__</span> <span class="o">=</span> <span class="bp">True</span></div>

<div class="viewcode-block" id="Taylor3D.__init__"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefflist</span><span class="o">=</span><span class="p">[],</span> <span class="n">Lmax</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">nodeepcopy</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a Taylor3D object, with coefflist (default = empty)</span>

<span class="sd">        :param coefflist: list((n, lmax, powexpansion)). No type checking; default empty</span>
<span class="sd">        :param Lmax: maximum power / orbital angular momentum; can be set only once the</span>
<span class="sd">            first time a Taylor expansion is constructed, and is set for all objects</span>
<span class="sd">        :param nodeepcopy: true if we don&#39;t want to copy the matrices on creation of object</span>
<span class="sd">            (i.e., deep copy, which is the default) **Note:** deep copy is strongly preferred.</span>
<span class="sd">            The *only* real reason to use nodeepcopy is when returning slices / indexing in</span>
<span class="sd">            arrays, but even then we have to be careful about doing things like reductions,</span>
<span class="sd">            etc., that modify matrices *in place*. We always copy the list, but that</span>
<span class="sd">            doesn&#39;t make copies of the underlying matrices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__initTaylor3Dindexing__</span><span class="p">(</span><span class="n">Lmax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nodeepcopy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coefflist</span> <span class="o">=</span> <span class="n">coefflist</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coefflist</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coefflist</span><span class="p">]</span></div>

<div class="viewcode-block" id="Taylor3D.copy"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a copy of the current expansion&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Taylor3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefflist</span><span class="p">)</span></div>

<div class="viewcode-block" id="Taylor3D.addhdf5"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.addhdf5">[docs]</a>    <span class="k">def</span> <span class="nf">addhdf5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">HDF5group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an HDF5 representation of object into an HDF5group (needs to already exist).</span>
<span class="sd">        Example: if f is an open HDF5, then T3D.addhdf5(f.create_group(&#39;T3D&#39;)) will</span>
<span class="sd">        (1) create the group named &#39;T3D&#39;, and then (2) put the T3D representation in</span>
<span class="sd">        that group.</span>

<span class="sd">        :param HDF5group: HDF5 group</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">HDF5group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
        <span class="n">HDF5group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;Lmax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Lmax</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefflist</span><span class="p">:</span>
            <span class="n">coeffstr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">HDF5str</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
            <span class="n">HDF5group</span><span class="p">[</span><span class="n">coeffstr</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
            <span class="n">HDF5group</span><span class="p">[</span><span class="n">coeffstr</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
            <span class="n">HDF5group</span><span class="p">[</span><span class="n">coeffstr</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;l&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Taylor3D.loadhdf5"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.loadhdf5">[docs]</a>    <span class="k">def</span> <span class="nf">loadhdf5</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">HDF5group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new T3D from an HDF5 group.</span>

<span class="sd">        :param HDFgroup: HDF5 group</span>
<span class="sd">        :return T3D: new T3D object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t3d</span> <span class="o">=</span> <span class="n">cls</span><span class="p">()</span>  <span class="c1"># initialize</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">HDF5group</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">HDF5group</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">HDF5group</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;l&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">t3d</span><span class="o">.</span><span class="n">Lmax</span> <span class="ow">or</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;HDF5 group data contains illegal l = {} for {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
            <span class="n">t3d</span><span class="o">.</span><span class="n">coefflist</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">t3d</span></div>

<div class="viewcode-block" id="Taylor3D.dumpinternalsHDF5"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.dumpinternalsHDF5">[docs]</a>    <span class="k">def</span> <span class="nf">dumpinternalsHDF5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">HDF5group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds the initialized power expansion internals into an HDF5group--should be stored for a</span>
<span class="sd">        sanity check</span>

<span class="sd">        :param HDF5group: HDF5 group</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">HDF5group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Internals of PowerExpansion class&#39;</span>
        <span class="n">HDF5group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;Lmax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Lmax</span>
        <span class="n">HDF5group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;NYlm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">NYlm</span>
        <span class="n">HDF5group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;Npower&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Npower</span>
        <span class="k">for</span> <span class="n">internal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__internallist__</span><span class="p">:</span>
            <span class="n">HDF5group</span><span class="p">[</span><span class="n">internal</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">internal</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Taylor3D.checkinternalsHDF5"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.checkinternalsHDF5">[docs]</a>    <span class="k">def</span> <span class="nf">checkinternalsHDF5</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">HDF5group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the power expansion internals into an HDF5group, and performs sanity check</span>

<span class="sd">        :param HDF5group: HDF5 group</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cls</span><span class="o">.</span><span class="n">__INITIALIZED__</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must initialize first to perform sanity check&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">HDF5group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">u&#39;Internals of PowerExpansion class&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;HDF5 group lacks the attribute &quot;description&quot; which matches &quot;Internals of PowerExpansion class&quot;&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">HDF5group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;Lmax&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">HDF5group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;NYlm&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cls</span><span class="o">.</span><span class="n">NYlm</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">HDF5group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;Npower&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cls</span><span class="o">.</span><span class="n">Npower</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">internal</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">__internallist__</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">HDF5group</span><span class="p">[</span><span class="n">internal</span><span class="p">][:]</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">internal</span><span class="p">)):</span> <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Taylor3D.zeros"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.zeros">[docs]</a>    <span class="k">def</span> <span class="nf">zeros</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">nmin</span><span class="p">,</span> <span class="n">nmax</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs (and returns) a &quot;zero&quot; Taylor expansion with the prescribed shape.</span>
<span class="sd">        This will be useful for doing slicing assignments. Because of the manner in</span>
<span class="sd">        which slicing works for assignment, we create what looks like a *lot* of</span>
<span class="sd">        zeros, by explicitly making the full range of l values.</span>

<span class="sd">        :param nmin: minimum value of n</span>
<span class="sd">        :param nmax: maximum value of n (inclusive)</span>
<span class="sd">        :param shape: shape of matrix, as zeros would expect.</span>
<span class="sd">        :return Taylor3D: Taylor3D, with a zero coefficient list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">([(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">l</span><span class="p">],)</span> <span class="o">+</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmin</span><span class="p">,</span> <span class="n">nmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span></div>

<div class="viewcode-block" id="Taylor3D.__getitem__"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indexes (or even slices) into our Taylor expansion.</span>

<span class="sd">        :param key: indices for our Taylor expansion</span>
<span class="sd">        :return Taylor3D: Taylor expansion after indexing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="n">keyt</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">keyt</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">return</span> <span class="n">Taylor3D</span><span class="p">([(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">),)</span> <span class="o">+</span> <span class="n">keyt</span><span class="p">])</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefflist</span><span class="p">],</span> <span class="n">nodeepcopy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Taylor3D.__setitem__"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.__setitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indexes (or even slices) into our Taylor expansion and &quot;sets&quot;; really only intended to work</span>
<span class="sd">        with another Taylor expansion</span>

<span class="sd">        :param key: indices for our Taylor expansion</span>
<span class="sd">        :param value: assignment value; really, should be</span>
<span class="sd">        :return: Taylor expansion after indexing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;coefflist&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can only do setitem ([...] = ) with another Taylor3D on the rhs&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="n">keyt</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">keyt</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">for</span> <span class="n">nv</span><span class="p">,</span> <span class="n">lv</span><span class="p">,</span> <span class="n">cv</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">coefflist</span><span class="p">:</span>
            <span class="n">matched</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefflist</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">nv</span> <span class="ow">and</span> <span class="n">l</span> <span class="o">==</span> <span class="n">lv</span><span class="p">:</span>
                    <span class="n">matched</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">c</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">),)</span> <span class="o">+</span> <span class="n">keyt</span><span class="p">]</span> <span class="o">=</span> <span class="n">cv</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">matched</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Attempted to do setitem where the rhs contains terms not present in lhs&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Taylor3D.__str__"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Human readable string representation&quot;&quot;&quot;</span>
        <span class="n">strrep</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefflist</span><span class="p">:</span>
            <span class="n">strrep</span> <span class="o">=</span> <span class="n">strrep</span> <span class="o">+</span> <span class="s2">&quot;f^({}, {})(u)*(&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">l</span><span class="p">]):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="mi">0</span><span class="p">)):</span>
                    <span class="n">strrep</span> <span class="o">=</span> <span class="n">strrep</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">{} x^{} y^{} z^{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="n">p</span><span class="p">],</span>
                                                                   <span class="bp">self</span><span class="o">.</span><span class="n">ind2pow</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ind2pow</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                                                                   <span class="bp">self</span><span class="o">.</span><span class="n">ind2pow</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">strrep</span> <span class="o">=</span> <span class="n">strrep</span> <span class="o">+</span> <span class="s2">&quot; )</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">strrep</span></div>

<div class="viewcode-block" id="Taylor3D.addterms"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.addterms">[docs]</a>    <span class="k">def</span> <span class="nf">addterms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefflist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add additional coefficients into our object. No type checking. Only works if</span>
<span class="sd">        terms are completely non-overlapping (otherwise, need to use sum).</span>

<span class="sd">        :param coefflist: list((n, lmax, powexpansion))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># getattr is here *in case* someone passes us a Taylor3D type object...</span>
        <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">coefflist</span><span class="p">,</span> <span class="s1">&#39;coefflist&#39;</span><span class="p">,</span> <span class="n">coefflist</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefflist</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can only use addterms to include new powers; use + instead&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coefflist</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coefflist</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__sortkey</span><span class="p">)</span></div>

<div class="viewcode-block" id="Taylor3D.__call__"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">fnu</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method for evaluating our 3D Taylor expansion. We have two approaches: if we are</span>
<span class="sd">        passed a dictionary in fnu that will map (n,l) tuple pairs to either (a) values or</span>
<span class="sd">        (b) functions of a single parameter umagn, then we will compute and return the</span>
<span class="sd">        function value. Otherwise, we return a dictionary mapping (n,l) tuple pairs into</span>
<span class="sd">        values, and leave it at that.</span>

<span class="sd">        :param u: three vector to evaluate; may (or may not) be normalized</span>
<span class="sd">        :param fnu: dictionary of (n,l): value or function pairs.</span>
<span class="sd">        :return value or dictionary: depending on fnu; default is dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u0</span><span class="p">,</span> <span class="n">umagn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">powexp</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fnu</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">fval</span> <span class="o">=</span> <span class="p">[</span><span class="n">fnu</span><span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">)](</span><span class="n">umagn</span><span class="p">)</span> <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">fnu</span><span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">)])</span> <span class="k">else</span> <span class="n">fnu</span><span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">)]</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefflist</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fv</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">u0</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">l</span><span class="p">]],</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">fv</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefflist</span><span class="p">))</span>
        <span class="c1"># otherwise, create a dictionary!</span>
        <span class="k">return</span> <span class="p">{(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">u0</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">l</span><span class="p">]],</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefflist</span><span class="p">}</span></div>

<div class="viewcode-block" id="Taylor3D.nl"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.nl">[docs]</a>    <span class="k">def</span> <span class="nf">nl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of (n,l) pairs in the coefflist</span>

<span class="sd">        :return nl_list: all of the (n,l) pairs that are present in our coefflist</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">([(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefflist</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__sortkey</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Taylor3D.negcoeff"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.negcoeff">[docs]</a>    <span class="k">def</span> <span class="nf">negcoeff</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Negates a coefficient expansion a</span>

<span class="sd">        :param a = list((n, lmax, powexpansion): expansion of function in powers</span>
<span class="sd">        :return coefflist: -a</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">acoeff</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;coefflist&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="n">nega</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">an</span><span class="p">,</span> <span class="n">almax</span><span class="p">,</span> <span class="n">apow</span> <span class="ow">in</span> <span class="n">acoeff</span><span class="p">:</span>
            <span class="n">nega</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">an</span><span class="p">,</span> <span class="n">almax</span><span class="p">,</span> <span class="o">-</span><span class="n">apow</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">nega</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Taylor3D.scalarproductcoeff"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.scalarproductcoeff">[docs]</a>    <span class="k">def</span> <span class="nf">scalarproductcoeff</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiplies an coefficient expansion a by a scalar c</span>

<span class="sd">        :param c: scalar *or* dictionary mapping (n,l) to scalars</span>
<span class="sd">        :param a = list((n, lmax, powexpansion): expansion of function in powers</span>
<span class="sd">        :param inplace: modify a in place?</span>
<span class="sd">        :return coefflist: c*a</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">acoeff</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;coefflist&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">an</span><span class="p">,</span> <span class="n">almax</span><span class="p">,</span> <span class="n">apow</span> <span class="ow">in</span> <span class="n">acoeff</span><span class="p">:</span>
                    <span class="n">apow</span> <span class="o">*=</span> <span class="n">c</span><span class="p">[(</span><span class="n">an</span><span class="p">,</span> <span class="n">almax</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">an</span><span class="p">,</span> <span class="n">almax</span><span class="p">,</span> <span class="n">apow</span> <span class="ow">in</span> <span class="n">acoeff</span><span class="p">:</span>
                    <span class="n">apow</span> <span class="o">*=</span> <span class="n">c</span>
            <span class="n">ca</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># create new expansion</span>
            <span class="n">ca</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">an</span><span class="p">,</span> <span class="n">almax</span><span class="p">,</span> <span class="n">apow</span> <span class="ow">in</span> <span class="n">acoeff</span><span class="p">:</span>
                    <span class="n">ca</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">an</span><span class="p">,</span> <span class="n">almax</span><span class="p">,</span> <span class="n">c</span><span class="p">[(</span><span class="n">an</span><span class="p">,</span> <span class="n">almax</span><span class="p">)]</span> <span class="o">*</span> <span class="n">apow</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">an</span><span class="p">,</span> <span class="n">almax</span><span class="p">,</span> <span class="n">apow</span> <span class="ow">in</span> <span class="n">acoeff</span><span class="p">:</span>
                    <span class="n">ca</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">an</span><span class="p">,</span> <span class="n">almax</span><span class="p">,</span> <span class="n">c</span> <span class="o">*</span> <span class="n">apow</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ca</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Taylor3D.rotatecoeff"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.rotatecoeff">[docs]</a>    <span class="k">def</span> <span class="nf">rotatecoeff</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">npowtrans</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a rotated version of the expansion. Needs to use pad to work with reduced representations.</span>

<span class="sd">        :param a: coefficiant list</span>
<span class="sd">        :param npowtrans: Lmax+1 x Npow x Npow matrix, of [n,oldpow,newpow] corresponding to the rotation</span>
<span class="sd">        :return rcoeff: coefficient list, rotated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">acoeff</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;coefflist&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">acoeff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">acoeff</span>
        <span class="c1"># needed to make padding easier: we only pad the first axis corresponding to our powers</span>
        <span class="n">padtuple</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">acoeff</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">npowtrans</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="p">:</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">n</span><span class="p">]],</span>
                                        <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">l</span><span class="p">]),)</span> <span class="o">+</span> <span class="n">padtuple</span><span class="p">,</span>
                                               <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">),</span>
                                        <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
                    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">acoeff</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">acoeff</span><span class="p">):</span>
                <span class="n">acoeff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">npowtrans</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="p">:</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">n</span><span class="p">]],</span>
                                                <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">l</span><span class="p">]),)</span> <span class="o">+</span> <span class="n">padtuple</span><span class="p">,</span>
                                                       <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">),</span>
                                                <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">acoeff</span></div>

<div class="viewcode-block" id="Taylor3D.rotate"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">powtrans</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a rotated version of the expansion.</span>

<span class="sd">        :param powtrans: Npow x Npow matrix, of [oldpow,newpow] corresponding to the rotation</span>
<span class="sd">        :return rTaylor3D: Taylor expansion, rotated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Taylor3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotatecoeff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefflist</span><span class="p">,</span> <span class="n">powtrans</span><span class="p">))</span></div>

<div class="viewcode-block" id="Taylor3D.irotate"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.irotate">[docs]</a>    <span class="k">def</span> <span class="nf">irotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">powtrans</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotate in place.</span>

<span class="sd">        :param powtrans: Npow x Npow matrix, of [oldpow,newpow] corresponding to the rotation</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotatecoeff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefflist</span><span class="p">,</span> <span class="n">powtrans</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Taylor3D.sumcoeff"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.sumcoeff">[docs]</a>    <span class="k">def</span> <span class="nf">sumcoeff</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes Taylor3D expansion a and b, and returns the sum of the expansions.</span>

<span class="sd">        :param: a, b = list((n, lmax, powexpansion)</span>
<span class="sd">            written as a series of coefficients; n defines the magnitude function, which</span>
<span class="sd">            is additive; lmax is the largest cumulative power of coefficients, and</span>
<span class="sd">            powexpansion is a numpy array that can multiplied. We assume that a and b</span>
<span class="sd">            have consistent shapes throughout--we *do not test this*; runtime will likely</span>
<span class="sd">            fail if not true. The entries in the list are *tuples* of n, lmax, pow</span>
<span class="sd">        :param alpha, beta:</span>
<span class="sd">            optional scalars: c = alpha*a + beta*b; allows for more efficient expansions</span>
<span class="sd">        :param inplace: True if the summation should modify a in place</span>
<span class="sd">        :return c: coeff of sum of a and b (! NOTE ! does not return the class!)</span>
<span class="sd">            sum of a and b</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># a little pythonic magic to work with *either* a list, or an object with a coefflist</span>
        <span class="n">acoeff</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;coefflist&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>  <span class="c1"># fallback to a if not there... which assumes it&#39;s a list</span>
        <span class="n">bcoeff</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;coefflist&#39;</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  <span class="c1"># fallback to b if not there... which assumes it&#39;s a list</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bcoeff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">scalarproductcoeff</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">acoeff</span><span class="p">,</span> <span class="n">inplace</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">acoeff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">scalarproductcoeff</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">bcoeff</span><span class="p">,</span> <span class="n">inplace</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">scalarproductcoeff</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">bcoeff</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
                    <span class="n">acoeff</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">acoeff</span>
        <span class="n">ashape</span> <span class="o">=</span> <span class="n">acoeff</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">bshape</span> <span class="o">=</span> <span class="n">bcoeff</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">ashape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">bshape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unable to add--not compatible&#39;</span><span class="p">)</span>
        <span class="c1"># make c = copy of a</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="p">[(</span><span class="n">an</span><span class="p">,</span> <span class="n">almax</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">apow</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">an</span><span class="p">,</span> <span class="n">almax</span><span class="p">,</span> <span class="n">apow</span><span class="p">)</span> <span class="ow">in</span> <span class="n">acoeff</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">acoeff</span>
        <span class="k">for</span> <span class="n">bn</span><span class="p">,</span> <span class="n">blmax</span><span class="p">,</span> <span class="n">bpow</span> <span class="ow">in</span> <span class="n">bcoeff</span><span class="p">:</span>
            <span class="c1"># now add it into the list</span>
            <span class="n">cpow</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">bpow</span>
            <span class="n">matched</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">coeffindex</span><span class="p">,</span> <span class="n">cmatch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">cmatch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">bn</span><span class="p">:</span>
                    <span class="n">matched</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">matched</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">bn</span><span class="p">,</span> <span class="n">blmax</span><span class="p">,</span> <span class="n">cpow</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># a little tricky: we need to *append* to an existing term</span>
                <span class="n">clmax0</span> <span class="o">=</span> <span class="n">cmatch</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">blmax</span> <span class="o">&gt;</span> <span class="n">clmax0</span><span class="p">:</span>
                    <span class="c1"># need to replace cmatch with a new tuple</span>
                    <span class="n">cpow</span><span class="p">[:</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">clmax0</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">cmatch</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">c</span><span class="p">[</span><span class="n">coeffindex</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">bn</span><span class="p">,</span> <span class="n">blmax</span><span class="p">,</span> <span class="n">cpow</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># can just append in place: need to be careful, since we have a tuple</span>
                    <span class="n">coeff</span> <span class="o">=</span> <span class="n">cmatch</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">coeff</span><span class="p">[:</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">blmax</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">cpow</span>
        <span class="n">c</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">cls</span><span class="o">.</span><span class="n">__sortkey</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">c</span></div>

<div class="viewcode-block" id="Taylor3D.__pos__"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.__pos__">[docs]</a>    <span class="k">def</span> <span class="nf">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return +T3D&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="Taylor3D.__neg__"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.__neg__">[docs]</a>    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return -T3D&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Taylor3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">negcoeff</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

<div class="viewcode-block" id="Taylor3D.__add__"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.__add__">[docs]</a>    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a set of Taylor expansions&quot;&quot;&quot;</span>
        <span class="c1"># if we&#39;re passed an array, just take it in stride</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span> <span class="n">other</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">Taylor3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sumcoeff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span></div>

<div class="viewcode-block" id="Taylor3D.__radd__"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.__radd__">[docs]</a>    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a set of Taylor expansions&quot;&quot;&quot;</span>
        <span class="c1"># note: sum(), without a start value, uses 0, which then will call __radd__:</span>
        <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># if we&#39;re passed an array, just take it in stride</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span> <span class="n">other</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">Taylor3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sumcoeff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span></div>

<div class="viewcode-block" id="Taylor3D.__iadd__"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.__iadd__">[docs]</a>    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a set of Taylor expansions&quot;&quot;&quot;</span>
        <span class="c1"># if we&#39;re passed an array, just take it in stride</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span> <span class="n">other</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">))]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sumcoeff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Taylor3D.__sub__"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.__sub__">[docs]</a>    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Subtract a set of Taylor expansions&quot;&quot;&quot;</span>
        <span class="c1"># if we&#39;re passed an array, just take it in stride</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span> <span class="n">other</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">Taylor3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sumcoeff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="Taylor3D.__rsub__"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.__rsub__">[docs]</a>    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Subtract a set of Taylor expansions&quot;&quot;&quot;</span>
        <span class="c1"># if we&#39;re passed an array, just take it in stride</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span> <span class="n">other</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">Taylor3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sumcoeff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="Taylor3D.__isub__"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.__isub__">[docs]</a>    <span class="k">def</span> <span class="nf">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Subtract a set of Taylor expansions&quot;&quot;&quot;</span>
        <span class="c1"># if we&#39;re passed an array, just take it in stride</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span> <span class="n">other</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">))]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sumcoeff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Taylor3D.tensorproductcoeff"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.tensorproductcoeff">[docs]</a>    <span class="k">def</span> <span class="nf">tensorproductcoeff</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">leftmultiply</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiplies an coefficient expansion a by a scalar c</span>

<span class="sd">        :param c: array *or* dictionary mapping (n,l) to arrays</span>
<span class="sd">        :param a = list((n, lmax, powexpansion): expansion of function in powers</span>
<span class="sd">        :param leftmultiply: tensordot(c,a) vs. tensordot(a,c)</span>
<span class="sd">        :return coefflist: c.a (or a.c)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">acoeff</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;coefflist&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Number</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">[(</span><span class="n">acoeff</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">acoeff</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])],</span> <span class="n">Number</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">scalarproductcoeff</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">an</span><span class="p">,</span> <span class="n">almax</span><span class="p">,</span> <span class="n">apow</span> <span class="ow">in</span> <span class="n">acoeff</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">cmult</span> <span class="o">=</span> <span class="n">c</span><span class="p">[(</span><span class="n">an</span><span class="p">,</span> <span class="n">almax</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cmult</span> <span class="o">=</span> <span class="n">c</span>
            <span class="k">if</span> <span class="n">leftmultiply</span><span class="p">:</span>
                <span class="c1"># tricky because of layout of apow</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">apow</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="n">cmult</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">apow</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">almax</span><span class="p">]):</span>
                    <span class="n">mat</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">cmult</span><span class="p">,</span> <span class="n">apow</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">ca</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">an</span><span class="p">,</span> <span class="n">almax</span><span class="p">,</span> <span class="n">mat</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ca</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">an</span><span class="p">,</span> <span class="n">almax</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">apow</span><span class="p">,</span> <span class="n">cmult</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))))</span>
        <span class="k">return</span> <span class="n">ca</span></div>

<div class="viewcode-block" id="Taylor3D.ldot"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.ldot">[docs]</a>    <span class="k">def</span> <span class="nf">ldot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns :math:`c\\cdot self`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Taylor3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tensorproductcoeff</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span></div>

<div class="viewcode-block" id="Taylor3D.rdot"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.rdot">[docs]</a>    <span class="k">def</span> <span class="nf">rdot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns :math:`self\\cdot c`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Taylor3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tensorproductcoeff</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">leftmultiply</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span></div>

<div class="viewcode-block" id="Taylor3D.ildot"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.ildot">[docs]</a>    <span class="k">def</span> <span class="nf">ildot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes :math:`c\\cdot self` in place&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coefflist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensorproductcoeff</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Taylor3D.irdot"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.irdot">[docs]</a>    <span class="k">def</span> <span class="nf">irdot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes :math:`self\\cdot c` in place&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coefflist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensorproductcoeff</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">leftmultiply</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Taylor3D.coeffproductcoeff"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.coeffproductcoeff">[docs]</a>    <span class="k">def</span> <span class="nf">coeffproductcoeff</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a direction expansion a and b, and returns the product expansion.</span>

<span class="sd">        :param a: list((n, lmax, powexpansion)</span>
<span class="sd">        :param b: list((n, lmax, powexpansion)</span>
<span class="sd">            written as a series of coefficients; n defines the magnitude function, which</span>
<span class="sd">            is additive; lmax is the largest cumulative power of coefficients, and</span>
<span class="sd">            powexpansion is a numpy array that can multiplied. We assume that a and b</span>
<span class="sd">            have consistent shapes throughout--we *do not test this*; runtime will likely</span>
<span class="sd">            fail if not true. The entries in the list are *tuples* of n, lmax, pow</span>
<span class="sd">        :return c: list((n, lmax, powexpansion)), product of ``a`` and ``b``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># a little pythonic magic to work with *either* a list, or an object with a coefflist</span>
        <span class="n">acoeff</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;coefflist&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>  <span class="c1"># fallback to a if not there... which assumes it&#39;s a list</span>
        <span class="n">bcoeff</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;coefflist&#39;</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  <span class="c1"># fallback to b if not there... which assumes it&#39;s a list</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">acoeff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">acoeff</span>  <span class="c1"># 0*anything == 0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bcoeff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">bcoeff</span>  <span class="c1"># anything*0 == 0</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ashape</span> <span class="o">=</span> <span class="n">acoeff</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">bshape</span> <span class="o">=</span> <span class="n">bcoeff</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">scalarmult</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ashape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cshape</span> <span class="o">=</span> <span class="n">bshape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">scalarmult</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">bshape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cshape</span> <span class="o">=</span> <span class="n">ashape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">scalarmult</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ashape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bshape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unable to multiply--not compatible&#39;</span><span class="p">)</span>
            <span class="n">cshape</span> <span class="o">=</span> <span class="n">ashape</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">bshape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>  <span class="c1"># weird piece of python to find the shape of a*b</span>
        <span class="k">for</span> <span class="n">an</span><span class="p">,</span> <span class="n">almax</span><span class="p">,</span> <span class="n">apow</span> <span class="ow">in</span> <span class="n">acoeff</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">bn</span><span class="p">,</span> <span class="n">blmax</span><span class="p">,</span> <span class="n">bpow</span> <span class="ow">in</span> <span class="n">bcoeff</span><span class="p">:</span>
                <span class="n">cn</span> <span class="o">=</span> <span class="n">an</span> <span class="o">+</span> <span class="n">bn</span>
                <span class="n">clmax</span> <span class="o">=</span> <span class="n">almax</span> <span class="o">+</span> <span class="n">blmax</span>
                <span class="k">if</span> <span class="n">clmax</span> <span class="o">&gt;</span> <span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span><span class="p">:</span>
                    <span class="c1"># in theory... we should warn the user here</span>
                    <span class="n">clmax</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">Lmax</span>
                <span class="c1"># construct the expansion</span>
                <span class="n">cpow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">clmax</span><span class="p">],)</span> <span class="o">+</span> <span class="n">cshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">pa</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">almax</span><span class="p">]):</span>
                    <span class="k">for</span> <span class="n">pb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">blmax</span><span class="p">]):</span>
                        <span class="k">if</span> <span class="n">scalarmult</span><span class="p">:</span>
                            <span class="n">cpow</span><span class="p">[</span><span class="n">cls</span><span class="o">.</span><span class="n">directmult</span><span class="p">[</span><span class="n">pa</span><span class="p">,</span> <span class="n">pb</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">apow</span><span class="p">[</span><span class="n">pa</span><span class="p">]</span> <span class="o">*</span> <span class="n">bpow</span><span class="p">[</span><span class="n">pb</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">cpow</span><span class="p">[</span><span class="n">cls</span><span class="o">.</span><span class="n">directmult</span><span class="p">[</span><span class="n">pa</span><span class="p">,</span> <span class="n">pb</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">apow</span><span class="p">[</span><span class="n">pa</span><span class="p">],</span> <span class="n">bpow</span><span class="p">[</span><span class="n">pb</span><span class="p">],</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># now add it into the list</span>
                <span class="n">matched</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">for</span> <span class="n">coeffindex</span><span class="p">,</span> <span class="n">cmatch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">cmatch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cn</span><span class="p">:</span>
                        <span class="n">matched</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">matched</span><span class="p">:</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cn</span><span class="p">,</span> <span class="n">clmax</span><span class="p">,</span> <span class="n">cpow</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># a little tricky: we need to *append* to an existing term</span>
                    <span class="n">clmax0</span> <span class="o">=</span> <span class="n">cmatch</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">clmax</span> <span class="o">&gt;</span> <span class="n">clmax0</span><span class="p">:</span>
                        <span class="c1"># need to replace cmatch with a new tuple</span>
                        <span class="n">cpow</span><span class="p">[:</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">clmax0</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">cmatch</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                        <span class="n">c</span><span class="p">[</span><span class="n">coeffindex</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="n">clmax</span><span class="p">,</span> <span class="n">cpow</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># can just append in place: need to be careful, since we have a tuple</span>
                        <span class="n">coeff</span> <span class="o">=</span> <span class="n">cmatch</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                        <span class="n">coeff</span><span class="p">[:</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">clmax</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">cpow</span>
        <span class="n">c</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">cls</span><span class="o">.</span><span class="n">__sortkey</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">c</span></div>

<div class="viewcode-block" id="Taylor3D.__mul__"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.__mul__">[docs]</a>    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiply our expansion</span>

<span class="sd">        :param other:</span>
<span class="sd">        :return Taylor3D: expansion of product</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Number</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalarproductcoeff</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeffproductcoeff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Taylor3D</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span></div>

<div class="viewcode-block" id="Taylor3D.__rmul__"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.__rmul__">[docs]</a>    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiply our expansion</span>

<span class="sd">        :param other:</span>
<span class="sd">        :return Taylor3D: expansion of product</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Number</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalarproductcoeff</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeffproductcoeff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Taylor3D</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Taylor3D.inversecoeff"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.inversecoeff">[docs]</a>    <span class="k">def</span> <span class="nf">inversecoeff</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">Nmax</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a direction expansion , and returns the inversion expansion (approximated</span>
<span class="sd">        based on the Taylor expansion of :math:`1/(1-x) = \\sum_{i=0}^{\\infty} x^i`, or</span>
<span class="sd">        :math:`(A + B)^{-1} = ((1+BA^{-1})A)^{-1} = A^{-1}(1-(-BA{^1}))^{-1} = A^{-1} \\sum_{i=0} (-BA^{-1})^i`</span>

<span class="sd">        NOTE: assumes SMALLEST n coefficient is the leading order; only works if that</span>
<span class="sd">        coefficient is also isotropic (l=0). Otherwise, raises an error.</span>
<span class="sd">        NOTE: there is no sanity check on whether Nmax is reasonable given the expansion</span>
<span class="sd">        and Lmax values; *caveat emptor*.</span>

<span class="sd">        :param a: = list((n, lmax, powexpansion)</span>
<span class="sd">            written as a series of coefficients; n defines the magnitude function, which</span>
<span class="sd">            is additive; lmax is the largest cumulative power of coefficients, and</span>
<span class="sd">            powexpansion is a numpy array that can multiplied. We assume that a and b</span>
<span class="sd">            have consistent shapes throughout--we *do not test this*; runtime will likely</span>
<span class="sd">            fail if not true. The entries in the list are *tuples* of n, lmax, pow</span>
<span class="sd">        :param Nmax: maximum remaining n value in expansion. Default value of 0 means</span>
<span class="sd">            up to a discontinuity correction in an inversion, but higher (or lower) values are</span>
<span class="sd">            possible.</span>
<span class="sd">        :return c: list((n, lmax, powexpansion)), inverse of a</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># a little pythonic magic to work with *either* a list, or an object with a coefflist</span>
        <span class="n">acoeff</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;coefflist&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span>
                        <span class="n">key</span><span class="o">=</span><span class="n">cls</span><span class="o">.</span><span class="n">__sortkey</span><span class="p">)</span>  <span class="c1"># fallback to a if not there... which assumes it&#39;s a list</span>
        <span class="n">lead</span> <span class="o">=</span> <span class="n">acoeff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">lead</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot invert expansion: leading-order term {} has l={}&gt;0&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lead</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lead</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lead</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">leadinvmat</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">lead</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">leadinvmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">lead</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">leadinvpow</span> <span class="o">=</span> <span class="o">-</span><span class="n">lead</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">[(</span><span class="n">leadinvpow</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">leadinvmat</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">lead</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">))]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">acoeff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># trivial case</span>
            <span class="k">return</span> <span class="n">c</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">leadinvpow</span> <span class="o">+</span> <span class="n">acoeff</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot invert expansion: second term has same power as leading-order term?&#39;</span><span class="p">)</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span> <span class="o">+</span> <span class="n">leadinvpow</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="o">-</span><span class="n">coeff</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">tensorproductcoeff</span><span class="p">(</span><span class="n">leadinvmat</span><span class="p">,</span> <span class="n">acoeff</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">leftmultiply</span><span class="o">=</span><span class="bp">True</span><span class="p">)]</span>
        <span class="c1"># now we can calculate the number of terms necessary:</span>
        <span class="c1"># leadinvpow + n*(tail[0][0]) &gt;= Nmax</span>
        <span class="n">Nseries</span> <span class="o">=</span> <span class="p">(</span><span class="n">Nmax</span> <span class="o">-</span> <span class="n">leadinvpow</span><span class="p">)</span> <span class="o">//</span> <span class="n">tail</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># prime the pump: leadinvmat = A^-1, tail = -A^-1 B</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">sumcoeff</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">[(</span><span class="n">n</span> <span class="o">+</span> <span class="n">leadinvpow</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span>
                         <span class="n">cls</span><span class="o">.</span><span class="n">tensorproductcoeff</span><span class="p">(</span><span class="n">leadinvmat</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">leftmultiply</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                         <span class="k">if</span> <span class="n">n</span> <span class="o">+</span> <span class="n">leadinvpow</span> <span class="o">&lt;=</span> <span class="n">Nmax</span><span class="p">],</span>
                     <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">tailn</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">coeff</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">tail</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">npower</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">Nseries</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># trim out the powers that are too large once they become too large:</span>
            <span class="n">tailn</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">coeffproductcoeff</span><span class="p">(</span><span class="n">tailn</span><span class="p">,</span> <span class="n">tail</span><span class="p">)</span>
                     <span class="k">if</span> <span class="n">n</span> <span class="o">+</span> <span class="n">leadinvpow</span> <span class="o">&lt;=</span> <span class="n">Nmax</span><span class="p">]</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">sumcoeff</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">[(</span><span class="n">n</span> <span class="o">+</span> <span class="n">leadinvpow</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span>
                             <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span>
                             <span class="n">cls</span><span class="o">.</span><span class="n">tensorproductcoeff</span><span class="p">(</span><span class="n">leadinvmat</span><span class="p">,</span> <span class="n">tailn</span><span class="p">,</span> <span class="n">leftmultiply</span><span class="o">=</span><span class="bp">False</span><span class="p">)],</span>
                         <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">c</span></div>

<div class="viewcode-block" id="Taylor3D.inv"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.inv">[docs]</a>    <span class="k">def</span> <span class="nf">inv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Nmax</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the inverse of the expansion, up to order Nmax</span>

<span class="sd">        :param Nmax: maximum order in the inverse expansion</span>
<span class="sd">        :return Taylor3D^-1: Taylor series of inverse</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Taylor3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inversecoeff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Nmax</span><span class="p">))</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Taylor3D.reducecoeff"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.reducecoeff">[docs]</a>    <span class="k">def</span> <span class="nf">reducecoeff</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Projects coefficients through Ylm space, then eliminates any zero contributions</span>
<span class="sd">        (including possible reduction in l values, too).</span>

<span class="sd">        :param a: list((n, lmax, powexpansion), expansion of function in powers</span>
<span class="sd">        :param inplace: modify a in place?</span>
<span class="sd">        :return coefflist: a</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">acoeff</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;coefflist&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">ra</span> <span class="o">=</span> <span class="n">acoeff</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ra</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">acoeff</span><span class="p">]</span>
        <span class="n">projector</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">Lproj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dellist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">coeffindex</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ra</span><span class="p">):</span>
            <span class="c1"># first, project</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">projector</span><span class="p">[:</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="p">:</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">l</span><span class="p">]],</span> <span class="n">c</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># print(c)</span>
            <span class="c1"># now, systematically attempt to reduce the l value</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">):</span>
                <span class="c1"># occasionally, it gets reduced to zero:</span>
                <span class="n">dellist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeffindex</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># then we have something to look at... systematically attempt to drop l:</span>
                <span class="c1"># check in blocks</span>
                <span class="k">for</span> <span class="n">lmin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">lmin</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">lmin</span><span class="p">]],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">):</span>
                        <span class="k">break</span>
                <span class="c1"># reduce! Note: we do this *every time* because c is the projected version of our coeff.</span>
                <span class="n">ra</span><span class="p">[</span><span class="n">coeffindex</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">lmin</span><span class="p">,</span> <span class="n">c</span><span class="p">[:</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">lmin</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="c1"># finally, let&#39;s deal with our delete list; do this by popping, and in reverse index order</span>
        <span class="n">dellist</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">dellist</span><span class="p">:</span>
            <span class="n">ra</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ra</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Taylor3D.collectcoeff"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.collectcoeff">[docs]</a>    <span class="k">def</span> <span class="nf">collectcoeff</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collects coefficients: sums up all the common n values. Best to be done *after*</span>
<span class="sd">        reduce is called.</span>

<span class="sd">        :param a: list((n, lmax, powexpansion), expansion of function in powers</span>
<span class="sd">        :param inplace: modify a in place?</span>
<span class="sd">        :return coefflist: a</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">acoeff</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;coefflist&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">ca</span> <span class="o">=</span> <span class="n">acoeff</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ca</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">acoeff</span><span class="p">]</span>
        <span class="c1"># so: the sort is such that all of the common n values are in ascending order</span>
        <span class="c1"># *and* ascending l order. Makes collecting very easy:</span>
        <span class="n">ca</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">cls</span><span class="o">.</span><span class="n">__sortkey</span><span class="p">)</span>
        <span class="n">projector</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">Lproj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dellist</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># indices to be eliminated</span>
        <span class="k">for</span> <span class="n">coeffindex</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ca</span><span class="p">):</span>
            <span class="c1"># first, project</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">projector</span><span class="p">[:</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="p">:</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">l</span><span class="p">]],</span> <span class="n">c</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">):</span>
                <span class="c1"># if we have zero coefficients, remove from the list</span>
                <span class="n">dellist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeffindex</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">coeffindex</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ca</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ca</span><span class="p">[</span><span class="n">coeffindex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
                        <span class="c1"># same n, so collect:</span>
                        <span class="n">ca</span><span class="p">[</span><span class="n">coeffindex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">][:</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">l</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">c</span>
                        <span class="n">dellist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeffindex</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ca</span><span class="p">[</span><span class="n">coeffindex</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="c1"># finally, let&#39;s deal with our delete list; do this by popping, and in reverse index order</span>
        <span class="n">dellist</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">dellist</span><span class="p">:</span>
            <span class="n">ca</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ca</span></div>

<div class="viewcode-block" id="Taylor3D.reduce"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.reduce">[docs]</a>    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reduce the coefficients: eliminate any n that has zero coefficients, collect all of</span>
<span class="sd">        the same values of n together. Done in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reducecoeff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefflist</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collectcoeff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefflist</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Taylor3D.separatecoeff"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.separatecoeff">[docs]</a>    <span class="k">def</span> <span class="nf">separatecoeff</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Projects coefficients through Ylm space, one by one. Assumes they&#39;ve already been</span>
<span class="sd">        reduced and collected first; if not, could lead to duplicated (n,l) entries in list, which</span>
<span class="sd">        is inefficient (should still *evaluate* the same, just with extra steps). After this,</span>
<span class="sd">        each (n,l) term *only* contains terms equal to l, rather than terms &lt;= l.</span>

<span class="sd">        :param a: list((n, lmax, powexpansion), expansion of function in powers</span>
<span class="sd">        :param inplace: modify a in place?</span>
<span class="sd">        :return coefflist: a</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">acoeff</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;coefflist&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">sa</span> <span class="o">=</span> <span class="n">acoeff</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sa</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">acoeff</span><span class="p">]</span>
        <span class="n">dellist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># we&#39;re going to append to sa, so... if you DON&#39;T do this, you get an infinite loop:</span>
        <span class="k">for</span> <span class="n">coeffindex</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sa</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">sa</span><span class="p">)]):</span>
            <span class="c1"># first, project</span>
            <span class="k">for</span> <span class="n">l0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
                <span class="n">cl0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">Lproj</span><span class="p">[</span><span class="n">l0</span><span class="p">][:</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="p">:</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">l</span><span class="p">]],</span>
                                   <span class="n">c</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">l0</span><span class="p">]]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">cl0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">):</span>
                    <span class="n">sa</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">l0</span><span class="p">,</span> <span class="n">cl0</span><span class="p">))</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">Lproj</span><span class="p">[</span><span class="n">l</span><span class="p">][:</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="p">:</span><span class="n">cls</span><span class="o">.</span><span class="n">powlrange</span><span class="p">[</span><span class="n">l</span><span class="p">]],</span> <span class="n">c</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">):</span>
                <span class="n">sa</span><span class="p">[</span><span class="n">coeffindex</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>  <span class="c1"># this *should not be zero* but just in case...</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dellist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeffindex</span><span class="p">)</span>
        <span class="c1"># finally, let&#39;s deal with our delete list; do this by popping, and in reverse index order</span>
        <span class="n">dellist</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">dellist</span><span class="p">:</span>
            <span class="n">sa</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
        <span class="n">sa</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">cls</span><span class="o">.</span><span class="n">__sortkey</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sa</span></div>

<div class="viewcode-block" id="Taylor3D.separate"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.separate">[docs]</a>    <span class="k">def</span> <span class="nf">separate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Separate out the coefficients into (n,l) terms where *only* l contributions appear in each.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separatecoeff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefflist</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Taylor3D.truncatecoeff"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.truncatecoeff">[docs]</a>    <span class="k">def</span> <span class="nf">truncatecoeff</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">Nmax</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the coefficients above a given Nmax; normally returns a new object</span>

<span class="sd">        :param Nmax: maximum coefficient to include</span>
<span class="sd">        :param a: list((n, lmax, powexpansion), expansion of function in powers</span>
<span class="sd">        :param inplace: do it in place?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">acoeff</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;coefflist&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">acoeff</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">acoeff</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Nmax</span><span class="p">:</span>
                    <span class="n">acoeff</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">acoeff</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">acoeff</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">Nmax</span><span class="p">]</span></div>

<div class="viewcode-block" id="Taylor3D.truncate"><a class="viewcode-back" href="../PowerExpansion.html#PowerExpansion.Taylor3D.truncate">[docs]</a>    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Nmax</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the coefficients above a given Nmax; normally returns a new object</span>

<span class="sd">        :param Nmax: maximum coefficient to include</span>
<span class="sd">        :param inplace: do it in place?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">truncatecoeff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefflist</span><span class="p">,</span> <span class="n">Nmax</span><span class="p">,</span> <span class="n">inplace</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Taylor3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">truncatecoeff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefflist</span><span class="p">,</span> <span class="n">Nmax</span><span class="p">))</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Dallas R. Trinkle.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>