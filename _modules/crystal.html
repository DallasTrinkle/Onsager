

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>crystal &mdash; Onsager 1.3 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="Onsager 1.3 documentation" href="../index.html"/>
        <link rel="up" title="Module code" href="index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Onsager
          

          
          </a>

          
            
            
              <div class="version">
                1.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../includeme.html">Onsager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../InputOutput.html">Input and output for Onsager transport calculation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks.html">Example Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">Modules</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Onsager</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>crystal</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for crystal</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Crystal class</span>

<span class="sd">Class to store definition of a crystal, along with some analysis</span>
<span class="sd">1. geometric analysis (nearest neighbor displacements)</span>
<span class="sd">2. space group operations</span>
<span class="sd">3. point group operations for each basis position</span>
<span class="sd">4. Wyckoff position generation (for interstitials)</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Dallas R. Trinkle&#39;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">collections</span><span class="o">,</span> <span class="nn">copy</span><span class="o">,</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="k">import</span> <span class="n">Number</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">gcd</span>
<span class="kn">import</span> <span class="nn">yaml</span>  <span class="c1"># use crystal.yaml to call--may need to change in the future</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>

<span class="c1"># YAML tags:</span>
<span class="c1"># interfaces are either at the bottom, or staticmethods in the corresponding object</span>
<span class="n">NDARRAY_YAMLTAG</span> <span class="o">=</span> <span class="s1">&#39;!numpy.ndarray&#39;</span>
<span class="n">GROUPOP_YAMLTAG</span> <span class="o">=</span> <span class="s1">&#39;!GroupOp&#39;</span>


<div class="viewcode-block" id="gcdlist"><a class="viewcode-back" href="../crystal.html#crystal.gcdlist">[docs]</a><span class="k">def</span> <span class="nf">gcdlist</span><span class="p">(</span><span class="n">lis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the GCD of a list of integers&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">gcd</span><span class="p">,</span> <span class="n">lis</span><span class="p">)</span></div>


<div class="viewcode-block" id="incell"><a class="viewcode-back" href="../crystal.html#crystal.incell">[docs]</a><span class="k">def</span> <span class="nf">incell</span><span class="p">(</span><span class="n">vec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the vector inside the unit cell (in [0,1)**3)</span>

<span class="sd">    :param vec: 3-vector (unit coord)</span>
<span class="sd">    :return: 3-vector</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">vec</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">vec</span> <span class="o">+</span> <span class="mf">1.0e-8</span><span class="p">)</span></div>


<div class="viewcode-block" id="inhalf"><a class="viewcode-back" href="../crystal.html#crystal.inhalf">[docs]</a><span class="k">def</span> <span class="nf">inhalf</span><span class="p">(</span><span class="n">vec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the vector inside the centered cell (in [-0.5,0.5)**3)</span>

<span class="sd">    :param vec: 3-vector (unit coord)</span>
<span class="sd">    :return: 3-vector</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">vec</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">vec</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span></div>


<div class="viewcode-block" id="maptranslation"><a class="viewcode-back" href="../crystal.html#crystal.maptranslation">[docs]</a><span class="k">def</span> <span class="nf">maptranslation</span><span class="p">(</span><span class="n">oldpos</span><span class="p">,</span> <span class="n">newpos</span><span class="p">,</span> <span class="n">oldspins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">newspins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of transformed positions, identify if there&#39;s a translation vector</span>
<span class="sd">    that maps from the current positions to the new position.</span>

<span class="sd">    The mapping specifies the index that the *translated* atom corresponds to in the</span>
<span class="sd">    original position set. If unable to construct a mapping, the mapping return is</span>
<span class="sd">    None; the translation vector will be meaningless.</span>

<span class="sd">    If old/newspins are given then ONLY mappings that maintain spin are considered.</span>
<span class="sd">    This means that a loop is needed to consider possible spin phase factors.</span>

<span class="sd">    :param oldpos: list of list of array[3]</span>
<span class="sd">    :param newpos: list of list of array[3], same layout as oldpos</span>
<span class="sd">    :param oldspins: (optional) list of list of numbers/arrays</span>
<span class="sd">    :param newspins: (optional) list of list of numbers/arrays</span>
<span class="sd">    :return translation: array[3]</span>
<span class="sd">    :return mapping: list of list of indices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># type-checking:</span>
    <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">oldpos</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;oldpos is not a list&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">newpos</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;newpos is not a list&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">oldpos</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">newpos</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2"> do not have the same length&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">oldpos</span><span class="p">,</span> <span class="n">newpos</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">oldpos</span><span class="p">,</span> <span class="n">newpos</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;element of oldpos </span><span class="si">{}</span><span class="s2"> is not a list&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;element of newpos </span><span class="si">{}</span><span class="s2"> is not a list&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2"> do not have the same length&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">oldspins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">newspins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;give both or neither spin arguments&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">oldspins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">oldspins</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;oldspins is not a list&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">newspins</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;newspins is not a list&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">oldspins</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">newspins</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2"> do not have the same length&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">oldspins</span><span class="p">,</span> <span class="n">newspins</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">oldspins</span><span class="p">,</span> <span class="n">newspins</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;element of oldspins </span><span class="si">{}</span><span class="s2"> is not a list&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;element of newspins </span><span class="si">{}</span><span class="s2"> is not a list&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2"> do not have the same length&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">oldspins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">oldspins</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">atomlist</span><span class="p">]</span> <span class="k">for</span> <span class="n">atomlist</span> <span class="ow">in</span> <span class="n">oldpos</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">newspins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">newspins</span> <span class="o">=</span> <span class="n">oldspins</span>

    <span class="c1"># Work with the shortest possible list for identifying translations</span>
    <span class="n">atomindex</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">maxlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">oldpos</span><span class="p">[</span><span class="n">atomindex</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ulist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">oldpos</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ulist</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">maxlen</span><span class="p">:</span>
            <span class="n">maxlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ulist</span><span class="p">)</span>
            <span class="n">atomindex</span> <span class="o">=</span> <span class="n">i</span>
    <span class="n">ru0</span> <span class="o">=</span> <span class="n">newpos</span><span class="p">[</span><span class="n">atomindex</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ub</span> <span class="ow">in</span> <span class="n">oldpos</span><span class="p">[</span><span class="n">atomindex</span><span class="p">]:</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="n">inhalf</span><span class="p">(</span><span class="n">ub</span> <span class="o">-</span> <span class="n">ru0</span><span class="p">)</span>
        <span class="n">foundmap</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># now check against all the others, and construct the mapping</span>
        <span class="n">indexmap</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">atomlist0</span><span class="p">,</span> <span class="n">spinlist0</span><span class="p">,</span> <span class="n">atomlist1</span><span class="p">,</span> <span class="n">spinlist1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">oldpos</span><span class="p">,</span> <span class="n">oldspins</span><span class="p">,</span> <span class="n">newpos</span><span class="p">,</span> <span class="n">newspins</span><span class="p">):</span>
            <span class="c1"># work through the &quot;new&quot; positions</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">foundmap</span><span class="p">:</span> <span class="k">break</span>
            <span class="n">maplist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">rua</span><span class="p">,</span> <span class="n">sp1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">atomlist1</span><span class="p">,</span> <span class="n">spinlist1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">uj</span><span class="p">,</span> <span class="n">sp0</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="n">atomlist0</span><span class="p">,</span> <span class="n">spinlist0</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">sp0</span><span class="p">,</span> <span class="n">sp1</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">threshold</span><span class="p">):</span> <span class="k">continue</span>  <span class="c1"># only allow maps that have same spin</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">inhalf</span><span class="p">(</span><span class="n">uj</span> <span class="o">-</span> <span class="n">rua</span> <span class="o">-</span> <span class="n">trans</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">threshold</span><span class="p">):</span>
                        <span class="n">maplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                        <span class="k">break</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">maplist</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atomlist0</span><span class="p">):</span>
                <span class="n">foundmap</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indexmap</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">maplist</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">foundmap</span><span class="p">:</span> <span class="k">break</span>
    <span class="k">if</span> <span class="n">foundmap</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">trans</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indexmap</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="GroupOp"><a class="viewcode-back" href="../crystal.html#crystal.GroupOp">[docs]</a><span class="k">class</span> <span class="nc">GroupOp</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;GroupOp&#39;</span><span class="p">,</span> <span class="s1">&#39;rot trans cartrot indexmap&#39;</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class corresponding to a group operation. Based on namedtuple, so it is immutable.</span>

<span class="sd">    Intended to be used in combination with Crystal, we have a few operations that</span>
<span class="sd">    can be defined out-of-the-box.</span>

<span class="sd">    :param rot: np.array(3,3) integer idempotent matrix</span>
<span class="sd">    :param trans: np.array(3) real vector</span>
<span class="sd">    :param cartrot: np.array(3,3) real unitary matrix</span>
<span class="sd">    :param indexmap: tuples of tuples, containing the atom mapping</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="GroupOp.incell"><a class="viewcode-back" href="../crystal.html#crystal.GroupOp.incell">[docs]</a>    <span class="k">def</span> <span class="nf">incell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a version of groupop where the translation is in the unit cell&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">GroupOp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot</span><span class="p">,</span> <span class="n">incell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trans</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">cartrot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexmap</span><span class="p">)</span></div>

<div class="viewcode-block" id="GroupOp.inhalf"><a class="viewcode-back" href="../crystal.html#crystal.GroupOp.inhalf">[docs]</a>    <span class="k">def</span> <span class="nf">inhalf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a version of groupop where the translation is in the centered unit cell&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">GroupOp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot</span><span class="p">,</span> <span class="n">inhalf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trans</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">cartrot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexmap</span><span class="p">)</span></div>

<div class="viewcode-block" id="GroupOp.ident"><a class="viewcode-back" href="../crystal.html#crystal.GroupOp.ident">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">ident</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">basis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a group operation corresponding to identity for a given basis&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">rot</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">trans</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">cartrot</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
                   <span class="n">indexmap</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atomlist</span><span class="p">)))</span> <span class="k">for</span> <span class="n">atomlist</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">))</span></div>

<div class="viewcode-block" id="GroupOp.__str__"><a class="viewcode-back" href="../crystal.html#crystal.GroupOp.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Human-readable version of groupop&quot;&quot;&quot;</span>
        <span class="n">str_rep</span> <span class="o">=</span> <span class="s2">&quot;#Rotation (lattice, cartesian):</span><span class="se">\n</span><span class="s2"> </span><span class="si">{}</span><span class="se">\t</span><span class="si">{}</span><span class="se">\n</span><span class="s2"> </span><span class="si">{}</span><span class="se">\t</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rot</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cartrot</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rot</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cartrot</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">str_rep</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="si">{}</span><span class="se">\t</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cartrot</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">str_rep</span> <span class="o">+=</span> <span class="s2">&quot;#Translation: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">#Indexmap:&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trans</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">chemind</span><span class="p">,</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indexmap</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">origind</span><span class="p">,</span> <span class="n">finalind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
                <span class="n">str_rep</span> <span class="o">=</span> <span class="n">str_rep</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  </span><span class="si">{chem}</span><span class="s2">.</span><span class="si">{o}</span><span class="s2"> -&gt; </span><span class="si">{chem}</span><span class="s2">.</span><span class="si">{f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chem</span><span class="o">=</span><span class="n">chemind</span><span class="p">,</span>
                                                                          <span class="n">o</span><span class="o">=</span><span class="n">origind</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">finalind</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">str_rep</span></div>

    <span class="k">def</span> <span class="nf">_asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a proper dict&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;rot&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot</span><span class="p">,</span>
                <span class="s1">&#39;trans&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans</span><span class="p">,</span>
                <span class="s1">&#39;cartrot&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cartrot</span><span class="p">,</span>
                <span class="s1">&#39;indexmap&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexmap</span><span class="p">}</span>

<div class="viewcode-block" id="GroupOp.__eq__"><a class="viewcode-back" href="../crystal.html#crystal.GroupOp.__eq__">[docs]</a>    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test for equality--we use numpy.isclose for comparison, since that&#39;s what we usually care about&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">rot</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trans</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">trans</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cartrot</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">cartrot</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">indexmap</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">indexmap</span></div>

<div class="viewcode-block" id="GroupOp.__ne__"><a class="viewcode-back" href="../crystal.html#crystal.GroupOp.__ne__">[docs]</a>    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inequality == not __eq__&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="GroupOp.__hash__"><a class="viewcode-back" href="../crystal.html#crystal.GroupOp.__hash__">[docs]</a>    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Hash, so that we can make sets of group operations&quot;&quot;&quot;</span>
        <span class="c1">### we are a little conservative, and only use the rotation and indexmap to define the hash. This means</span>
        <span class="c1">### we will get collisions for the same rotation but different unit cell translations. The reason is</span>
        <span class="c1">### that __eq__ uses &quot;isclose&quot; on our translations, and we don&#39;t have a good way to handle</span>
        <span class="c1">### that in a hash function. We lose a little bit on efficiency if we construct a set that</span>
        <span class="c1">### has a whole lot of translation operations, but that&#39;s not usually what we will do.</span>
        <span class="c1"># return hash(self.rot.data.tobytes())</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span> <span class="o">^</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indexmap</span><span class="p">)</span></div>

<div class="viewcode-block" id="GroupOp.__add__"><a class="viewcode-back" href="../crystal.html#crystal.GroupOp.__add__">[docs]</a>    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a translation to our group operation&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Can only add a translation to a group operation&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Can only add a </span><span class="si">{}</span><span class="s1"> dimensional vector&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Can only add a lattice vector translation&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">GroupOp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans</span> <span class="o">+</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cartrot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexmap</span><span class="p">)</span></div>

<div class="viewcode-block" id="GroupOp.__sub__"><a class="viewcode-back" href="../crystal.html#crystal.GroupOp.__sub__">[docs]</a>    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a (negative) translation to our group operation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="o">-</span><span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="GroupOp.__mul__"><a class="viewcode-back" href="../crystal.html#crystal.GroupOp.__mul__">[docs]</a>    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiply two group operations to produce a new group operation&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">GroupOp</span><span class="p">:</span> <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">GroupOp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">rot</span><span class="p">),</span>
                       <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">trans</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans</span><span class="p">,</span>
                       <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cartrot</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">cartrot</span><span class="p">),</span>
                       <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">atomlist0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">atomlist1</span><span class="p">)</span>
                             <span class="k">for</span> <span class="n">atomlist0</span><span class="p">,</span> <span class="n">atomlist1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indexmap</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">indexmap</span><span class="p">)))</span></div>

<div class="viewcode-block" id="GroupOp.__sane__"><a class="viewcode-back" href="../crystal.html#crystal.GroupOp.__sane__">[docs]</a>    <span class="k">def</span> <span class="nf">__sane__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return true if the cartrot and rot are consistent and &#39;sane&#39;&quot;&quot;&quot;</span>
        <span class="n">tr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span>
        <span class="n">det</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot</span><span class="p">)))</span>
        <span class="c1"># consistency:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cartrot</span><span class="o">.</span><span class="n">trace</span><span class="p">()))</span> <span class="o">!=</span> <span class="n">tr</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cartrot</span><span class="p">)))</span> <span class="o">!=</span> <span class="n">det</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># sanity:</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">det</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
        <span class="n">dimshift</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">det</span> <span class="o">*</span> <span class="n">tr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">dimshift</span><span class="p">)</span> <span class="ow">or</span> <span class="n">det</span> <span class="o">*</span> <span class="n">tr</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="n">dimshift</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="GroupOp.inv"><a class="viewcode-back" href="../crystal.html#crystal.GroupOp.inv">[docs]</a>    <span class="k">def</span> <span class="nf">inv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct and return the inverse of the group operation&quot;&quot;&quot;</span>
        <span class="n">inverse</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot</span><span class="p">)))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">GroupOp</span><span class="p">(</span><span class="n">inverse</span><span class="p">,</span>
                       <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inverse</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans</span><span class="p">),</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">cartrot</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                       <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">([(</span><span class="n">y</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atomlist</span><span class="p">)]))</span>
                             <span class="k">for</span> <span class="n">atomlist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexmap</span><span class="p">))</span></div>

<div class="viewcode-block" id="GroupOp.optype"><a class="viewcode-back" href="../crystal.html#crystal.GroupOp.optype">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">optype</span><span class="p">(</span><span class="n">rot</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the type of group operation (single integer):</span>
<span class="sd">        1 = identity</span>
<span class="sd">        2, 3, 4, 6 = n- fold rotation around an axis</span>
<span class="sd">        negative = rotation + mirror operation, perpendicular to axis</span>
<span class="sd">        &quot;special cases&quot;: -1 = mirror, -2 = inversion</span>

<span class="sd">        :param rot: rotation matrix (can be the integer rot)</span>
<span class="sd">        :return type: integer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># dim = rot.shape[0]</span>
        <span class="n">dimindexpos</span><span class="p">,</span> <span class="n">dimindexneg</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">if</span> <span class="n">rot</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">tr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">rot</span><span class="o">.</span><span class="n">trace</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="n">tr</span> <span class="o">+</span> <span class="n">dimindexpos</span><span class="p">]</span>  <span class="c1"># trace determines the rotation type [tr + 1] for 3d</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="n">tr</span> <span class="o">+</span> <span class="n">dimindexneg</span><span class="p">]</span>  <span class="c1"># trace determines the rotation type [tr + 3] fpr 3d</span></div>

<div class="viewcode-block" id="GroupOp.eigen"><a class="viewcode-back" href="../crystal.html#crystal.GroupOp.eigen">[docs]</a>    <span class="k">def</span> <span class="nf">eigen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the type of group operation (single integer) and eigenvectors.</span>
<span class="sd">        1 = identity</span>
<span class="sd">        2, 3, 4, 6 = n- fold rotation around an axis</span>
<span class="sd">        negative = rotation + mirror operation, perpendicular to axis</span>
<span class="sd">        &quot;special cases&quot;: -1 = mirror, -2 = inversion</span>

<span class="sd">        eigenvect[0] = axis of rotation / mirror</span>
<span class="sd">        eigenvect[1], eigenvect[2] = orthonormal vectors to define the plane giving a right-handed</span>
<span class="sd">        coordinate system and where rotation around [0] is positive, and the positive imaginary</span>
<span class="sd">        eigenvector for the complex eigenvalue is [1] + i [2].</span>

<span class="sd">        :return type: integer</span>
<span class="sd">        :return eigenvectors: list of [ev0, ev1, ev2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sane__</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Bad GroupOp:</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">optype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot</span><span class="p">)</span>
        <span class="n">det</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">optype</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">tr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot</span><span class="o">.</span><span class="n">trace</span><span class="p">())</span>
        <span class="c1"># two trivial cases: identity, inversion:</span>
        <span class="k">if</span> <span class="n">optype</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">optype</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">optype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">optype</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">optype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># only interesting case is how to deal with is the mirror plane; find the angle of the mirror</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cartrot</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">cartrot</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cartrot</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">cartrot</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">optype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)]])</span>
        <span class="c1"># otherwise, there&#39;s an axis to find:</span>
        <span class="n">vmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">vsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">det</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">optype</span><span class="p">):</span>
                <span class="n">vsum</span> <span class="o">+=</span> <span class="n">vmat</span>
                <span class="n">vmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cartrot</span><span class="p">,</span> <span class="n">vmat</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)[</span><span class="n">tr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]):</span>  <span class="c1">#</span>
                <span class="n">vsum</span> <span class="o">+=</span> <span class="n">vmat</span>
                <span class="n">vmat</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cartrot</span><span class="p">,</span> <span class="n">vmat</span><span class="p">)</span>
        <span class="c1"># vmat *should* equal identity if we didn&#39;t fail...</span>
        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">vmat</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span> <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span><span class="s1">&#39;eigenvalue analysis fail&#39;</span><span class="p">)</span>
        <span class="n">vsum</span> <span class="o">*=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">n</span>
        <span class="c1"># now the columns of vsum should either be (a) our rotation / mirror axis, or (b) zero</span>
        <span class="n">eig0</span> <span class="o">=</span> <span class="n">vsum</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">magn0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">eig0</span><span class="p">,</span> <span class="n">eig0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">magn0</span> <span class="o">&lt;</span> <span class="mf">1e-2</span><span class="p">:</span>
            <span class="n">eig0</span> <span class="o">=</span> <span class="n">vsum</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">magn0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">eig0</span><span class="p">,</span> <span class="n">eig0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">magn0</span> <span class="o">&lt;</span> <span class="mf">1e-2</span><span class="p">:</span>
                <span class="n">eig0</span> <span class="o">=</span> <span class="n">vsum</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
                <span class="n">magn0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">eig0</span><span class="p">,</span> <span class="n">eig0</span><span class="p">)</span>
        <span class="n">eig0</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">magn0</span><span class="p">)</span>
        <span class="c1"># now, construct the other two directions:</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">eig0</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.75</span><span class="p">:</span>
            <span class="n">eig1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">eig0</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">eig0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eig1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">eig0</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">eig0</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">eig1</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">eig1</span><span class="p">,</span> <span class="n">eig1</span><span class="p">))</span>
        <span class="n">eig2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">eig0</span><span class="p">,</span> <span class="n">eig1</span><span class="p">)</span>
        <span class="c1"># we have a right-handed coordinate system; test that we have a positive rotation around the axis</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">optype</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">eig2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cartrot</span><span class="p">,</span> <span class="n">eig1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">eig0</span> <span class="o">=</span> <span class="o">-</span><span class="n">eig0</span>
                <span class="n">eig2</span> <span class="o">=</span> <span class="o">-</span><span class="n">eig2</span>
        <span class="k">return</span> <span class="n">optype</span><span class="p">,</span> <span class="p">[</span><span class="n">eig0</span><span class="p">,</span> <span class="n">eig1</span><span class="p">,</span> <span class="n">eig2</span><span class="p">]</span></div>

<div class="viewcode-block" id="GroupOp.GroupOp_representer"><a class="viewcode-back" href="../crystal.html#crystal.GroupOp.GroupOp_representer">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">GroupOp_representer</span><span class="p">(</span><span class="n">dumper</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Output a GroupOp&quot;&quot;&quot;</span>
        <span class="c1"># asdict() returns an OrderedDictionary, so pass through dict()</span>
        <span class="c1"># had to rewrite _asdict() for some reason...?</span>
        <span class="k">return</span> <span class="n">dumper</span><span class="o">.</span><span class="n">represent_mapping</span><span class="p">(</span><span class="n">GROUPOP_YAMLTAG</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">_asdict</span><span class="p">())</span></div>

<div class="viewcode-block" id="GroupOp.GroupOp_constructor"><a class="viewcode-back" href="../crystal.html#crystal.GroupOp.GroupOp_constructor">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">GroupOp_constructor</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a GroupOp from YAML&quot;&quot;&quot;</span>
        <span class="c1"># ** turns the dictionary into parameters for GroupOp constructor</span>
        <span class="k">return</span> <span class="n">GroupOp</span><span class="p">(</span><span class="o">**</span><span class="n">loader</span><span class="o">.</span><span class="n">construct_mapping</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="VectorBasis"><a class="viewcode-back" href="../crystal.html#crystal.VectorBasis">[docs]</a><span class="k">def</span> <span class="nf">VectorBasis</span><span class="p">(</span><span class="n">rottype</span><span class="p">,</span> <span class="n">eigenvect</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a vector basis corresponding to the optype and eigenvectors for a GroupOp</span>

<span class="sd">    :param rottype: output from eigen()</span>
<span class="sd">    :param eigenvect: eigenvectors</span>
<span class="sd">    :return dim: dimensionality, 0..3</span>
<span class="sd">    :return vect: vector defining line direction (1) or plane normal (2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 2d first</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eigenvect</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rottype</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>  <span class="c1"># sphere (identity)</span>
        <span class="k">if</span> <span class="n">rottype</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">eigenvect</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># plane (pure mirror)</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>  <span class="c1"># all others are rotation, which leaves nothing unchanged in 2d</span>
    <span class="c1"># edge cases first:</span>
    <span class="k">if</span> <span class="n">rottype</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>  <span class="c1"># sphere (identity)</span>
    <span class="k">if</span> <span class="n">rottype</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>  <span class="c1"># point (inversion)</span>
    <span class="k">if</span> <span class="n">rottype</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">eigenvect</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># plane (pure mirror)</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">eigenvect</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># line (all others--there&#39;s a rotation axis involved</span></div>


<div class="viewcode-block" id="SymmTensorBasis"><a class="viewcode-back" href="../crystal.html#crystal.SymmTensorBasis">[docs]</a><span class="k">def</span> <span class="nf">SymmTensorBasis</span><span class="p">(</span><span class="n">rottype</span><span class="p">,</span> <span class="n">eigenvect</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a symmetric second-rank tensor basis corresponding to the optype and eigenvectors</span>
<span class="sd">    for a GroupOp</span>

<span class="sd">    :param rottype: output from eigen()</span>
<span class="sd">    :param eigenvect: eigenvectors</span>
<span class="sd">    :return tensorbasis: list of 2nd-rank symmetric tensors making up the basis</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">SymmTensor1</span><span class="p">(</span><span class="n">v1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make a normalized, symmetric tensor from two vectors&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SymmTensor2</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make a normalized, symmetric tensor from two vectors&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v2</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SymmTensorCross</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make a normalized, symmetric tensor from two vectors&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v1</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># 2d first:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eigenvect</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rottype</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">rottype</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">SymmTensor1</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">])),</span> <span class="n">SymmTensor1</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">])),</span>
                    <span class="n">SymmTensorCross</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">]))]</span>
        <span class="k">if</span> <span class="n">rottype</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">SymmTensor1</span><span class="p">(</span><span class="n">eigenvect</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">SymmTensor1</span><span class="p">(</span><span class="n">eigenvect</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="c1"># rotations kill everything except the isotropic case:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">SymmTensor2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">]))]</span>

    <span class="k">if</span> <span class="n">rottype</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">rottype</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
        <span class="c1"># identity / inversion: all symmetric tensors</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">SymmTensor1</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])),</span>  <span class="c1"># xx</span>
                <span class="n">SymmTensor1</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])),</span>  <span class="c1"># yy</span>
                <span class="n">SymmTensor1</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])),</span>  <span class="c1"># zz</span>
                <span class="n">SymmTensorCross</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])),</span>  <span class="c1"># yz</span>
                <span class="n">SymmTensorCross</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])),</span>  <span class="c1"># zx</span>
                <span class="n">SymmTensorCross</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]))]</span>  <span class="c1"># xy</span>
    <span class="k">if</span> <span class="n">rottype</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">rottype</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># mirror plane or 2-fold rotation:</span>
        <span class="c1"># 4 symmetric tensors: e0 x e0, e1 x e1, e2 x e2, e1 x e2</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">SymmTensor1</span><span class="p">(</span><span class="n">eigenvect</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="n">SymmTensor1</span><span class="p">(</span><span class="n">eigenvect</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="n">SymmTensor1</span><span class="p">(</span><span class="n">eigenvect</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                <span class="n">SymmTensorCross</span><span class="p">(</span><span class="n">eigenvect</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">eigenvect</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>
    <span class="c1"># else: 3-, 4-, or 6-fold rotation (with or without mirror):</span>
    <span class="c1"># 2 symmetric tensors: e0 x e0, e1 x e1 + e2 x e2</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">SymmTensor1</span><span class="p">(</span><span class="n">eigenvect</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">SymmTensor2</span><span class="p">(</span><span class="n">eigenvect</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">eigenvect</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span></div>


<div class="viewcode-block" id="CombineVectorBasis"><a class="viewcode-back" href="../crystal.html#crystal.CombineVectorBasis">[docs]</a><span class="k">def</span> <span class="nf">CombineVectorBasis</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combines (intersects) two vector spaces into one.</span>

<span class="sd">    :param b1: (dim, vect) -- dimensionality (0..3), vector defining line direction (1) or plane normal (2)</span>
<span class="sd">    :param b2: (dim, vect)</span>
<span class="sd">    :return dim: dimensionality, 0..3</span>
<span class="sd">    :return vect: vector defining line direction (1) or plane normal (2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># edge cases first</span>
    <span class="k">if</span> <span class="n">b1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">b1</span>  <span class="c1"># point with anything</span>
    <span class="k">if</span> <span class="n">b2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">b2</span>
    <span class="c1"># 2d first:</span>
    <span class="k">if</span> <span class="n">b1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">b1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="n">b2</span>
        <span class="k">if</span> <span class="n">b2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="n">b1</span>
        <span class="c1"># all that remains now is b1[0] == b2[0] == 1 (two lines)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b2</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="mf">1e-8</span><span class="p">):</span>  <span class="c1"># parallel vectors</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># two parallel lines</span>
            <span class="k">return</span> <span class="n">b1</span>

    <span class="k">if</span> <span class="n">b1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span> <span class="k">return</span> <span class="n">b2</span>  <span class="c1"># sphere with anything</span>
    <span class="k">if</span> <span class="n">b2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span> <span class="k">return</span> <span class="n">b1</span>
    <span class="k">if</span> <span class="n">b1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">b2</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b2</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="mf">1e-8</span><span class="p">):</span>  <span class="c1"># parallel vectors</span>
            <span class="k">return</span> <span class="n">b1</span>  <span class="c1"># equal bases</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># vectors not equal...</span>
            <span class="k">if</span> <span class="n">b1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># for a line, that&#39;s death:</span>
                <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># for a plane, need the mutual line:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">b1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">v</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">)))</span>
    <span class="c1"># finally: one is a plane, other is a line:</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b2</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="mf">1e-8</span><span class="p">:</span>  <span class="c1"># if the vectors are not perpendicular, death:</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># return whichever is a line:</span>
        <span class="k">if</span> <span class="n">b1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b2</span></div>


<div class="viewcode-block" id="CombineTensorBasis"><a class="viewcode-back" href="../crystal.html#crystal.CombineTensorBasis">[docs]</a><span class="k">def</span> <span class="nf">CombineTensorBasis</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combines (intersects) two tensor spaces into one; uses SVD to compute null space.</span>

<span class="sd">    :param b1: list of tensors</span>
<span class="sd">    :param b2: list of tensors</span>
<span class="sd">    :return tensorbasis: list of 2nd-rank symmetric tensors making up the basis</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># edge cases first (empty or full basis)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">b1</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">b2</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span> <span class="o">==</span> <span class="n">b1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">:</span> <span class="k">return</span> <span class="n">b2</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b2</span><span class="p">)</span> <span class="o">==</span> <span class="n">b2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">:</span> <span class="k">return</span> <span class="n">b1</span>
    <span class="c1"># make the combined matrix with the two column spaces D = [b1 b2], then</span>
    <span class="c1"># find its nullspace</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">b1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">b2</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="c1"># this is sneaky: the first is to pull out the size of the nullspace, the second slices</span>
    <span class="c1"># the part of b1 that we have to deal with, but then we have to *renormalize* these vectors</span>
    <span class="c1"># by multiplying by sqrt(2), since the slice in each vector space would be normalized.</span>
    <span class="n">nullspace</span> <span class="o">=</span> <span class="n">vh</span><span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;=</span> <span class="mf">1e-8</span><span class="p">):,</span> <span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">b1</span><span class="p">)]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># now to reconstruct our normalized basis from those</span>
    <span class="c1"># list comprehension to run over the elements of our nullspace, and the</span>
    <span class="c1"># generator in the sum to construct the basis</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">b1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">alpha</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nullspace</span><span class="p">]</span></div>


<div class="viewcode-block" id="ProjectTensorBasis"><a class="viewcode-back" href="../crystal.html#crystal.ProjectTensorBasis">[docs]</a><span class="k">def</span> <span class="nf">ProjectTensorBasis</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">basis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a tensor, project it onto the basis.</span>

<span class="sd">    :param tensor: tensor</span>
<span class="sd">    :param basis: list consisting of an orthonormal basis</span>
<span class="sd">    :return tensor: tensor, projected</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tensor</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Tensor and basis not compatible&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tensor</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">)</span></div>


<div class="viewcode-block" id="Voigtstrain"><a class="viewcode-back" href="../crystal.html#crystal.Voigtstrain">[docs]</a><span class="k">def</span> <span class="nf">Voigtstrain</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">e3</span><span class="p">,</span> <span class="n">e4</span><span class="p">,</span> <span class="n">e5</span><span class="p">,</span> <span class="n">e6</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a symmetric strain tensor from the Voigt reduced strain values.</span>

<span class="sd">    :param e1: xx</span>
<span class="sd">    :param e2: yy</span>
<span class="sd">    :param e3: zz</span>
<span class="sd">    :param e4: yz + zx</span>
<span class="sd">    :param e5: zx + xz</span>
<span class="sd">    :param e6: xy + yx</span>
<span class="sd">    :return strain: symmetric strain tensor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">e1</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">e6</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">e5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">e6</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">e4</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">e5</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">e4</span><span class="p">,</span> <span class="n">e3</span><span class="p">]])</span></div>


<div class="viewcode-block" id="isotropicFourthRank"><a class="viewcode-back" href="../crystal.html#crystal.isotropicFourthRank">[docs]</a><span class="k">def</span> <span class="nf">isotropicFourthRank</span><span class="p">(</span><span class="n">average</span><span class="p">,</span> <span class="n">shear</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a symmetrized, isotropic fourth-rank tensor based on an average value and &quot;shear&quot; value</span>

<span class="sd">    :param average: averaged value = (F11+2F12)/3</span>
<span class="sd">    :param shear: shear value = F44 = (F11-F12)/2</span>
<span class="sd">    :return F[a,b,c,d]: isotropic fourth-rank tensor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">F11</span><span class="p">,</span> <span class="n">F12</span><span class="p">,</span> <span class="n">F44</span> <span class="o">=</span> <span class="n">average</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">shear</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="n">average</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">shear</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="n">shear</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">F</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">F11</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="n">a</span><span class="p">:</span>
                <span class="n">F</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">F12</span>
                <span class="n">F</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">F44</span>
                <span class="n">F</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">F44</span>
    <span class="k">return</span> <span class="n">F</span></div>


<div class="viewcode-block" id="FourthRankIsotropic"><a class="viewcode-back" href="../crystal.html#crystal.FourthRankIsotropic">[docs]</a><span class="k">def</span> <span class="nf">FourthRankIsotropic</span><span class="p">(</span><span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the average and shear values from orientational averaging of a symmetric fourth-rank</span>
<span class="sd">    tensor.</span>

<span class="sd">    :param F[a,b,c,d]: symmetric fourth-rank tensor (F[abcd]=F[abcd]=F[bacd]=F[cdab])</span>
<span class="sd">    :return average: average value = (F11+2F12)/3, orientationally averaged</span>
<span class="sd">    :return shear: shear value = F44, orientationally averaged</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">average</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">/</span><span class="mi">9</span>
    <span class="n">shear</span> <span class="o">=</span> <span class="p">((</span><span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">F</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="mi">3</span> <span class="o">+</span>
             <span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="mi">5</span>
    <span class="k">return</span> <span class="n">average</span><span class="p">,</span> <span class="n">shear</span></div>


<span class="c1"># TODO: Add the ability to explicitly specify &quot;metastable&quot; states</span>
<span class="c1"># that should be considered the same chemistry, but not subject to reduction</span>
<div class="viewcode-block" id="Crystal"><a class="viewcode-back" href="../crystal.html#crystal.Crystal">[docs]</a><span class="k">class</span> <span class="nc">Crystal</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class that defines a crystal, as well as the symmetry analysis that goes along with it.</span>
<span class="sd">    Now includes optional spins. These can be vectors or &quot;scalar&quot; spins, for which we need</span>
<span class="sd">    to consider a phase factor. In general, they can be complex. Ideally, they should have</span>
<span class="sd">    magnitude either 0 or 1.</span>

<span class="sd">    Specified by a lattice (3 vectors), a basis (list of lists of positions in direct coordinates).</span>
<span class="sd">    Can also name the elements (chemistry), and specify spin degrees of freedom.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Crystal.__init__"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">basis</span><span class="p">,</span> <span class="n">chemistry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">NOSYM</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">noreduce</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialization; starts off with the lattice vector definition and the</span>
<span class="sd">        basis vectors. While it does not explicitly store the specific chemical</span>
<span class="sd">        elements involved, it does store that there are different elements.</span>

<span class="sd">        :param lattice: array[3,3] or list of array[3] (or 2 if 2-dimensional)</span>
<span class="sd">            lattice vectors; if [3,3] array, then the vectors need to be in *column* format</span>
<span class="sd">            so that the first lattice vector is lattice[:,0]</span>
<span class="sd">        :param basis: list of array[3] or list of list of array[3] (or 2 if 2-dimensional)</span>
<span class="sd">            crystalline basis vectors, in unit cell coordinates. If a list of lists, then</span>
<span class="sd">            there are multiple chemical elements, with each list corresponding to a unique</span>
<span class="sd">            element</span>
<span class="sd">        :param chemistry: (optional) list of names of chemical elements</span>
<span class="sd">        :param spins: (optional) list of numbers (complex) / vectors or list of list of same</span>
<span class="sd">            spins for individual atoms; if not None, needs to match the basis. Can either be</span>
<span class="sd">            scalars or vectors, corresponding to collinear or non-collinear magnetism</span>
<span class="sd">        :param NOSYM: turn off all symmetry finding (except identity)</span>
<span class="sd">        :param noreduce: do not attempt to reduce the atomic basis</span>
<span class="sd">        :param threshold: threshold for symmetry equivalence (stored in the class)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Do some basic type checking and &quot;formatting&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">lattice</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lattice</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lattice</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;lattice is a list, but does not contain 2 or 3 members&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lattice</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">lattice</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lattice</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;lattice is not a recognized type&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;lattice contains vectors that are not 2 or 3 dimensional&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># dimensionality of our lattice</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;basis needs to be a list or list of lists&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">basis</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> in </span><span class="si">{}</span><span class="s2"> is not an array&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">basis</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="p">[[</span><span class="n">incell</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> in basis is not a list&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">elem</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> in </span><span class="si">{}</span><span class="s2"> is not an array&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">elem</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="p">[[</span><span class="n">incell</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">atombasis</span><span class="p">]</span> <span class="k">for</span> <span class="n">atombasis</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">spins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">spins</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;spins needs to be a list or list of lists&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">spins</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spins</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">spins</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spins</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">spins</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spins</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">noreduce</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span>  <span class="c1"># clean up basis as needed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minlattice</span><span class="p">()</span>  <span class="c1"># clean up lattice vectors as needed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invlatt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span>
        <span class="c1"># this lets us, in a flat list, enumerate over indices of atoms as needed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atomindices</span> <span class="o">=</span> <span class="p">[(</span><span class="n">atomtype</span><span class="p">,</span> <span class="n">atomindex</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">atomtype</span><span class="p">,</span> <span class="n">atomlist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">atomindex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atomlist</span><span class="p">))]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomindices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nchem</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">chemistry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chemistry</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nchem</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chemistry</span> <span class="o">=</span> <span class="n">chemistry</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calcmetric</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reciplatt</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">invlatt</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BZvol</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reciplatt</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BZG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genBZG</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">()</span>  <span class="c1"># should do before gengroup so that inversion is centered at origin</span>
        <span class="k">if</span> <span class="n">NOSYM</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([</span><span class="n">GroupOp</span><span class="o">.</span><span class="n">ident</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gengroup</span><span class="p">()</span>  <span class="c1"># do before genpoint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pointG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genpoint</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Wyckoff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genWyckoffsets</span><span class="p">()</span></div>

<div class="viewcode-block" id="Crystal.__repr__"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation of crystal (lattice + basis)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;Crystal(&#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span> <span class="o">+</span> \
               <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, spins=&#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spins</span><span class="p">)</span> <span class="o">+</span> \
               <span class="s1">&#39;, chemistry=&#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chemistry</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span></div>

<div class="viewcode-block" id="Crystal.__str__"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Human-readable version of crystal (lattice + basis)&quot;&quot;&quot;</span>
        <span class="n">str_rep</span> <span class="o">=</span> <span class="s2">&quot;#Lattice:</span><span class="se">\n</span><span class="s2">  a1 = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">  a2 = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">str_rep</span> <span class="o">+=</span> <span class="s2">&quot;  a3 = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">str_rep</span> <span class="o">+=</span> <span class="s2">&quot;#Basis:&quot;</span>
        <span class="k">for</span> <span class="n">chemind</span><span class="p">,</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">atomind</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39; sp=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spins</span><span class="p">[</span><span class="n">chemind</span><span class="p">][</span><span class="n">atomind</span><span class="p">])</span>
                <span class="n">str_rep</span> <span class="o">=</span> <span class="n">str_rep</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  (</span><span class="si">{}</span><span class="s2">) </span><span class="si">{}</span><span class="s2">.</span><span class="si">{}</span><span class="s2"> = </span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chemistry</span><span class="p">[</span><span class="n">chemind</span><span class="p">],</span>
                                                                   <span class="n">chemind</span><span class="p">,</span> <span class="n">atomind</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">str_rep</span></div>

<div class="viewcode-block" id="Crystal.fromdict"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.fromdict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromdict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">yamldict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a Crystal object from a *very simple* YAML-created dictionary</span>

<span class="sd">        :param yamldict: dictionary; must contain &#39;lattice&#39; (using *row* vectors!) and &#39;basis&#39;;</span>
<span class="sd">            can contain optional &#39;lattice_constant&#39;</span>
<span class="sd">        :return Crystal(lattice.T, basis): new crystal object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;lattice&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">yamldict</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> does not contain &quot;lattice&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">yamldict</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;basis&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">yamldict</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> does not contain &quot;basis&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">yamldict</span><span class="p">))</span>
        <span class="n">lattice_constant</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="k">if</span> <span class="s1">&#39;lattice_constant&#39;</span> <span class="ow">in</span> <span class="n">yamldict</span><span class="p">:</span> <span class="n">lattice_constant</span> <span class="o">=</span> <span class="n">yamldict</span><span class="p">[</span><span class="s1">&#39;lattice_constant&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">((</span><span class="n">lattice_constant</span> <span class="o">*</span> <span class="n">yamldict</span><span class="p">[</span><span class="s1">&#39;lattice&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">yamldict</span><span class="p">[</span><span class="s1">&#39;basis&#39;</span><span class="p">],</span>
                   <span class="n">chemistry</span><span class="o">=</span><span class="p">(</span><span class="n">yamldict</span><span class="p">[</span><span class="s1">&#39;chemistry&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;chemistry&#39;</span> <span class="ow">in</span> <span class="n">yamldict</span> <span class="k">else</span> <span class="kc">None</span><span class="p">),</span>
                   <span class="n">spins</span><span class="o">=</span><span class="p">(</span><span class="n">yamldict</span><span class="p">[</span><span class="s1">&#39;spins&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;spins&#39;</span> <span class="ow">in</span> <span class="n">yamldict</span> <span class="k">else</span> <span class="kc">None</span><span class="p">),</span>
                   <span class="n">threshold</span><span class="o">=</span><span class="p">(</span><span class="n">yamldict</span><span class="p">[</span><span class="s1">&#39;threshold&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;threshold&#39;</span> <span class="ow">in</span> <span class="n">yamldict</span> <span class="k">else</span> <span class="mf">1e-8</span><span class="p">))</span></div>

<div class="viewcode-block" id="Crystal.simpleYAML"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.simpleYAML">[docs]</a>    <span class="k">def</span> <span class="nf">simpleYAML</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a0</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a simplified YAML dump, in case we don&#39;t want to output the full symmetry analysis</span>

<span class="sd">        :return YAML: string dump</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">yaml</span><span class="o">.</span><span class="n">dump</span><span class="p">({</span><span class="s1">&#39;lattice_constant&#39;</span><span class="p">:</span> <span class="n">a0</span><span class="p">,</span>
                          <span class="s1">&#39;lattice&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">a0</span><span class="p">,</span>
                          <span class="s1">&#39;basis&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">,</span>
                          <span class="s1">&#39;spins&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">spins</span><span class="p">,</span>
                          <span class="s1">&#39;chemistry&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemistry</span><span class="p">,</span>
                          <span class="s1">&#39;threshold&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">})</span></div>

<div class="viewcode-block" id="Crystal.chemindex"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.chemindex">[docs]</a>    <span class="k">def</span> <span class="nf">chemindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chemistry</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return index corresponding to chemistry; None if not present.</span>

<span class="sd">        :param chemistry: value to check</span>
<span class="sd">        :return index: corresponding to chemistry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemistry</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">chemistry</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

    <span class="c1"># a few &quot;convenient&quot; lattices</span>
<div class="viewcode-block" id="Crystal.FCC"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.FCC">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">FCC</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">chemistry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a face-centered cubic crystal with lattice constant a0</span>

<span class="sd">        :param a0: lattice constant</span>
<span class="sd">        :return FCC crystal:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">chemistry</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chemistry</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">chem</span> <span class="o">=</span> <span class="n">chemistry</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chem</span> <span class="o">=</span> <span class="p">[</span><span class="n">chemistry</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span> <span class="o">*</span> <span class="n">a0</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)],</span> <span class="n">chem</span><span class="p">)</span></div>

<div class="viewcode-block" id="Crystal.BCC"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.BCC">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">BCC</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">chemistry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a body-centered cubic crystal with lattice constant a0</span>

<span class="sd">        :param a0: lattice constant</span>
<span class="sd">        :return BCC crystal:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">chemistry</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chemistry</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">chem</span> <span class="o">=</span> <span class="n">chemistry</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chem</span> <span class="o">=</span> <span class="p">[</span><span class="n">chemistry</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">]])</span> <span class="o">*</span> <span class="n">a0</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)],</span> <span class="n">chem</span><span class="p">)</span></div>

<div class="viewcode-block" id="Crystal.HCP"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.HCP">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">HCP</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">c_a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">8.</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">),</span> <span class="n">chemistry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a hexagonal closed packed crystal with lattice constant a0, c/a ratio c_a</span>

<span class="sd">        :param a0: lattice constant</span>
<span class="sd">        :param c_a: (optional) c/a ratio, default=ideal :math:`\sqrt{8/3}`</span>
<span class="sd">        :return HCP crystal:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">chemistry</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chemistry</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">chem</span> <span class="o">=</span> <span class="n">chemistry</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chem</span> <span class="o">=</span> <span class="p">[</span><span class="n">chemistry</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
                             <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.75</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.75</span><span class="p">),</span> <span class="mf">0.</span><span class="p">],</span>
                             <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">c_a</span><span class="p">]])</span> <span class="o">*</span> <span class="n">a0</span><span class="p">,</span>
                   <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">2.</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">]),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">3.</span> <span class="o">/</span> <span class="mi">4</span><span class="p">])],</span> <span class="n">chem</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__iszero__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__isclose__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span>

<div class="viewcode-block" id="Crystal.center"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.center">[docs]</a>    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Center the atoms in the cell if there is an inversion operation present.&quot;&quot;&quot;</span>
        <span class="c1"># trivial case:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)]]</span>
            <span class="k">return</span>
        <span class="c1"># else, invert positions!</span>
        <span class="n">trans</span><span class="p">,</span> <span class="n">indexmap</span> <span class="o">=</span> <span class="n">maptranslation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">,</span> <span class="p">[[</span><span class="o">-</span><span class="n">u</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">atomlist</span><span class="p">]</span> <span class="k">for</span> <span class="n">atomlist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">indexmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># translate by -1/2 * trans for inversion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="p">[[</span><span class="n">incell</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">trans</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">atomlist</span><span class="p">]</span> <span class="k">for</span> <span class="n">atomlist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">]</span>
        <span class="c1"># now, check for &quot;aesthetics&quot; of our basis choice</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">atomlist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">atomlist</span><span class="p">]):</span>
                <span class="n">shift</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">atomlist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">atomlist</span><span class="p">]):</span>
                <span class="n">shift</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
            <span class="k">elif</span> <span class="nb">sum</span><span class="p">([</span><span class="mi">1</span> <span class="k">for</span> <span class="n">atomlist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">atomlist</span> <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.25</span> <span class="ow">or</span> <span class="n">u</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.75</span><span class="p">])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">shift</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="p">[[</span><span class="n">incell</span><span class="p">(</span><span class="n">atom</span> <span class="o">+</span> <span class="n">shift</span><span class="p">)</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atomlist</span><span class="p">]</span> <span class="k">for</span> <span class="n">atomlist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">]</span></div>

<div class="viewcode-block" id="Crystal.reduce"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.reduce">[docs]</a>    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reduces the lattice and basis, if needed. Works (tail) recursively.</span>

<span class="sd">        :param threshold: threshold for symmetry comparison; default = self.threshold</span>

<span class="sd">        Algorithm is slightly complicated: we attempt to identify if there is a internal</span>
<span class="sd">        translation symmetry in the crystal (called `t`) that applies to all sites. Once identified,</span>
<span class="sd">        we transform the lattice vectors and basis into the &quot;reduced&quot; form of the cell. We use</span>
<span class="sd">        tail recursion to continue until no further reduction is possible. Will usually require</span>
<span class="sd">        some &quot;polishing&quot; on the unit cell after the fact.</span>

<span class="sd">        We try to do this efficiently: we check the GCD of the site counts (called `M`); if it&#39;s 1,</span>
<span class="sd">        we kick out. We check translations against the smallest site set first.</span>

<span class="sd">        We try to do this carefully: We make sure that our translation can be expressed rationally</span>
<span class="sd">        with `M` as the denominator; this helps protect against roundoff error. When we reduce the</span>
<span class="sd">        atomic basis, we *average* the values that match. Finally, as we reduce, we also change the</span>
<span class="sd">        `self.threshold` value accordingly so that recursion uses the same &quot;effective&quot; threshold.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>
        <span class="n">sitecount</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">ulist</span><span class="p">)</span> <span class="k">for</span> <span class="n">ulist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">]</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">gcdlist</span><span class="p">(</span><span class="n">sitecount</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">M</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">atomindex</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sitecount</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="n">sitecount</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">)</span> <span class="c1"># index of shortest sitecount</span>
        <span class="c1"># if we don&#39;t have spins, just make a big list of lists of 0, otherwise there&#39;s too many &quot;if spins None...&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spins</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">atomlist</span><span class="p">]</span> <span class="k">for</span> <span class="n">atomlist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spins</span>
        <span class="c1"># We need to first check against reducibility of atomic positions: try out non-trivial displacements</span>
        <span class="n">initpos</span><span class="p">,</span> <span class="n">initsp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">atomindex</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">spins</span><span class="p">[</span><span class="n">atomindex</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">newpos</span><span class="p">,</span> <span class="n">newsp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">atomindex</span><span class="p">],</span> <span class="n">spins</span><span class="p">[</span><span class="n">atomindex</span><span class="p">]):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">newpos</span> <span class="o">-</span> <span class="n">initpos</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__isclose__</span><span class="p">(</span><span class="n">initsp</span><span class="p">,</span> <span class="n">newsp</span><span class="p">):</span> <span class="k">continue</span>
            <span class="c1"># reconstruct `t` as a rational vector; if fail, kick out</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__isclose__</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">T</span><span class="o">/</span><span class="n">M</span><span class="p">):</span> <span class="k">continue</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">T</span><span class="o">/</span><span class="n">M</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">atomlist</span><span class="p">,</span> <span class="n">spinlist</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">,</span> <span class="n">spins</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">atomlist</span><span class="p">,</span> <span class="n">spinlist</span><span class="p">):</span>
                    <span class="c1"># edited to only check against translations with the same spin:</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__iszero__</span><span class="p">(</span><span class="n">inhalf</span><span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">t</span> <span class="o">-</span> <span class="n">v</span><span class="p">))</span>
                               <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">vs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">atomlist</span><span class="p">,</span> <span class="n">spinlist</span><span class="p">)</span>
                               <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__isclose__</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">vs</span><span class="p">)]):</span>
                        <span class="n">trans</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
            <span class="k">if</span> <span class="n">trans</span><span class="p">:</span> <span class="k">break</span>
        <span class="c1"># end the recursion here:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">trans</span><span class="p">:</span> <span class="k">return</span>
        <span class="c1"># reduce that lattice and basis</span>
        <span class="c1"># 1. determine what the new lattice needs to look like.</span>
        <span class="c1"># m = index of smallest non-zero value in T:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
        <span class="c1"># i, j = other indices, ordered so that T, e_i, e_j == right-handed coordinate system</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">T</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span>
            <span class="c1"># new lattice: A0 = [a]*t, A1 = a_i, A2 = a_j</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 2-d</span>
            <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span>
            <span class="c1"># new lattice: A0 = [a]*t, A1 = a_i</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">reduction</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">/</span><span class="n">M</span><span class="p">)</span>
        <span class="n">mult</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">M</span><span class="o">/</span><span class="n">T</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">T</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">T</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">/</span><span class="n">T</span><span class="p">[</span><span class="n">m</span><span class="p">]])</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">M</span><span class="o">/</span><span class="n">T</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">T</span><span class="p">[</span><span class="n">m</span><span class="p">]])</span>

        <span class="c1"># 2. update the basis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">*=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">mult</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># need to update *before* doing matching below:</span>
        <span class="n">newbasis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">newspins</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">atomlist</span><span class="p">,</span> <span class="n">spinlist</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">,</span> <span class="n">spins</span><span class="p">):</span>
            <span class="n">newatomlist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">avedisplist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">newspinlist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">atomlist</span><span class="p">,</span> <span class="n">spinlist</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">incell</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">u</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">*</span><span class="n">mult</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                     <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">*</span><span class="n">mult</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                     <span class="n">u</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">*</span><span class="n">mult</span><span class="p">[</span><span class="mi">2</span><span class="p">]]))</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> \
                    <span class="n">incell</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">u</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">*</span><span class="n">mult</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                     <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">*</span><span class="n">mult</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">newatomlist</span><span class="p">:</span>
                    <span class="c1"># dv = relative displacement of site</span>
                    <span class="n">dv</span> <span class="o">=</span> <span class="n">inhalf</span><span class="p">(</span><span class="n">v</span><span class="o">-</span><span class="n">v1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__iszero__</span><span class="p">(</span><span class="n">dv</span><span class="p">):</span> <span class="k">break</span>
                    <span class="n">ind</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">ind</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">newatomlist</span><span class="p">):</span>
                    <span class="c1"># matched position: accumulate displacement and spin</span>
                    <span class="n">avedisplist</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dv</span>
                    <span class="n">newspinlist</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">+=</span> <span class="n">s</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># unmatched position!</span>
                    <span class="n">newatomlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">avedisplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
                    <span class="n">newspinlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newatomlist</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">M</span><span class="o">//</span><span class="nb">abs</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">m</span><span class="p">]))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atomlist</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span><span class="s1">&#39;Reduction did not produce correct reduced basis: </span><span class="si">{}</span><span class="s1">*</span><span class="si">{}</span><span class="s1"> != </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">newatomlist</span><span class="p">),</span> <span class="n">M</span><span class="o">//</span><span class="nb">abs</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">m</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">atomlist</span><span class="p">)))</span>
            <span class="n">newbasis</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">incell</span><span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="n">reduction</span><span class="o">*</span><span class="n">dv</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">dv</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">newatomlist</span><span class="p">,</span> <span class="n">avedisplist</span><span class="p">)])</span>
            <span class="n">newspins</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">reduction</span><span class="o">*</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">newspinlist</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="n">newbasis</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">spins</span> <span class="o">=</span> <span class="n">newspins</span>
        <span class="c1"># 3. tail recursion:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span></div>

<div class="viewcode-block" id="Crystal.remapbasis"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.remapbasis">[docs]</a>    <span class="k">def</span> <span class="nf">remapbasis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">supercell</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes the basis definition, and using a supercell definition, returns a new basis</span>

<span class="sd">        :param supercell: integer array[3,3]</span>
<span class="sd">        :return atomic basis: list of list of positions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">invsuper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">supercell</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[[</span><span class="n">incell</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">invsuper</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">atomlist</span><span class="p">]</span> <span class="k">for</span> <span class="n">atomlist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">]</span></div>

<div class="viewcode-block" id="Crystal.minlattice"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.minlattice">[docs]</a>    <span class="k">def</span> <span class="nf">minlattice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Try to find the optimal lattice vector definition for a crystal. Our definition of optimal</span>
<span class="sd">        is (a) length of each lattice vector is minimal; (b) the vectors are ordered from</span>
<span class="sd">        shortest to longest; (c) the vectors have minimal dot product; (d) the basis is right-handed.</span>

<span class="sd">        Works recursively, and in-place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">magnlist</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
        <span class="nb">super</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">magn</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">magnlist</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># check that we have a right-handed lattice</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="nb">super</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="nb">super</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="nb">super</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="nb">super</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remapbasis</span><span class="p">(</span><span class="nb">super</span><span class="p">)</span>

        <span class="nb">super</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">modified</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># check the possible vector reductions (edited to handle 2 and 3 dimensions)</span>
        <span class="n">asq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">asq</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">asq</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">u</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="n">modified</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">asq</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">asq</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">u</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">super</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                <span class="n">modified</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">asq</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">asq</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">u</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">super</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                    <span class="n">modified</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">modified</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="nb">super</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remapbasis</span><span class="p">(</span><span class="nb">super</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minlattice</span><span class="p">()</span></div>

<div class="viewcode-block" id="Crystal.calcmetric"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.calcmetric">[docs]</a>    <span class="k">def</span> <span class="nf">calcmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the volume of the cell and the metric tensor</span>

<span class="sd">        :return volume: cell volume</span>
<span class="sd">        :return metric tensor: 3x3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">))),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span></div>

<div class="viewcode-block" id="Crystal.inBZ"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.inBZ">[docs]</a>    <span class="k">def</span> <span class="nf">inBZ</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="n">BZG</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tells us if vec is inside our set of defining points.</span>

<span class="sd">        :param vec: array [3], vector to be tested</span>
<span class="sd">        :param BGZ: array [:,3], optional (default = self.BZG), array of vectors that define the BZ</span>
<span class="sd">        :param threshold: double, optional, threshold to use for &quot;equality&quot;</span>
<span class="sd">        :return inBZ: False if outside the BZ, True otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">BZG</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">BZG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BZG</span>
        <span class="c1"># checks that vec.G &lt; G^2 for all G (and throws out the option that vec == G, in case threshold == 0)</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">G</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">G</span><span class="p">)</span> <span class="o">+</span> <span class="n">threshold</span><span class="p">)</span> <span class="k">for</span> <span class="n">G</span> <span class="ow">in</span> <span class="n">BZG</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">vec</span> <span class="o">==</span> <span class="n">G</span><span class="p">))</span></div>

<div class="viewcode-block" id="Crystal.genBZG"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.genBZG">[docs]</a>    <span class="k">def</span> <span class="nf">genBZG</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates the reciprocal lattice G points that define the Brillouin zone.</span>

<span class="sd">        :return Garray: array of G vectors that define the BZ, in Cartesian coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Start with a list of possible vectors; add those that define the BZ...</span>
        <span class="n">BZG</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">nv</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">repeat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nv</span><span class="p">):</span> <span class="k">continue</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">nv</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inBZ</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">BZG</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span> <span class="n">BZG</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reciplatt</span><span class="p">,</span> <span class="n">nv</span><span class="p">))</span>
        <span class="c1"># ... and use a list comprehension to only keep those that still remain</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">vec</span> <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="n">BZG</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inBZ</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">BZG</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">)])</span></div>

<div class="viewcode-block" id="Crystal.gengroup"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.gengroup">[docs]</a>    <span class="k">def</span> <span class="nf">gengroup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate all of the space group operations. Now handles spins! Doesn&#39;t store</span>
<span class="sd">        spin phase factors for each group operation, though.</span>

<span class="sd">        :return Gset: frozenset of group operations</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">rootsofunity</span><span class="p">(</span><span class="n">optype</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Return an iterable of roots of unity to try for GroupOp type optype&quot;&quot;&quot;</span>
            <span class="c1"># always include negation</span>
            <span class="n">rot2</span><span class="p">,</span> <span class="n">rot4</span><span class="p">,</span> <span class="n">rot6</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span><span class="n">j</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">rot2</span><span class="p">,</span> <span class="n">rot2</span><span class="p">,</span> <span class="n">rot6</span><span class="p">,</span> <span class="n">rot4</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">rot6</span><span class="p">)[</span><span class="nb">abs</span><span class="p">(</span><span class="n">optype</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># (+-1, +-2, +-3, +-4, .., +-6)</span>

        <span class="k">def</span> <span class="nf">quickabsdet</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span> <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span> <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
                                            <span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                                            <span class="o">+</span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>

        <span class="n">groupops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">supercellvect</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nv</span><span class="p">)</span> <span class="k">for</span> <span class="n">nv</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
                         <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nv</span><span class="p">)]</span>
        <span class="n">matchvect</span> <span class="o">=</span> <span class="p">[[</span><span class="n">u</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">supercellvect</span>
                      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__isclose__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">,</span> <span class="n">u</span><span class="p">)),</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">])]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)]</span>
        <span class="c1"># if we don&#39;t have spins, just make a big list of lists of 0, otherwise there&#39;s too many &quot;if spins None...&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spins</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">atomlist</span><span class="p">]</span> <span class="k">for</span> <span class="n">atomlist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spins</span>
        <span class="k">for</span> <span class="n">supertuple</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">matchvect</span><span class="p">):</span>
            <span class="n">supercell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">supertuple</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">if</span> <span class="n">quickabsdet</span><span class="p">(</span><span class="n">supercell</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__isclose__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">supercell</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">,</span> <span class="n">supercell</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">):</span>
                <span class="c1"># possible operation--need to check the atomic positions with spin phase factors</span>
                <span class="n">optype</span> <span class="o">=</span> <span class="n">GroupOp</span><span class="o">.</span><span class="n">optype</span><span class="p">(</span><span class="n">supercell</span><span class="p">)</span>
                <span class="n">cartrot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">supercell</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">invlatt</span><span class="p">))</span>
                <span class="n">detrot</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">optype</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
                <span class="c1"># apply cartesian rotation to spins... if they&#39;re vectors; else, do nothing</span>
                <span class="n">rotspins</span> <span class="o">=</span> <span class="p">[[</span><span class="n">detrot</span> <span class="o">*</span> <span class="n">s</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Number</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cartrot</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                             <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spinlist</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">spinlist</span> <span class="ow">in</span> <span class="n">spins</span><span class="p">]</span>
                <span class="c1"># if det * tr &lt; -1 or det * tr &gt; 3: return False</span>
                <span class="k">for</span> <span class="n">phase</span> <span class="ow">in</span> <span class="n">rootsofunity</span><span class="p">(</span><span class="n">optype</span><span class="p">):</span>
                    <span class="n">newspins</span> <span class="o">=</span> <span class="p">[[</span><span class="n">phase</span> <span class="o">*</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spinlist</span><span class="p">]</span> <span class="k">for</span> <span class="n">spinlist</span> <span class="ow">in</span> <span class="n">rotspins</span><span class="p">]</span>
                    <span class="n">trans</span><span class="p">,</span> <span class="n">indexmap</span> <span class="o">=</span> <span class="n">maptranslation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">,</span>
                                                     <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">supercell</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
                                                       <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">atomlist</span><span class="p">]</span>
                                                      <span class="k">for</span> <span class="n">atomlist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">],</span>
                                                     <span class="n">spins</span><span class="p">,</span> <span class="n">newspins</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">indexmap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">groupops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">GroupOp</span><span class="p">(</span><span class="n">supercell</span><span class="p">,</span>
                                                <span class="n">trans</span><span class="p">,</span>
                                                <span class="n">cartrot</span><span class="p">,</span>
                                                <span class="n">indexmap</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">groupops</span><span class="p">)</span></div>

<div class="viewcode-block" id="Crystal.strain"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.strain">[docs]</a>    <span class="k">def</span> <span class="nf">strain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new Crystal object that is a strained version of the current.</span>

<span class="sd">        :param eps: strain tensor</span>
<span class="sd">        :return Crystal: new crystal object, strained</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="ow">or</span> <span class="n">eps</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;strain is not a 3x3 tensor&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Crystal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span> <span class="o">+</span> <span class="n">eps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">,</span>
                       <span class="n">chemistry</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chemistry</span><span class="p">,</span> <span class="n">spins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spins</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span></div>

<div class="viewcode-block" id="Crystal.addbasis"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.addbasis">[docs]</a>    <span class="k">def</span> <span class="nf">addbasis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basis</span><span class="p">,</span> <span class="n">chemistry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spins</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new Crystal object that contains additional sites (assumed to be new chemistry).</span>
<span class="sd">        This is intended to &quot;add in&quot; interstitial sites. Note: if the symmetry is to be</span>
<span class="sd">        maintained, should be the output from Wyckoffpos().</span>

<span class="sd">        :param basis: list (or list of lists) of new sites</span>
<span class="sd">        :param chemistry: (optional) list of chemistry names</span>
<span class="sd">        :param spins: (optional) list of spins</span>
<span class="sd">        :return Crystal: new crystal object, with additional sites</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;basis needs to be a list or list of lists&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">spins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">spins</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;spins needs to be a list or list of lists&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">basis</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> in </span><span class="si">{}</span><span class="s2"> is not an array&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">basis</span><span class="p">))</span>
            <span class="n">newbasis</span> <span class="o">=</span> <span class="p">[[</span><span class="n">incell</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> in basis is not a list&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">elem</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> in </span><span class="si">{}</span><span class="s2"> is not an array&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">elem</span><span class="p">))</span>
            <span class="n">newbasis</span> <span class="o">=</span> <span class="p">[[</span><span class="n">incell</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">atombasis</span><span class="p">]</span> <span class="k">for</span> <span class="n">atombasis</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">chemistry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">newchemistry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemistry</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nchem</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">newbasis</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newchemistry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemistry</span> <span class="o">+</span> <span class="n">chemistry</span>
        <span class="c1"># a little complicated: need to deal with (1) no spin at all; (2) having no spin and adding;</span>
        <span class="c1"># (3) having spin and adding something without; (4) having spin and adding it.</span>
        <span class="k">if</span> <span class="n">spins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">spins</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
                <span class="n">sp</span> <span class="o">=</span> <span class="p">[</span><span class="n">spins</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sp</span> <span class="o">=</span> <span class="n">spins</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">newspins</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">atomlist</span><span class="p">]</span> <span class="k">for</span> <span class="n">atomlist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">]</span> <span class="o">+</span> <span class="n">sp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newspins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spins</span> <span class="o">+</span> <span class="n">sp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">newspins</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newspins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spins</span> <span class="o">+</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">atomlist</span><span class="p">]</span> <span class="k">for</span> <span class="n">atomlist</span> <span class="ow">in</span> <span class="n">newbasis</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Crystal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">+</span> <span class="n">newbasis</span><span class="p">,</span>
                       <span class="n">chemistry</span><span class="o">=</span><span class="n">newchemistry</span><span class="p">,</span> <span class="n">spins</span><span class="o">=</span><span class="n">newspins</span><span class="p">,</span>
                       <span class="n">threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span></div>

<div class="viewcode-block" id="Crystal.pos2cart"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.pos2cart">[docs]</a>    <span class="k">def</span> <span class="nf">pos2cart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lattvec</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cartesian coordinates of an atom specified by its lattice and index</span>

<span class="sd">        :param lattvec: 3-vector (integer) lattice vector in direct coordinates</span>
<span class="sd">        :param ind: two-tuple index specifying the atom: (atomtype, atomindex)</span>
<span class="sd">        :return v: 3-vector (float) in Cartesian coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">lattvec</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span></div>

<div class="viewcode-block" id="Crystal.unit2cart"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.unit2cart">[docs]</a>    <span class="k">def</span> <span class="nf">unit2cart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lattvec</span><span class="p">,</span> <span class="n">uvec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cartesian coordinates of a position specified by its lattice and</span>
<span class="sd">        unit cell coordinates</span>

<span class="sd">        :param lattvec: 3-vector (integer) lattice vector in direct coordinates</span>
<span class="sd">        :param uvec: 3-vector (float) unit cell vector in direct coordinates</span>
<span class="sd">        :return v: 3-vector (float) in Cartesian coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">lattvec</span> <span class="o">+</span> <span class="n">uvec</span><span class="p">)</span></div>

<div class="viewcode-block" id="Crystal.cart2unit"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.cart2unit">[docs]</a>    <span class="k">def</span> <span class="nf">cart2unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the lattvec and unit cell coord. corresponding to a position</span>
<span class="sd">        in cartesian coord.</span>

<span class="sd">        :param v: 3-vector (float) position in Cartesian coordinates</span>
<span class="sd">        :return lattvec: 3-vector (integer) lattice vector in direct coordinates,</span>
<span class="sd">        :return uvec: 3-vector (float) inside unit cell, in direct coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">invlatt</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">ucell</span> <span class="o">=</span> <span class="n">incell</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">ucell</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">ucell</span></div>

<div class="viewcode-block" id="Crystal.cart2pos"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.cart2pos">[docs]</a>    <span class="k">def</span> <span class="nf">cart2pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the lattvec and index corresponding to an atomic position in cartesian coord.</span>

<span class="sd">        :param v: 3-vector (float) position in Cartesian coordinates</span>
<span class="sd">        :return lattvec: 3-vector (integer) lattice vector in direct coordinates,</span>
<span class="sd">        :return (c,i): tuple of matching basis atom; None if no match</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">latt</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cart2unit</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">indlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">ind</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomindices</span>
                   <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__isclose__</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]])]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indlist</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">latt</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">latt</span><span class="p">,</span> <span class="n">indlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Crystal.g_direc"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.g_direc">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">g_direc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">direc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a space group operation to a direction</span>

<span class="sd">        :param g: group operation (GroupOp)</span>
<span class="sd">        :param direc: 3-vector direction</span>
<span class="sd">        :return gdirec: 3-vector direction</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">GroupOp</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">direc</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">cartrot</span><span class="p">,</span> <span class="n">direc</span><span class="p">)</span></div>

<div class="viewcode-block" id="Crystal.g_tensor"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.g_tensor">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">g_tensor</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">tensor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a space group operation to a 2nd-rank tensor</span>

<span class="sd">        :param g: group operation (GroupOp)</span>
<span class="sd">        :param tensor: 2nd-rank tensor</span>
<span class="sd">        :return gtensor: 2nd-rank tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">GroupOp</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
            <span class="k">if</span> <span class="n">tensor</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">g</span><span class="o">.</span><span class="n">rot</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">cartrot</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">cartrot</span><span class="o">.</span><span class="n">T</span><span class="p">))</span></div>

<div class="viewcode-block" id="Crystal.g_pos"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.g_pos">[docs]</a>    <span class="k">def</span> <span class="nf">g_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">lattvec</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a space group operation to an atom position specified by its lattice and index</span>

<span class="sd">        :param g: group operation (GroupOp)</span>
<span class="sd">        :param lattvec: 3-vector (integer) lattice vector in direct coordinates</span>
<span class="sd">        :param ind: two-tuple index specifying the atom: (atomtype, atomindex)</span>
<span class="sd">        :return glatt: 3-vector (integer) lattice vector in direct coordinates</span>
<span class="sd">        :return gindex: tuple of new basis atom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">GroupOp</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">lattvec</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="n">rotlatt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">rot</span><span class="p">,</span> <span class="n">lattvec</span><span class="p">)</span>
        <span class="n">rotind</span> <span class="o">=</span> <span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">g</span><span class="o">.</span><span class="n">indexmap</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">delu</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">rot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">+</span> <span class="n">g</span><span class="o">.</span><span class="n">trans</span> <span class="o">-</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">rotind</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">rotind</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rotlatt</span> <span class="o">+</span> <span class="n">delu</span><span class="p">,</span> <span class="n">rotind</span></div>

<div class="viewcode-block" id="Crystal.g_vect"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.g_vect">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">g_vect</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">lattvec</span><span class="p">,</span> <span class="n">uvec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a space group operation to a vector position specified by its lattice and a location</span>
<span class="sd">        in the unit cell in direct coordinates</span>

<span class="sd">        :param g:  group operation (GroupOp)</span>
<span class="sd">        :param lattvec: 3-vector (integer) lattice vector in direct coordinates</span>
<span class="sd">        :param uvec: 3-vector (float) vector in direct coordinates</span>
<span class="sd">        :return glatt: 3-vector (integer) lattice vector in direct coordinates</span>
<span class="sd">        :param guvec: 3-vector (float) vector in direct coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">GroupOp</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">lattvec</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">uvec</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="n">rotlatt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">rot</span><span class="p">,</span> <span class="n">lattvec</span><span class="p">)</span>
        <span class="n">rotu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">rot</span><span class="p">,</span> <span class="n">uvec</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="o">.</span><span class="n">trans</span>
        <span class="n">incellu</span> <span class="o">=</span> <span class="n">incell</span><span class="p">(</span><span class="n">rotu</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rotlatt</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">rotu</span> <span class="o">-</span> <span class="n">incellu</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">incellu</span></div>

<div class="viewcode-block" id="Crystal.g_cart"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.g_cart">[docs]</a>    <span class="k">def</span> <span class="nf">g_cart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a space group operation to a (Cartesian) vector position</span>

<span class="sd">        :param g: group operation (GroupOp)</span>
<span class="sd">        :param x: 3-vector position in space</span>
<span class="sd">        :return gx: 3-vector position in space (Cartesian coordinates)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">GroupOp</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">cartrot</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">trans</span><span class="p">)</span></div>

<div class="viewcode-block" id="Crystal.g_direc_equivalent"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.g_direc_equivalent">[docs]</a>    <span class="k">def</span> <span class="nf">g_direc_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tells us if two directions are equivalent by according to the space group</span>

<span class="sd">        :param d1: direction one (array[3])</span>
<span class="sd">        :param d2: direction two (array[3])</span>
<span class="sd">        :param threshold: threshold for equality</span>
<span class="sd">        :return equivalent: True if equivalent by a point group operation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">d1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_direc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">d2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">)</span></div>

<div class="viewcode-block" id="Crystal.genpoint"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.genpoint">[docs]</a>    <span class="k">def</span> <span class="nf">genpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate our point group indices. Done with crazy list comprehension due to the</span>
<span class="sd">        structure of our basis.</span>

<span class="sd">        :return Gpointlists: list of lists of frozensets of point group operations that leave a site unchanged</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">]]</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[[</span><span class="nb">frozenset</span><span class="p">([</span><span class="n">g</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_pos</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="p">(</span><span class="n">atomtypeindex</span><span class="p">,</span> <span class="n">atomindex</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span>
                            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">indexmap</span><span class="p">[</span><span class="n">atomtypeindex</span><span class="p">][</span><span class="n">atomindex</span><span class="p">]</span> <span class="o">==</span> <span class="n">atomindex</span><span class="p">])</span>
                 <span class="k">for</span> <span class="n">atomindex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atomlist</span><span class="p">))]</span>
                <span class="k">for</span> <span class="n">atomtypeindex</span><span class="p">,</span> <span class="n">atomlist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)]</span></div>

<div class="viewcode-block" id="Crystal.genWyckoffsets"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.genWyckoffsets">[docs]</a>    <span class="k">def</span> <span class="nf">genWyckoffsets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate our Wykcoff sets.</span>

<span class="sd">        :return Wyckoffsets: set of sets of tuples of positions that correspond to identical Wyckoff positions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">frozenset</span><span class="p">([</span><span class="nb">frozenset</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])])</span>
        <span class="c1"># this is a little suboptimal if our basis is huge--it leans heavily</span>
        <span class="c1"># on the construction of sets to make the checks easy.</span>
        <span class="k">return</span> <span class="nb">frozenset</span><span class="p">([</span><span class="nb">frozenset</span><span class="p">([(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">g</span><span class="o">.</span><span class="n">indexmap</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                                     <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">])</span>
                          <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomindices</span><span class="p">])</span></div>

<div class="viewcode-block" id="Crystal.Wyckoffpos"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.Wyckoffpos">[docs]</a>    <span class="k">def</span> <span class="nf">Wyckoffpos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uvec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates all the equivalent Wyckoff positions for a unit cell vector.</span>

<span class="sd">        :param uvec: 3-vector (float) vector in direct coordinates</span>
<span class="sd">        :return Wyckofflist: list of equivalent Wyckoff positions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g_vect</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">uvec</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">__isclose__</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u1</span><span class="p">)</span> <span class="k">for</span> <span class="n">u1</span> <span class="ow">in</span> <span class="n">lis</span><span class="p">]):</span>
                <span class="n">lis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lis</span></div>

<div class="viewcode-block" id="Crystal.VectorBasis"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.VectorBasis">[docs]</a>    <span class="k">def</span> <span class="nf">VectorBasis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates the vector basis corresponding to an atomic site</span>

<span class="sd">        :param ind: tuple index for atom</span>
<span class="sd">        :return dim: dimensionality, 0..3</span>
<span class="sd">        :return vect: vector defining line direction (1) or plane normal (2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># need to work with the point group operations for the site</span>
        <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">CombineVectorBasis</span><span class="p">,</span>
                      <span class="p">[</span><span class="n">VectorBasis</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">eigen</span><span class="p">())</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointG</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span></div>
        <span class="c1"># , (3, np.zeros(3)) -- don&#39;t need initial value; if there&#39;s only one group op, it&#39;s identity</span>

    <span class="c1"># implemented as a static method as its a utility function</span>
<div class="viewcode-block" id="Crystal.vectlist"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.vectlist">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">vectlist</span><span class="p">(</span><span class="n">vb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of orthonormal vectors corresponding to our vector basis.</span>

<span class="sd">        :param vb: (dim, v)</span>
<span class="sd">        :return vlist: list of vectors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">vb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="p">[</span><span class="n">vb</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">vb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">vb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="k">return</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">vb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="k">if</span> <span class="n">vb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># 3d only</span>
            <span class="c1"># now, construct the other two directions:</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">vb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">norm</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.75</span><span class="p">:</span>
                <span class="n">v1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">norm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">norm</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">norm</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">norm</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">v1</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v1</span><span class="p">))</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">]</span></div>

<div class="viewcode-block" id="Crystal.FullVectorBasis"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.FullVectorBasis">[docs]</a>    <span class="k">def</span> <span class="nf">FullVectorBasis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chem</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate our full vector basis, using the information from our crystal</span>

<span class="sd">        :param chem: (optional) chemical index to consider; otherwise return a list of such</span>
<span class="sd">        :return VBfunctions: (list) of our unique vector basis lattice functions, normalized; each is an array</span>
<span class="sd">            (NVbasis x Nsites x 3)</span>
<span class="sd">        :return VVouter: (list) of ouf VV &quot;outer&quot; expansion (NVbasis x NVbasis for each chemistry)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">chem</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chemlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chemlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">chem</span><span class="p">]</span>
        <span class="n">VBlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">VVlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chemlist</span><span class="p">:</span>
            <span class="n">lis</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vectlist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">VectorBasis</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]))):</span>
                    <span class="n">v</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>  <span class="c1"># additional normalization</span>
                    <span class="c1"># we have some constructing to do... first, make the vector we want to use</span>
                    <span class="n">vb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">:</span>
                        <span class="c1"># what site do we land on, and what&#39;s the vector? (this is slight overkill)</span>
                        <span class="n">vb</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">indexmap</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_direc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                    <span class="n">lis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vb</span><span class="p">)</span>
            <span class="c1"># need the *full matrix of this tensor*; could probably be done using tensordot?</span>
            <span class="n">VV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vb_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lis</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">vb_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lis</span><span class="p">):</span>
                    <span class="n">VV</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vb_i</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">vb_j</span><span class="p">)</span>
            <span class="n">VBlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lis</span><span class="p">))</span>
            <span class="n">VVlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">VV</span><span class="p">)</span>
        <span class="c1"># if we didn&#39;t specify which chemical element, return the lists; else, just the individual arrays</span>
        <span class="k">if</span> <span class="n">chem</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">VBlist</span><span class="p">,</span> <span class="n">VVlist</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">VBlist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">VVlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Crystal.SymmTensorBasis"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.SymmTensorBasis">[docs]</a>    <span class="k">def</span> <span class="nf">SymmTensorBasis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates the symmetric tensor basis corresponding to an atomic site</span>

<span class="sd">        :param ind: tuple index for atom</span>
<span class="sd">        :return tensorbasis: list of 2nd-rank symmetric tensors making up the basis</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># need to work with the point group operations for the site</span>
        <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">CombineTensorBasis</span><span class="p">,</span>
                      <span class="p">[</span><span class="n">SymmTensorBasis</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">eigen</span><span class="p">())</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointG</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span></div>
        <span class="c1"># , (3, np.zeros(3)) -- don&#39;t need initial value; if there&#39;s only one group op, it&#39;s identity</span>

<div class="viewcode-block" id="Crystal.nnlist"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.nnlist">[docs]</a>    <span class="k">def</span> <span class="nf">nnlist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the nearest neighbor list for a given cutoff. Only consider</span>
<span class="sd">        neighbor vectors for atoms of the same type. Returns a list of</span>
<span class="sd">        cartesian vectors.</span>

<span class="sd">        :param ind: tuple index for atom</span>
<span class="sd">        :param cutoff:  distance cutoff</span>
<span class="sd">        :return nnlist: list of nearest neighbor vectors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r2</span> <span class="o">=</span> <span class="n">cutoff</span> <span class="o">*</span> <span class="n">cutoff</span>
        <span class="n">nmax</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">])))</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)]</span>
        <span class="n">nranges</span> <span class="o">=</span> <span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nmax</span><span class="p">]</span>
        <span class="n">supervect</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ntup</span><span class="p">)</span> <span class="k">for</span> <span class="n">ntup</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">nranges</span><span class="p">)]</span>
        <span class="n">lis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">u0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">u1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
            <span class="n">du</span> <span class="o">=</span> <span class="n">u1</span> <span class="o">-</span> <span class="n">u0</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">supervect</span><span class="p">:</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit2cart</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">du</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">r2</span><span class="p">:</span>
                    <span class="n">lis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lis</span></div>

<div class="viewcode-block" id="Crystal.jumpnetwork"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.jumpnetwork">[docs]</a>    <span class="k">def</span> <span class="nf">jumpnetwork</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chem</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">closestdistance</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the full jump network for a specific chemical index, out to a cutoff. Organized</span>
<span class="sd">        by symmetry-unique transitions. Note that i-&gt;j and j-&gt;i are always related to one-another,</span>
<span class="sd">        but by equivalence of transition state, not symmetry. Now updated with closest-distance</span>
<span class="sd">        parameter.</span>

<span class="sd">        :param chem: index corresponding to the chemistry to consider</span>
<span class="sd">        :param cutoff: distance cutoff</span>
<span class="sd">        :param closestdistance: closest distance allowed in transition (can be a list)</span>
<span class="sd">        :return jumpnetwork: list of symmetry-unique transitions; each is a list of tuples:</span>
<span class="sd">          ``((i,j), dx)`` corresponding to jump from :math:`i \\to j` with vector :math:`\mathbf{\delta x}`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># should we consider changing the lists to tuples? Not sure if there&#39;s any efficiency gain</span>
        <span class="k">def</span> <span class="nf">inlist</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">lis</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Determines if (i,j), dx is in our list&quot;&quot;&quot;</span>
            <span class="c1"># a little confusing: run through all transition tuples, see if we find our example</span>
            <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">tup</span> <span class="o">==</span> <span class="n">ij</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__isclose__</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">translist</span> <span class="ow">in</span> <span class="n">lis</span> <span class="k">for</span> <span class="n">ij</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">translist</span><span class="p">)</span>

        <span class="n">r2</span> <span class="o">=</span> <span class="n">cutoff</span> <span class="o">*</span> <span class="n">cutoff</span>
        <span class="n">nmax</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">])))</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)]</span>
        <span class="n">nranges</span> <span class="o">=</span> <span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nmax</span><span class="p">]</span>
        <span class="n">supervect</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ntup</span><span class="p">)</span> <span class="k">for</span> <span class="n">ntup</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">nranges</span><span class="p">)]</span>
        <span class="n">lis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">u0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">chem</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">u1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">chem</span><span class="p">]):</span>
                <span class="n">du</span> <span class="o">=</span> <span class="n">u1</span> <span class="o">-</span> <span class="n">u0</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">supervect</span><span class="p">:</span>
                    <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit2cart</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">du</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">r2</span><span class="p">:</span>
                        <span class="c1"># we have a valid transition; first check that we haven&#39;t already looked at it</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">inlist</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dx</span><span class="p">,</span> <span class="n">lis</span><span class="p">):</span>
                            <span class="n">trans</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">:</span>
                                <span class="c1"># rotate through all combinations of i-&gt;j using space group symmetry</span>
                                <span class="n">R1</span><span class="p">,</span> <span class="n">ind1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_pos</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="p">(</span><span class="n">chem</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
                                <span class="n">R2</span><span class="p">,</span> <span class="n">ind2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_pos</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">chem</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                                <span class="n">tup</span> <span class="o">=</span> <span class="p">(</span><span class="n">ind1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ind2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                                <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos2cart</span><span class="p">(</span><span class="n">R2</span><span class="p">,</span> <span class="n">ind2</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos2cart</span><span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">ind1</span><span class="p">)</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">tup</span> <span class="o">==</span> <span class="n">ij</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__isclose__</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">ij</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">trans</span><span class="p">):</span>
                                    <span class="n">trans</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">tup</span><span class="p">,</span> <span class="n">dx</span><span class="p">))</span>
                                    <span class="n">trans</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="n">dx</span><span class="p">))</span>
                            <span class="n">lis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span>
        <span class="c1"># now for collision detection:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">closestdistance</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="c1"># quick sanity check to make sure we don&#39;t include collision detection on</span>
            <span class="c1"># our interstitial site</span>
            <span class="n">closest2list</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">chem</span> <span class="k">else</span> <span class="o">-</span><span class="mf">1.</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">closestdistance</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">closest2list</span> <span class="o">=</span> <span class="p">[</span><span class="n">closestdistance</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">chem</span> <span class="k">else</span> <span class="o">-</span><span class="mf">1.</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nchem</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">mindist2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">closest2list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mindist2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># skip the negative distances; we still check 0 because straight line paths</span>
                <span class="c1"># through sites should (probably) still be excluded</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">u0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">supervect</span><span class="p">:</span>
                    <span class="c1"># check each transition in the list (we need to do list(lis) because</span>
                    <span class="c1"># we will modify lis in place with remove&#39;s, and its dangerous to pull</span>
                    <span class="c1"># off as we iterate through:</span>
                    <span class="c1"># for trans in lis.copy():</span>
                    <span class="k">for</span> <span class="n">ntrans</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">trans</span> <span class="o">=</span> <span class="n">lis</span><span class="p">[</span><span class="n">ntrans</span><span class="p">]</span>
                        <span class="n">t</span> <span class="o">=</span> <span class="n">trans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># representative transition</span>
                        <span class="n">dx</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="c1"># take our starting point relative to the first item in the tuple</span>
                        <span class="n">xRa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit2cart</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">u0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">chem</span><span class="p">][</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
                        <span class="n">xRa2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">xRa</span><span class="p">,</span> <span class="n">xRa</span><span class="p">)</span>
                        <span class="n">xRa_dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">xRa</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
                        <span class="n">dx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
                        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">xRa_dx</span> <span class="o">&lt;=</span> <span class="n">dx2</span><span class="p">:</span>
                            <span class="n">d2</span> <span class="o">=</span> <span class="p">(</span><span class="n">xRa2</span> <span class="o">*</span> <span class="n">dx2</span> <span class="o">-</span> <span class="n">xRa_dx</span> <span class="o">*</span> <span class="n">xRa_dx</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx2</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">d2</span><span class="p">,</span> <span class="n">mindist2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">d2</span> <span class="o">&lt;</span> <span class="n">mindist2</span><span class="p">:</span>
                                <span class="c1"># lis.remove(trans)</span>
                                <span class="n">lis</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ntrans</span><span class="p">)</span>
        <span class="n">lis</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">entry</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mf">1e-3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dx</span> <span class="ow">in</span> <span class="n">entry</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">lis</span></div>

<div class="viewcode-block" id="Crystal.jumpnetwork2lattice"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.jumpnetwork2lattice">[docs]</a>    <span class="k">def</span> <span class="nf">jumpnetwork2lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chem</span><span class="p">,</span> <span class="n">jumpnetwork</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a &quot;standard&quot; jumpnetwork (that specifies displacement vectors dx) into a lattice</span>
<span class="sd">        representation, where we replace dx with the lattice vector from i to j.</span>

<span class="sd">        :param chem: index corresponding to the chemistry to consider</span>
<span class="sd">        :param jumpnetwork: list of symmetry-unique transitions; each is a list of tuples:</span>
<span class="sd">          ``((i,j), dx)`` corresponding to jump from :math:`i \\to j` with vector :math:`\mathbf{\delta x}`</span>
<span class="sd">        :return jumplattice: list of symmetry-unique transitions; each is a list of tuples:</span>
<span class="sd">          ``((i,j), R)`` corresponding to jump from i in unit cell 0 -&gt; j in unit cell R</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[[((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">invlatt</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">chem</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">chem</span><span class="p">][</span><span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
                 <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dx</span> <span class="ow">in</span> <span class="n">jumplist</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">jumplist</span> <span class="ow">in</span> <span class="n">jumpnetwork</span><span class="p">]</span></div>

<div class="viewcode-block" id="Crystal.sitelist"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.sitelist">[docs]</a>    <span class="k">def</span> <span class="nf">sitelist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chem</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of lists of Wyckoff-related sites for a given chemistry.</span>
<span class="sd">        Done with a single list comprehension--useful as input for diffusion calculation</span>

<span class="sd">        :param chem: index corresponding to chemistry to consider</span>
<span class="sd">        :return symmequivsites: list of lists of indices that are equivalent by symmetry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">([</span><span class="nb">sorted</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">l</span><span class="p">)</span>  <span class="c1"># strips out the chemistry index; sorted for readability</span>
                       <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wyckoff</span><span class="p">]</span>  <span class="c1"># converts to list of lists</span>
                       <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">chem</span><span class="p">])</span>  <span class="c1"># select only those with correct chemistry</span></div>

<div class="viewcode-block" id="Crystal.fullkptmesh"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.fullkptmesh">[docs]</a>    <span class="k">def</span> <span class="nf">fullkptmesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Nmesh</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a k-point mesh of density given by Nmesh; does not symmetrize but does put the</span>
<span class="sd">        k-points inside the BZ. Does not return any *weights* as every point is equally weighted.</span>

<span class="sd">        :param Nmesh: mesh divisions Nmesh[0] x Nmesh[1] x Nmesh[2]</span>
<span class="sd">        :return kpt: array[Nkpt][3] of kpoints</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Nkpt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">Nmesh</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Nkpt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span>
        <span class="c1"># dN = np.array([1 / x for x in Nmesh])</span>
        <span class="c1"># # use a list comprehension to iterate and build:</span>
        <span class="c1"># kptfull = np.array([np.dot(self.reciplatt, (n0 * dN[0], n1 * dN[1], n2 * dN[2]))</span>
        <span class="c1">#                     for n0 in range(-Nmesh[0] // 2 + 1, Nmesh[0] // 2 + 1)</span>
        <span class="c1">#                     for n1 in range(-Nmesh[1] // 2 + 1, Nmesh[1] // 2 + 1)</span>
        <span class="c1">#                     for n2 in range(-Nmesh[2] // 2 + 1, Nmesh[2] // 2 + 1)])</span>
        <span class="n">kdiv</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">Nm</span><span class="p">,</span><span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">Nm</span> <span class="ow">in</span> <span class="n">Nmesh</span><span class="p">]</span>
        <span class="n">kptfull</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reciplatt</span><span class="p">,</span> <span class="n">ktup</span><span class="p">)</span> <span class="k">for</span> <span class="n">ktup</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">kdiv</span><span class="p">)])</span>
        <span class="c1"># run through list to ensure that all k-points are inside the BZ</span>
        <span class="n">Gmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">G</span><span class="p">)</span> <span class="k">for</span> <span class="n">G</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">BZG</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kptfull</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">Gmin</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">G</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">BZG</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">G</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
                        <span class="n">k</span> <span class="o">-=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">G</span>
        <span class="k">return</span> <span class="n">kptfull</span></div>

<div class="viewcode-block" id="Crystal.reducekptmesh"><a class="viewcode-back" href="../crystal.html#crystal.Crystal.reducekptmesh">[docs]</a>    <span class="k">def</span> <span class="nf">reducekptmesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kptfull</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a fully expanded mesh, and reduces it by symmetry. Assumes every point is</span>
<span class="sd">        equally weighted. We would need a different (more complicated) algorithm if not true...</span>

<span class="sd">        :param kptfull: array[Nkpt][3] of kpoints</span>
<span class="sd">        :param threshold: threshold for symmetry equality</span>
<span class="sd">        :return kptsymm: array[Nsymm][3] of kpoints</span>
<span class="sd">        :return weight: array[Nsymm] of weights (integrates to 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">threshold</span>
        <span class="n">kptlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">kptfull</span><span class="p">)</span>
        <span class="n">Nkpt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kptlist</span><span class="p">)</span>
        <span class="n">kptlist</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
        <span class="n">k2_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">k2old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">kptlist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">kptlist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kptlist</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">k2</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">k2old</span> <span class="o">+</span> <span class="n">eps</span><span class="p">):</span>
                <span class="n">k2_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">k2old</span> <span class="o">=</span> <span class="n">k2</span>
        <span class="n">k2_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Nkpt</span><span class="p">)</span>
        <span class="c1"># k2_indices now contains a list of indices with the same magnitudes</span>
        <span class="n">kptsym</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">wsym</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># unscaled at this point</span>
        <span class="n">kmin</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">basewt</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">Nkpt</span>
        <span class="k">for</span> <span class="n">kmax</span> <span class="ow">in</span> <span class="n">k2_indices</span><span class="p">:</span>
            <span class="n">complist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">symmcomplist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">wtlist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kptlist</span><span class="p">[</span><span class="n">kmin</span><span class="p">:</span><span class="n">kmax</span><span class="p">]:</span>
                <span class="n">match</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">symmcomp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">symmcomplist</span><span class="p">):</span>
                    <span class="c1"># if any(np.allclose(k, gk, rtol=0, atol=threshold) for gk in symmcomp):</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">gk</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">)</span> <span class="k">for</span> <span class="n">gk</span> <span class="ow">in</span> <span class="n">symmcomp</span><span class="p">):</span>
                        <span class="c1"># update weight, kick out</span>
                        <span class="n">wtlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">basewt</span>
                        <span class="n">match</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                    <span class="c1"># new symmetry point!</span>
                    <span class="n">complist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="n">symmcomplist</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">g_direc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">])</span>
                    <span class="n">wtlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">basewt</span><span class="p">)</span>
            <span class="n">kptsym</span> <span class="o">+=</span> <span class="n">complist</span>
            <span class="n">wsym</span> <span class="o">+=</span> <span class="n">wtlist</span>
            <span class="n">kmin</span> <span class="o">=</span> <span class="n">kmax</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kptsym</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">wsym</span><span class="p">)</span></div></div>


<span class="c1"># YAML interfaces for types outside of this module</span>
<div class="viewcode-block" id="ndarray_representer"><a class="viewcode-back" href="../crystal.html#crystal.ndarray_representer">[docs]</a><span class="k">def</span> <span class="nf">ndarray_representer</span><span class="p">(</span><span class="n">dumper</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Output a numpy array&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">dumper</span><span class="o">.</span><span class="n">represent_sequence</span><span class="p">(</span><span class="n">NDARRAY_YAMLTAG</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span></div>


<span class="c1">### NOTE: deep=True is THE KEY here for reading</span>
<span class="c1">### hat-tip: https://stackoverflow.com/questions/19439765/is-there-a-way-to-construct-an-object-using-pyyaml-construct-mapping-after-all-n</span>
<span class="k">def</span> <span class="nf">ndarray_constructor</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loader</span><span class="o">.</span><span class="n">construct_sequence</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>


<span class="c1"># YAML registration:</span>
<span class="n">yaml</span><span class="o">.</span><span class="n">add_representer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray_representer</span><span class="p">)</span>
<span class="n">yaml</span><span class="o">.</span><span class="n">add_constructor</span><span class="p">(</span><span class="n">NDARRAY_YAMLTAG</span><span class="p">,</span> <span class="n">ndarray_constructor</span><span class="p">)</span>

<span class="n">yaml</span><span class="o">.</span><span class="n">add_representer</span><span class="p">(</span><span class="n">GroupOp</span><span class="p">,</span> <span class="n">GroupOp</span><span class="o">.</span><span class="n">GroupOp_representer</span><span class="p">)</span>
<span class="n">yaml</span><span class="o">.</span><span class="n">add_constructor</span><span class="p">(</span><span class="n">GROUPOP_YAMLTAG</span><span class="p">,</span> <span class="n">GroupOp</span><span class="o">.</span><span class="n">GroupOp_constructor</span><span class="p">)</span>


<span class="c1"># representers for numpy types that trip up YAML</span>
<span class="c1"># (from https://github.com/leifdenby/pycfd/blob/master/yaml_serialize.py)</span>
<span class="k">def</span> <span class="nf">bool_representer</span><span class="p">(</span><span class="n">dumper</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">dumper</span><span class="o">.</span><span class="n">represent_bool</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>


<span class="n">yaml</span><span class="o">.</span><span class="n">add_representer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span> <span class="n">bool_representer</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">int_representer</span><span class="p">(</span><span class="n">dumper</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">dumper</span><span class="o">.</span><span class="n">represent_int</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>


<span class="n">yaml</span><span class="o">.</span><span class="n">add_representer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">int_representer</span><span class="p">)</span>
<span class="n">yaml</span><span class="o">.</span><span class="n">add_representer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="n">int_representer</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">long_representer</span><span class="p">(</span><span class="n">dumper</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">dumper</span><span class="o">.</span><span class="n">represent_long</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>


<span class="n">yaml</span><span class="o">.</span><span class="n">add_representer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">int_representer</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">float_representer</span><span class="p">(</span><span class="n">dumper</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">dumper</span><span class="o">.</span><span class="n">represent_float</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>


<span class="n">yaml</span><span class="o">.</span><span class="n">add_representer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">float_representer</span><span class="p">)</span>
<span class="n">yaml</span><span class="o">.</span><span class="n">add_representer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">float_representer</span><span class="p">)</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Dallas R. Trinkle.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.3',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>