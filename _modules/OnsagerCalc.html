

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>OnsagerCalc &mdash; Onsager 1.3.2 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Onsager
          

          
          </a>

          
            
            
              <div class="version">
                1.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../includeme.html">Onsager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../InputOutput.html">Input and output for Onsager transport calculation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks.html">Example Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">Modules</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Onsager</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>OnsagerCalc</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for OnsagerCalc</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Onsager calculator module: Interstitialcy mechanism and Vacancy-mediated mechanism</span>

<span class="sd">Class to create an Onsager &quot;calculator&quot;, which brings two functionalities:</span>
<span class="sd">1. determines *what* input is needed to compute the Onsager (mobility, or L) tensors</span>
<span class="sd">2. constructs the function that calculates those tensors, given the input values.</span>

<span class="sd">This class is designed to be combined with code that can, e.g., automatically</span>
<span class="sd">run some sort of atomistic-scale (DFT, classical potential) calculation of site</span>
<span class="sd">energies, and energy barriers, and then in concert with scripts to convert such data</span>
<span class="sd">into rates and probabilities, this will allow for efficient evaluation of transport</span>
<span class="sd">coefficients.</span>

<span class="sd">This implementation will be for vacancy-mediated solute diffusion assumes the dilute limit.</span>
<span class="sd">The mathematics is based on a Green function solution for the vacancy diffusion. The</span>
<span class="sd">computation of the GF is included in the GFcalc module.</span>

<span class="sd">Now with HDF5 write / read capability for VacancyMediated module</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Dallas R. Trinkle&#39;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="k">import</span> <span class="n">pinv2</span><span class="p">,</span> <span class="n">solve</span>
<span class="kn">import</span> <span class="nn">copy</span><span class="o">,</span> <span class="nn">collections</span><span class="o">,</span> <span class="nn">itertools</span><span class="o">,</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">onsager</span> <span class="k">import</span> <span class="n">GFcalc</span>
<span class="kn">from</span> <span class="nn">onsager</span> <span class="k">import</span> <span class="n">crystal</span>
<span class="kn">from</span> <span class="nn">onsager</span> <span class="k">import</span> <span class="n">crystalStars</span> <span class="k">as</span> <span class="n">stars</span>
<span class="kn">from</span> <span class="nn">onsager</span> <span class="k">import</span> <span class="n">supercell</span>

<span class="c1"># database tags</span>
<span class="n">INTERSTITIAL_TAG</span> <span class="o">=</span> <span class="s1">&#39;i&#39;</span>
<span class="n">TRANSITION_TAG</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{state1}</span><span class="s1">^</span><span class="si">{state2}</span><span class="s1">&#39;</span>
<span class="n">SOLUTE_TAG</span> <span class="o">=</span> <span class="s1">&#39;s&#39;</span>
<span class="n">VACANCY_TAG</span> <span class="o">=</span> <span class="s1">&#39;v&#39;</span>
<span class="n">SINGLE_DEFECT_TAG_3D</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{type}</span><span class="s1">:</span><span class="si">{u[0]:+06.3f}</span><span class="s1">,</span><span class="si">{u[1]:+06.3f}</span><span class="s1">,</span><span class="si">{u[2]:+06.3f}</span><span class="s1">&#39;</span>
<span class="n">SINGLE_DEFECT_TAG_2D</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{type}</span><span class="s1">:</span><span class="si">{u[0]:+06.3f}</span><span class="s1">,</span><span class="si">{u[1]:+06.3f}</span><span class="s1">&#39;</span>
<span class="n">DOUBLE_DEFECT_TAG</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{state1}</span><span class="s1">-</span><span class="si">{state2}</span><span class="s1">&#39;</span>
<span class="n">OM0_TAG</span> <span class="o">=</span> <span class="s1">&#39;omega0:</span><span class="si">{vac1}</span><span class="s1">^</span><span class="si">{vac2}</span><span class="s1">&#39;</span>
<span class="n">OM1_TAG</span> <span class="o">=</span> <span class="s1">&#39;omega1:</span><span class="si">{solute}</span><span class="s1">-</span><span class="si">{vac1}</span><span class="s1">^</span><span class="si">{vac2}</span><span class="s1">&#39;</span>
<span class="n">OM2_TAG</span> <span class="o">=</span> <span class="s1">&#39;omega2:</span><span class="si">{complex1}</span><span class="s1">^</span><span class="si">{complex2}</span><span class="s1">&#39;</span>


<div class="viewcode-block" id="Interstitial"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.Interstitial">[docs]</a><span class="k">class</span> <span class="nc">Interstitial</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to compute interstitial diffusivity; uses structure of crystal to do most</span>
<span class="sd">    of the heavy lifting in terms of symmetry.</span>

<span class="sd">    Takes in a crystal that contains the interstitial as one of the chemical elements,</span>
<span class="sd">    to be specified by ``chem``, the sitelist (list of symmetry equivalent sites), and</span>
<span class="sd">    jumpnetwork. Both of the latter can be computed automatically from ``crys`` methods,</span>
<span class="sd">    but as they are lists, can also be editted or constructed by hand.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Interstitial.__init__"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.Interstitial.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crys</span><span class="p">,</span> <span class="n">chem</span><span class="p">,</span> <span class="n">sitelist</span><span class="p">,</span> <span class="n">jumpnetwork</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialization; takes an underlying crystal, a choice of atomic chemistry,</span>
<span class="sd">        a corresponding Wyckoff site list and jump network.</span>

<span class="sd">        :param crys: Crystal object</span>
<span class="sd">        :param chem: integer, index into the basis of crys, corresponding to the chemical element that hops</span>
<span class="sd">        :param sitelist: list of lists of indices, site indices where the atom may hop;</span>
<span class="sd">          grouped by symmetry equivalency</span>
<span class="sd">        :param jumpnetwork: list of lists of tuples: ( (i, j), dx )</span>
<span class="sd">            symmetry unique transitions; each list is all of the possible transitions</span>
<span class="sd">            from site i to site j with jump vector dx; includes i-&gt;j and j-&gt;i</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crys</span> <span class="o">=</span> <span class="n">crys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="n">crys</span><span class="o">.</span><span class="n">dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chem</span> <span class="o">=</span> <span class="n">chem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span> <span class="o">=</span> <span class="n">sitelist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">sitelist</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">w</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invmap</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">sitelist</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">w</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sitelist</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">w</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">invmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork</span> <span class="o">=</span> <span class="n">jumpnetwork</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">VectorBasis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">VV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">FullVectorBasis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NV</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">VectorBasis</span><span class="p">)</span>
        <span class="c1"># quick check to see if our projected omega matrix will be invertible</span>
        <span class="c1"># only really needed if we have a non-empty vector basis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega_invertible</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NV</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># invertible if inversion is present</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">omega_invertible</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">cartrot</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">crys</span><span class="o">.</span><span class="n">G</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega_invertible</span><span class="p">:</span>
            <span class="c1"># invertible, so just use solve for speed (omega is technically *negative* definite)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bias_solver</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">omega</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="o">-</span><span class="n">solve</span><span class="p">(</span><span class="o">-</span><span class="n">omega</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">sym_pos</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># pseudoinverse required:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bias_solver</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">omega</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pinv2</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>
        <span class="c1"># these pieces are needed in order to compute the elastodiffusion tensor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sitegroupops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generateSiteGroupOps</span><span class="p">()</span>  <span class="c1"># list of group ops to take first rep. into whole list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jumpgroupops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generateJumpGroupOps</span><span class="p">()</span>  <span class="c1"># list of group ops to take first rep. into whole list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">siteSymmTensorBasis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generateSiteSymmTensorBasis</span><span class="p">()</span>  <span class="c1"># projections for *first rep. only*</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jumpSymmTensorBasis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generateJumpSymmTensorBasis</span><span class="p">()</span>  <span class="c1"># projections for *first rep. only*</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tagdict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tagdicttype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generatetags</span><span class="p">()</span>  <span class="c1"># now with tags!</span></div>

<div class="viewcode-block" id="Interstitial.sitelistYAML"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.Interstitial.sitelistYAML">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">sitelistYAML</span><span class="p">(</span><span class="n">sitelist</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dumps a &quot;sample&quot; YAML formatted version of the sitelist with data to be entered&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">crystal</span><span class="o">.</span><span class="n">yaml</span><span class="o">.</span><span class="n">dump</span><span class="p">({</span><span class="s1">&#39;Dipole&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">sitelist</span><span class="p">],</span>
                                  <span class="s1">&#39;Energy&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">sitelist</span><span class="p">],</span>
                                  <span class="s1">&#39;Prefactor&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">sitelist</span><span class="p">],</span>
                                  <span class="s1">&#39;sitelist&#39;</span><span class="p">:</span> <span class="n">sitelist</span><span class="p">})</span></div>

<div class="viewcode-block" id="Interstitial.jumpnetworkYAML"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.Interstitial.jumpnetworkYAML">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">jumpnetworkYAML</span><span class="p">(</span><span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dumps a &quot;sample&quot; YAML formatted version of the jumpnetwork with data to be entered&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">crystal</span><span class="o">.</span><span class="n">yaml</span><span class="o">.</span><span class="n">dump</span><span class="p">({</span><span class="s1">&#39;DipoleT&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">jumpnetwork</span><span class="p">],</span>
                                  <span class="s1">&#39;EnergyT&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">jumpnetwork</span><span class="p">],</span>
                                  <span class="s1">&#39;PrefactorT&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">jumpnetwork</span><span class="p">],</span>
                                  <span class="s1">&#39;jumpnetwork&#39;</span><span class="p">:</span> <span class="n">jumpnetwork</span><span class="p">})</span></div>

<div class="viewcode-block" id="Interstitial.generatetags"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.Interstitial.generatetags">[docs]</a>    <span class="k">def</span> <span class="nf">generatetags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create tags for unique interstitial states, and transition states.</span>

<span class="sd">        :return tags: dictionary of tags; each is a list-of-lists</span>
<span class="sd">        :return tagdict: dictionary that maps tag into the index of the corresponding list.</span>
<span class="sd">        :return tagdicttype: dictionary that maps tag into the key for the corresponding list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tags</span><span class="p">,</span> <span class="n">tagdict</span><span class="p">,</span> <span class="n">tagdicttype</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}</span>
        <span class="n">basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">]</span>  <span class="c1"># shortcut</span>

        <span class="k">def</span> <span class="nf">single_state</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">SINGLE_DEFECT_TAG_3D</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="n">INTERSTITIAL_TAG</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="n">u</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> \
                    <span class="n">SINGLE_DEFECT_TAG_2D</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="n">INTERSTITIAL_TAG</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="n">u</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">transition</span><span class="p">(</span><span class="n">ui</span><span class="p">,</span> <span class="n">dx</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">TRANSITION_TAG</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">single_state</span><span class="p">(</span><span class="n">ui</span><span class="p">),</span>
                                         <span class="n">state2</span><span class="o">=</span><span class="n">single_state</span><span class="p">(</span><span class="n">ui</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">invlatt</span><span class="p">,</span> <span class="n">dx</span><span class="p">)))</span>

        <span class="n">tags</span><span class="p">[</span><span class="s1">&#39;states&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">single_state</span><span class="p">(</span><span class="n">basis</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">]</span>
                          <span class="k">for</span> <span class="n">sites</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">]</span>
        <span class="n">tags</span><span class="p">[</span><span class="s1">&#39;transitions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">transition</span><span class="p">(</span><span class="n">basis</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span> <span class="k">for</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dx</span><span class="p">)</span> <span class="ow">in</span> <span class="n">jumplist</span><span class="p">]</span>
                               <span class="k">for</span> <span class="n">jumplist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork</span><span class="p">]</span>
        <span class="c1"># make the &quot;tagdict&quot; for quick indexing!</span>
        <span class="k">for</span> <span class="n">tagtype</span><span class="p">,</span> <span class="n">taglist</span> <span class="ow">in</span> <span class="n">tags</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tagset</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">taglist</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">tagset</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">tagdict</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Generated repeated tags? </span><span class="si">{}</span><span class="s1"> found twice.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tagdict</span><span class="p">[</span><span class="n">tag</span><span class="p">],</span> <span class="n">tagdicttype</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">tagtype</span>
        <span class="k">return</span> <span class="n">tags</span><span class="p">,</span> <span class="n">tagdict</span><span class="p">,</span> <span class="n">tagdicttype</span></div>

<div class="viewcode-block" id="Interstitial.__str__"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.Interstitial.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Human readable version of diffuser&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Diffuser for atom </span><span class="si">{}</span><span class="s2"> (</span><span class="si">{}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">chemistry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">])</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;states&#39;</span><span class="p">,</span> <span class="s1">&#39;transitions&#39;</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">t</span> <span class="o">+</span> <span class="s1">&#39;:</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">taglist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">taglist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="n">t</span><span class="p">]])</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="Interstitial.makesupercells"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.Interstitial.makesupercells">[docs]</a>    <span class="k">def</span> <span class="nf">makesupercells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">super_n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Take in a supercell matrix, then generate all of the supercells needed to compute</span>
<span class="sd">        site energies and transitions (corresponding to the representatives).</span>

<span class="sd">        :param super_n: 3x3 integer matrix to define our supercell</span>
<span class="sd">        :return superdict: dictionary of ``states``, ``transitions``, ``transmapping``,</span>
<span class="sd">            and ``indices`` that correspond to dictionaries with tags.</span>

<span class="sd">            * superdict[&#39;states&#39;][i] = supercell of site;</span>
<span class="sd">            * superdict[&#39;transitions&#39;][n] = (supercell initial, supercell final);</span>
<span class="sd">            * superdict[&#39;transmapping&#39;][n] = ((site tag, groupop, mapping), (site tag, groupop, mapping))</span>
<span class="sd">            * superdict[&#39;indices&#39;][tag] = index of tag, where tag is either a state or transition tag.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">superdict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;states&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;transitions&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;transmapping&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;indices&#39;</span><span class="p">:</span> <span class="p">{}}</span>
        <span class="n">basesupercell</span> <span class="o">=</span> <span class="n">supercell</span><span class="o">.</span><span class="n">Supercell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="p">,</span> <span class="n">super_n</span><span class="p">,</span> <span class="n">interstitial</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">,),</span> <span class="n">Nsolute</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">]</span>
        <span class="c1"># fill up the supercell with all the *other* atoms</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">atomindices</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">basesupercell</span><span class="o">.</span><span class="n">fillperiodic</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">Wyckoff</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># for efficiency</span>
        <span class="k">for</span> <span class="n">sites</span><span class="p">,</span> <span class="n">tags</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="s1">&#39;states&#39;</span><span class="p">]):</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">tag</span> <span class="o">=</span> <span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">basis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">super0</span> <span class="o">=</span> <span class="n">basesupercell</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">super0</span><span class="o">.</span><span class="n">invsuper</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="o">/</span> <span class="n">super0</span><span class="o">.</span><span class="n">size</span>
            <span class="c1"># put an interstitial in that single state; the &quot;first&quot; one is fine:</span>
            <span class="n">super0</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chem</span>
            <span class="n">superdict</span><span class="p">[</span><span class="s1">&#39;states&#39;</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">super0</span>
        <span class="k">for</span> <span class="n">jumps</span><span class="p">,</span> <span class="n">tags</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="s1">&#39;transitions&#39;</span><span class="p">]):</span>
            <span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">j0</span><span class="p">),</span> <span class="n">dx0</span> <span class="o">=</span> <span class="n">jumps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="n">tags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">u0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">][</span><span class="n">i0</span><span class="p">]</span>
            <span class="n">u1</span> <span class="o">=</span> <span class="n">u0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">invlatt</span><span class="p">,</span> <span class="n">dx0</span><span class="p">)</span>  <span class="c1"># should correspond to the j0</span>
            <span class="n">super0</span><span class="p">,</span> <span class="n">super1</span> <span class="o">=</span> <span class="n">basesupercell</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">basesupercell</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">ind0</span><span class="p">,</span> <span class="n">ind1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">super0</span><span class="o">.</span><span class="n">invsuper</span><span class="p">,</span> <span class="n">u0</span><span class="p">)</span> <span class="o">/</span> <span class="n">super0</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">super1</span><span class="o">.</span><span class="n">invsuper</span><span class="p">,</span> <span class="n">u1</span><span class="p">)</span> <span class="o">/</span> <span class="n">super0</span><span class="o">.</span><span class="n">size</span>
            <span class="c1"># put interstitials at our corresponding sites</span>
            <span class="n">super0</span><span class="p">[</span><span class="n">ind0</span><span class="p">],</span> <span class="n">super1</span><span class="p">[</span><span class="n">ind1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chem</span>
            <span class="n">superdict</span><span class="p">[</span><span class="s1">&#39;transitions&#39;</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">super0</span><span class="p">,</span> <span class="n">super1</span><span class="p">)</span>
            <span class="c1"># determine the mappings:</span>
            <span class="n">superdict</span><span class="p">[</span><span class="s1">&#39;transmapping&#39;</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">(</span><span class="n">super0</span><span class="p">,</span> <span class="n">super1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">superdict</span><span class="p">[</span><span class="s1">&#39;states&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="c1"># attempt the mapping</span>
                    <span class="n">g</span><span class="p">,</span> <span class="n">mapping</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">equivalencemap</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">superdict</span><span class="p">[</span><span class="s1">&#39;transmapping&#39;</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">+=</span> <span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">mapping</span><span class="p">),)</span>
                        <span class="k">break</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">(</span><span class="n">superdict</span><span class="p">[</span><span class="s1">&#39;states&#39;</span><span class="p">],</span> <span class="n">superdict</span><span class="p">[</span><span class="s1">&#39;transitions&#39;</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">superdict</span><span class="p">[</span><span class="s1">&#39;indices&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tagdict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>  <span class="c1"># keep a local copy of the indices, for transformation later</span>
        <span class="k">return</span> <span class="n">superdict</span></div>

<div class="viewcode-block" id="Interstitial.generateSiteGroupOps"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.Interstitial.generateSiteGroupOps">[docs]</a>    <span class="k">def</span> <span class="nf">generateSiteGroupOps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a list of group operations that transform the first site in each site list</span>
<span class="sd">        into all of the other members; one group operation for each.</span>

<span class="sd">        :return siteGroupOps: list of list of group ops that mirrors the structure of site list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">groupops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sites</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">:</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">oplist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">G</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">indexmap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">][</span><span class="n">i0</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                        <span class="n">oplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                        <span class="k">break</span>
            <span class="n">groupops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oplist</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">groupops</span></div>

<div class="viewcode-block" id="Interstitial.generateJumpGroupOps"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.Interstitial.generateJumpGroupOps">[docs]</a>    <span class="k">def</span> <span class="nf">generateJumpGroupOps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a list of group operations that transform the first jump in the jump</span>
<span class="sd">        network into all of the other members; one group operation for each.</span>

<span class="sd">        :return siteGroupOps: list of list of group ops that mirrors the structure of jumpnetwork.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">groupops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">jumps</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork</span><span class="p">:</span>
            <span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">j0</span><span class="p">),</span> <span class="n">dx0</span> <span class="o">=</span> <span class="n">jumps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">oplist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dx</span> <span class="ow">in</span> <span class="n">jumps</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">G</span><span class="p">:</span>
                    <span class="c1"># more complex: have to check the tuple (i,j) *and* the rotation of dx</span>
                    <span class="c1"># AND against the possibility that we are looking at the reverse jump too</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">indexmap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">][</span><span class="n">i0</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span>
                        <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">indexmap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">][</span><span class="n">j0</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span>
                        <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">cartrot</span><span class="p">,</span> <span class="n">dx0</span><span class="p">),</span> <span class="n">atol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">))</span> <span class="ow">or</span> \
                            <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">indexmap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">][</span><span class="n">i0</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span>
                             <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">indexmap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">][</span><span class="n">j0</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span>
                             <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">cartrot</span><span class="p">,</span> <span class="n">dx0</span><span class="p">),</span> <span class="n">atol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)):</span>
                        <span class="n">oplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                        <span class="k">break</span>
            <span class="n">groupops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oplist</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">groupops</span></div>

<div class="viewcode-block" id="Interstitial.generateSiteSymmTensorBasis"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.Interstitial.generateSiteSymmTensorBasis">[docs]</a>    <span class="k">def</span> <span class="nf">generateSiteSymmTensorBasis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a list of symmetric tensor bases for the first representative site</span>
<span class="sd">        in our site list.</span>

<span class="sd">        :return TensorSet: list of symmetric tensors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">SymmTensorBasis</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">,</span> <span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="k">for</span> <span class="n">sites</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">]</span></div>

<div class="viewcode-block" id="Interstitial.generateJumpSymmTensorBasis"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.Interstitial.generateJumpSymmTensorBasis">[docs]</a>    <span class="k">def</span> <span class="nf">generateJumpSymmTensorBasis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a list of symmetric tensor bases for the first representative transition</span>
<span class="sd">        in our jump network</span>

<span class="sd">        :return TensorSet: list of list of symmetric tensors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># there is probably another way to do a list comprehension here, but that</span>
        <span class="c1"># will likely be nigh unreadable.</span>
        <span class="n">lis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">jumps</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork</span><span class="p">:</span>
            <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">jumps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># more complex: have to check the tuple (i,j) *and* the rotation of dx</span>
            <span class="c1"># AND against the possibility that we are looking at the reverse jump too</span>
            <span class="n">lis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reduce</span><span class="p">(</span><span class="n">crystal</span><span class="o">.</span><span class="n">CombineTensorBasis</span><span class="p">,</span>
                              <span class="p">[</span><span class="n">crystal</span><span class="o">.</span><span class="n">SymmTensorBasis</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">eigen</span><span class="p">())</span>
                               <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">G</span>
                               <span class="k">if</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">indexmap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span> <span class="ow">and</span>
                                   <span class="n">g</span><span class="o">.</span><span class="n">indexmap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span> <span class="ow">and</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">cartrot</span><span class="p">,</span> <span class="n">dx</span><span class="p">),</span> <span class="n">atol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">))</span> <span class="ow">or</span>
                               <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">indexmap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span> <span class="ow">and</span>
                                <span class="n">g</span><span class="o">.</span><span class="n">indexmap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span> <span class="ow">and</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">cartrot</span><span class="p">,</span> <span class="n">dx</span><span class="p">),</span> <span class="n">atol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">))]))</span>
        <span class="k">return</span> <span class="n">lis</span></div>

<div class="viewcode-block" id="Interstitial.siteprob"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.Interstitial.siteprob">[docs]</a>    <span class="k">def</span> <span class="nf">siteprob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">betaene</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns our site probabilities, normalized, as a vector&quot;&quot;&quot;</span>
        <span class="c1"># be careful to make sure that we don&#39;t under-/over-flow on beta*ene</span>
        <span class="n">minbetaene</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">betaene</span><span class="p">)</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pre</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">minbetaene</span> <span class="o">-</span> <span class="n">betaene</span><span class="p">[</span><span class="n">w</span><span class="p">])</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">invmap</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">rho</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span></div>

<div class="viewcode-block" id="Interstitial.ratelist"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.Interstitial.ratelist">[docs]</a>    <span class="k">def</span> <span class="nf">ratelist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">betaene</span><span class="p">,</span> <span class="n">preT</span><span class="p">,</span> <span class="n">betaeneT</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of lists of rates, matched to jumpnetwork&quot;&quot;&quot;</span>
        <span class="c1"># the ij tuple in each transition list is the i-&gt;j pair</span>
        <span class="c1"># invmap[i] tells you which Wyckoff position i maps to (in the sitelist)</span>
        <span class="c1"># trying to avoid under-/over-flow</span>
        <span class="n">siteene</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">betaene</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">invmap</span><span class="p">])</span>
        <span class="n">sitepre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pre</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">invmap</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">[[</span><span class="n">pT</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">siteene</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">beT</span><span class="p">)</span> <span class="o">/</span> <span class="n">sitepre</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                 <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dx</span> <span class="ow">in</span> <span class="n">t</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">pT</span><span class="p">,</span> <span class="n">beT</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">preT</span><span class="p">,</span> <span class="n">betaeneT</span><span class="p">)]</span></div>

<div class="viewcode-block" id="Interstitial.symmratelist"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.Interstitial.symmratelist">[docs]</a>    <span class="k">def</span> <span class="nf">symmratelist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">betaene</span><span class="p">,</span> <span class="n">preT</span><span class="p">,</span> <span class="n">betaeneT</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of lists of symmetrized rates, matched to jumpnetwork&quot;&quot;&quot;</span>
        <span class="c1"># the ij tuple in each transition list is the i-&gt;j pair</span>
        <span class="c1"># invmap[i] tells you which Wyckoff position i maps to (in the sitelist)</span>
        <span class="c1"># trying to avoid under-/over-flow</span>
        <span class="n">siteene</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">betaene</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">invmap</span><span class="p">])</span>
        <span class="n">sitepre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pre</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">invmap</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">[[</span><span class="n">pT</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">siteene</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">siteene</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">beT</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sitepre</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sitepre</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                 <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dx</span> <span class="ow">in</span> <span class="n">t</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">pT</span><span class="p">,</span> <span class="n">beT</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">preT</span><span class="p">,</span> <span class="n">betaeneT</span><span class="p">)]</span></div>

<div class="viewcode-block" id="Interstitial.siteDipoles"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.Interstitial.siteDipoles">[docs]</a>    <span class="k">def</span> <span class="nf">siteDipoles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dipoles</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of the elastic dipole on each site, given the dipoles</span>
<span class="sd">        for the representatives. (&quot;populating&quot; the full set of dipoles)</span>

<span class="sd">        :param dipoles: list of dipoles for the first representative site</span>
<span class="sd">        :return dipolelist: array of dipole for each site [site][3][3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># difficult to do with list comprehension since we&#39;re mapping from Wyckoff positions</span>
        <span class="c1"># to site indices; need to create the &quot;blank&quot; list first, then map into it.</span>
        <span class="n">lis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>  <span class="c1"># blank list to index into</span>
        <span class="k">for</span> <span class="n">dipole</span><span class="p">,</span> <span class="n">basis</span><span class="p">,</span> <span class="n">sites</span><span class="p">,</span> <span class="n">groupops</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dipoles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">siteSymmTensorBasis</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sitegroupops</span><span class="p">):</span>
            <span class="n">symmdipole</span> <span class="o">=</span> <span class="n">crystal</span><span class="o">.</span><span class="n">ProjectTensorBasis</span><span class="p">(</span><span class="n">dipole</span><span class="p">,</span> <span class="n">basis</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sites</span><span class="p">,</span> <span class="n">groupops</span><span class="p">):</span>
                <span class="n">lis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">g_tensor</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">symmdipole</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lis</span></div>
        <span class="c1"># return [ dipoles[w] for i,w in enumerate(self.invmap) ]</span>

<div class="viewcode-block" id="Interstitial.jumpDipoles"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.Interstitial.jumpDipoles">[docs]</a>    <span class="k">def</span> <span class="nf">jumpDipoles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dipoles</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of the elastic dipole for each transition, given the dipoles</span>
<span class="sd">        for the representatives. (&quot;populating&quot; the full set of dipoles)</span>

<span class="sd">        :param dipoles: list of dipoles for the first representative transition</span>
<span class="sd">        :return dipolelist: list of lists of dipole for each jump[site][3][3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># symmetrize them first via projection</span>
        <span class="n">symmdipoles</span> <span class="o">=</span> <span class="p">[</span><span class="n">crystal</span><span class="o">.</span><span class="n">ProjectTensorBasis</span><span class="p">(</span><span class="n">dipole</span><span class="p">,</span> <span class="n">basis</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">dipole</span><span class="p">,</span> <span class="n">basis</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dipoles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">jumpSymmTensorBasis</span><span class="p">)]</span>
        <span class="k">return</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">g_tensor</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">dipole</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groupops</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">groupops</span><span class="p">,</span> <span class="n">dipole</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumpgroupops</span><span class="p">,</span> <span class="n">symmdipoles</span><span class="p">)]</span></div>

<div class="viewcode-block" id="Interstitial.diffusivity"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.Interstitial.diffusivity">[docs]</a>    <span class="k">def</span> <span class="nf">diffusivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">betaene</span><span class="p">,</span> <span class="n">preT</span><span class="p">,</span> <span class="n">betaeneT</span><span class="p">,</span> <span class="n">CalcDeriv</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the diffusivity for our element given prefactors and energies/kB T.</span>
<span class="sd">        Also returns the negative derivative of diffusivity with respect to beta (used to compute</span>
<span class="sd">        the activation barrier tensor) if CalcDeriv = True</span>
<span class="sd">        The input list order corresponds to the sitelist and jumpnetwork</span>

<span class="sd">        :param pre: list of prefactors for unique sites</span>
<span class="sd">        :param betaene: list of site energies divided by kB T</span>
<span class="sd">        :param preT: list of prefactors for transition states</span>
<span class="sd">        :param betaeneT: list of transition state energies divided by kB T</span>
<span class="sd">        :return D[3,3]: diffusivity as a 3x3 tensor</span>
<span class="sd">        :return DE[3,3]: diffusivity times activation barrier (if CalcDeriv == True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pre</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;length of prefactor </span><span class="si">{}</span><span class="s2"> doesn&#39;t match sitelist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pre</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">betaene</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;length of energies </span><span class="si">{}</span><span class="s2"> doesn&#39;t match sitelist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">betaene</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">preT</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;length of prefactor </span><span class="si">{}</span><span class="s2"> doesn&#39;t match jump network&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">preT</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">betaeneT</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;length of energies </span><span class="si">{}</span><span class="s2"> doesn&#39;t match jump network&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">betaeneT</span><span class="p">))</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">siteprob</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">betaene</span><span class="p">)</span>
        <span class="n">sqrtrho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
        <span class="n">ratelist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratelist</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">betaene</span><span class="p">,</span> <span class="n">preT</span><span class="p">,</span> <span class="n">betaeneT</span><span class="p">)</span>
        <span class="n">symmratelist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmratelist</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">betaene</span><span class="p">,</span> <span class="n">preT</span><span class="p">,</span> <span class="n">betaeneT</span><span class="p">)</span>
        <span class="n">omega_ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span>
        <span class="n">domega_ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span>
        <span class="n">bias_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">dbias_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">D0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">Dcorrection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">Db</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="c1"># bookkeeping for energies:</span>
        <span class="n">siteene</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">betaene</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">invmap</span><span class="p">])</span>
        <span class="c1"># transene = [ [ bET for (i,j), dx in t ] for t, bET in zip(self.jumpnetwork, betaeneT)]</span>
        <span class="n">Eave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">siteene</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">transitionset</span><span class="p">,</span> <span class="n">rates</span><span class="p">,</span> <span class="n">symmrates</span><span class="p">,</span> <span class="n">bET</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">ratelist</span><span class="p">,</span> <span class="n">symmratelist</span><span class="p">,</span> <span class="n">betaeneT</span><span class="p">):</span>
            <span class="k">for</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dx</span><span class="p">),</span> <span class="n">rate</span><span class="p">,</span> <span class="n">symmrate</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">transitionset</span><span class="p">,</span> <span class="n">rates</span><span class="p">,</span> <span class="n">symmrates</span><span class="p">):</span>
                <span class="c1"># symmrate = sqrtrho[i]*invsqrtrho[j]*rate</span>
                <span class="n">omega_ij</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">symmrate</span>
                <span class="n">omega_ij</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">rate</span>
                <span class="n">domega_ij</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">symmrate</span> <span class="o">*</span> <span class="p">(</span><span class="n">bET</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">siteene</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">siteene</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                <span class="n">domega_ij</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">rate</span> <span class="o">*</span> <span class="p">(</span><span class="n">bET</span> <span class="o">-</span> <span class="n">siteene</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">bias_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sqrtrho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">rate</span> <span class="o">*</span> <span class="n">dx</span>
                <span class="n">dbias_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sqrtrho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">rate</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">*</span> <span class="p">(</span><span class="n">bET</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">siteene</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">Eave</span><span class="p">))</span>
                <span class="n">D0</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">rate</span>
                <span class="n">Db</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">rate</span> <span class="o">*</span> <span class="p">(</span><span class="n">bET</span> <span class="o">-</span> <span class="n">Eave</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NV</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># NOTE: there&#39;s probably a SUPER clever way to do this with higher dimensional arrays and dot...</span>
            <span class="n">omega_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">NV</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">NV</span><span class="p">))</span>
            <span class="n">domega_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">NV</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">NV</span><span class="p">))</span>
            <span class="n">bias_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NV</span><span class="p">)</span>
            <span class="n">dbias_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NV</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">va</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">VectorBasis</span><span class="p">):</span>
                <span class="n">bias_v</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bias_i</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">va</span><span class="p">))</span>
                <span class="n">dbias_v</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dbias_i</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">va</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">vb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">VectorBasis</span><span class="p">):</span>
                    <span class="n">omega_v</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">va</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">omega_ij</span><span class="p">,</span> <span class="n">vb</span><span class="p">)))</span>
                    <span class="n">domega_v</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">va</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">domega_ij</span><span class="p">,</span> <span class="n">vb</span><span class="p">)))</span>
            <span class="n">gamma_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias_solver</span><span class="p">(</span><span class="n">omega_v</span><span class="p">,</span> <span class="n">bias_v</span><span class="p">)</span>
            <span class="n">dgamma_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">domega_v</span><span class="p">,</span> <span class="n">gamma_v</span><span class="p">)</span>
            <span class="n">Dcorrection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">VV</span><span class="p">,</span> <span class="n">bias_v</span><span class="p">),</span> <span class="n">gamma_v</span><span class="p">)</span>
            <span class="n">Db</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">VV</span><span class="p">,</span> <span class="n">dbias_v</span><span class="p">),</span> <span class="n">gamma_v</span><span class="p">)</span> \
                  <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">VV</span><span class="p">,</span> <span class="n">gamma_v</span><span class="p">),</span> <span class="n">dbias_v</span><span class="p">)</span> \
                  <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">VV</span><span class="p">,</span> <span class="n">gamma_v</span><span class="p">),</span> <span class="n">dgamma_v</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">CalcDeriv</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">D0</span> <span class="o">+</span> <span class="n">Dcorrection</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">D0</span> <span class="o">+</span> <span class="n">Dcorrection</span><span class="p">,</span> <span class="n">Db</span></div>

<div class="viewcode-block" id="Interstitial.elastodiffusion"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.Interstitial.elastodiffusion">[docs]</a>    <span class="k">def</span> <span class="nf">elastodiffusion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">betaene</span><span class="p">,</span> <span class="n">dipole</span><span class="p">,</span> <span class="n">preT</span><span class="p">,</span> <span class="n">betaeneT</span><span class="p">,</span> <span class="n">dipoleT</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the elastodiffusion tensor for our element given prefactors, energies/kB T,</span>
<span class="sd">        and elastic dipoles/kB T</span>
<span class="sd">        The input list order corresponds to the sitelist and jumpnetwork</span>

<span class="sd">        :param pre: list of prefactors for unique sites</span>
<span class="sd">        :param betaene: list of site energies divided by kB T</span>
<span class="sd">        :param dipole: list of elastic dipoles divided by kB T</span>
<span class="sd">        :param preT: list of prefactors for transition states</span>
<span class="sd">        :param betaeneT: list of transition state energies divided by kB T</span>
<span class="sd">        :param dipoleT: list of elastic dipoles divided by kB T</span>
<span class="sd">        :return D[3,3]: diffusivity as 3x3 tensor</span>
<span class="sd">        :return dD[3,3,3,3]: elastodiffusion tensor as 3x3x3x3 tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">vector_tensor_outer</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Construct the outer product of v and a&quot;&quot;&quot;</span>
            <span class="n">va</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">va</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">va</span>

        <span class="k">def</span> <span class="nf">tensor_tensor_outer</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Construct the outer product of a and b&quot;&quot;&quot;</span>
            <span class="n">ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
                <span class="n">ab</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">ab</span>

        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pre</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;length of prefactor </span><span class="si">{}</span><span class="s2"> doesn&#39;t match sitelist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pre</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">betaene</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;length of energies </span><span class="si">{}</span><span class="s2"> doesn&#39;t match sitelist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">betaene</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dipole</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;length of dipoles </span><span class="si">{}</span><span class="s2"> doesn&#39;t match sitelist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dipole</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">preT</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;length of prefactor </span><span class="si">{}</span><span class="s2"> doesn&#39;t match jump network&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">preT</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">betaeneT</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;length of energies </span><span class="si">{}</span><span class="s2"> doesn&#39;t match jump network&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">betaeneT</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dipoleT</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;length of dipoles </span><span class="si">{}</span><span class="s2"> doesn&#39;t match jump network&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dipoleT</span><span class="p">))</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">siteprob</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">betaene</span><span class="p">)</span>
        <span class="n">sqrtrho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
        <span class="n">ratelist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratelist</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">betaene</span><span class="p">,</span> <span class="n">preT</span><span class="p">,</span> <span class="n">betaeneT</span><span class="p">)</span>
        <span class="n">symmratelist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmratelist</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">betaene</span><span class="p">,</span> <span class="n">preT</span><span class="p">,</span> <span class="n">betaeneT</span><span class="p">)</span>
        <span class="n">omega_ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span>
        <span class="n">bias_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">biasP_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">domega_ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">sitedipoles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">siteDipoles</span><span class="p">(</span><span class="n">dipole</span><span class="p">)</span>
        <span class="n">jumpdipoles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jumpDipoles</span><span class="p">(</span><span class="n">dipoleT</span><span class="p">)</span>
        <span class="n">dipoleave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">sitedipoles</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">)])</span>  <span class="c1"># average dipole</span>

        <span class="n">D0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">Dp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">transitionset</span><span class="p">,</span> <span class="n">rates</span><span class="p">,</span> <span class="n">symmrates</span><span class="p">,</span> <span class="n">dipoles</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">ratelist</span><span class="p">,</span> <span class="n">symmratelist</span><span class="p">,</span> <span class="n">jumpdipoles</span><span class="p">):</span>
            <span class="k">for</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dx</span><span class="p">),</span> <span class="n">rate</span><span class="p">,</span> <span class="n">symmrate</span><span class="p">,</span> <span class="n">dipole</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">transitionset</span><span class="p">,</span> <span class="n">rates</span><span class="p">,</span> <span class="n">symmrates</span><span class="p">,</span> <span class="n">dipoles</span><span class="p">):</span>
                <span class="c1"># symmrate = sqrtrho[i]*invsqrtrho[j]*rate</span>
                <span class="n">omega_ij</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">symmrate</span>
                <span class="n">omega_ij</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">rate</span>
                <span class="n">domega_ij</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="n">symmrate</span> <span class="o">*</span> <span class="p">(</span><span class="n">dipole</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">sitedipoles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">sitedipoles</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                <span class="n">domega_ij</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rate</span> <span class="o">*</span> <span class="p">(</span><span class="n">dipole</span> <span class="o">-</span> <span class="n">sitedipoles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">bias_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sqrtrho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">rate</span> <span class="o">*</span> <span class="n">dx</span>
                <span class="n">biasP_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">vector_tensor_outer</span><span class="p">(</span><span class="n">sqrtrho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">rate</span> <span class="o">*</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dipole</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">sitedipoles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dipoleave</span><span class="p">))</span>
                <span class="n">D0</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">rate</span>
                <span class="n">Dp</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">tensor_tensor_outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">rate</span><span class="p">,</span> <span class="n">dipole</span> <span class="o">-</span> <span class="n">dipoleave</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NV</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">omega_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">NV</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">NV</span><span class="p">))</span>
            <span class="n">bias_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NV</span><span class="p">)</span>
            <span class="n">domega_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">NV</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">NV</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
            <span class="c1"># NOTE: there&#39;s probably a SUPER clever way to do this with higher dimensional arrays and dot...</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">va</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">VectorBasis</span><span class="p">):</span>
                <span class="n">bias_v</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">bias_i</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>  <span class="c1"># can also use trace(dot(bias_i.T, va))</span>
                <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">vb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">VectorBasis</span><span class="p">):</span>
                    <span class="n">omega_v</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">va</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">omega_ij</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="p">((</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">))),</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
                    <span class="n">domega_v</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">va</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">domega_ij</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="p">((</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">))),</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
            <span class="n">gamma_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias_solver</span><span class="p">(</span><span class="n">omega_v</span><span class="p">,</span> <span class="n">bias_v</span><span class="p">)</span>
            <span class="n">dg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">domega_v</span><span class="p">,</span> <span class="n">gamma_v</span><span class="p">,</span> <span class="p">((</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
            <span class="c1"># need to project gamma_v *back onto* our sites; not sure if we can just do with a dot since</span>
            <span class="c1"># self.VectorBasis is a list of Nx3 matrices</span>
            <span class="n">gamma_i</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">g</span> <span class="o">*</span> <span class="n">va</span> <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">va</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gamma_v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">VectorBasis</span><span class="p">))</span>
            <span class="n">D0</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">VV</span><span class="p">,</span> <span class="n">bias_v</span><span class="p">),</span> <span class="n">gamma_v</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">Dp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">gamma_i</span><span class="p">,</span> <span class="n">biasP_i</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">],</span> <span class="p">((</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">)))</span> <span class="o">+</span> \
                                  <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">biasP_i</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">],</span> <span class="n">gamma_i</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
            <span class="n">Dp</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">VV</span><span class="p">,</span> <span class="n">gamma_v</span><span class="p">,</span> <span class="p">((</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">))),</span> <span class="n">dg</span><span class="p">,</span> <span class="p">((</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">c</span><span class="p">:</span>
                <span class="n">Dp</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">D0</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">Dp</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">D0</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">c</span><span class="p">:</span>
                <span class="n">Dp</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">D0</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">Dp</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">D0</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">D0</span><span class="p">,</span> <span class="n">Dp</span></div>

<div class="viewcode-block" id="Interstitial.losstensors"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.Interstitial.losstensors">[docs]</a>    <span class="k">def</span> <span class="nf">losstensors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">betaene</span><span class="p">,</span> <span class="n">dipole</span><span class="p">,</span> <span class="n">preT</span><span class="p">,</span> <span class="n">betaeneT</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the internal friction loss tensors for our element given prefactors, energies/kB T,</span>
<span class="sd">        and elastic dipoles/kB T</span>
<span class="sd">        The input list order corresponds to the sitelist and jumpnetwork</span>

<span class="sd">        :param pre: list of prefactors for unique sites</span>
<span class="sd">        :param betaene: list of site energies divided by kB T</span>
<span class="sd">        :param dipole: list of elastic dipoles divided by kB T</span>
<span class="sd">        :param preT: list of prefactors for transition states</span>
<span class="sd">        :param betaeneT: list of transition state energies divided by kB T</span>
<span class="sd">        :return lambdaL: list of tuples of (eigenmode, L-tensor) where L-tensor is a 3x3x3x3 loss tensor</span>
<span class="sd">            L-tensor needs to be multiplied by kB T to have proper units of energy.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">tensor_square</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Construct the outer product of a with itself&quot;&quot;&quot;</span>
            <span class="n">aa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
                <span class="n">aa</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">aa</span>

        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pre</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;length of prefactor </span><span class="si">{}</span><span class="s2"> doesn&#39;t match sitelist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pre</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">betaene</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;length of energies </span><span class="si">{}</span><span class="s2"> doesn&#39;t match sitelist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">betaene</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dipole</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;length of dipoles </span><span class="si">{}</span><span class="s2"> doesn&#39;t match sitelist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dipole</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">preT</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;length of prefactor </span><span class="si">{}</span><span class="s2"> doesn&#39;t match jump network&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">preT</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">betaeneT</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;length of energies </span><span class="si">{}</span><span class="s2"> doesn&#39;t match jump network&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">betaeneT</span><span class="p">))</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">siteprob</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">betaene</span><span class="p">)</span>
        <span class="n">sqrtrho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
        <span class="n">ratelist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratelist</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">betaene</span><span class="p">,</span> <span class="n">preT</span><span class="p">,</span> <span class="n">betaeneT</span><span class="p">)</span>
        <span class="n">symmratelist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmratelist</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">betaene</span><span class="p">,</span> <span class="n">preT</span><span class="p">,</span> <span class="n">betaeneT</span><span class="p">)</span>
        <span class="n">omega_ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span>
        <span class="n">sitedipoles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">siteDipoles</span><span class="p">(</span><span class="n">dipole</span><span class="p">)</span>

        <span class="c1"># populate our symmetrized transition matrix:</span>
        <span class="k">for</span> <span class="n">transitionset</span><span class="p">,</span> <span class="n">rates</span><span class="p">,</span> <span class="n">symmrates</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">ratelist</span><span class="p">,</span> <span class="n">symmratelist</span><span class="p">):</span>
            <span class="k">for</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dx</span><span class="p">),</span> <span class="n">rate</span><span class="p">,</span> <span class="n">symmrate</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">transitionset</span><span class="p">,</span> <span class="n">rates</span><span class="p">,</span> <span class="n">symmrates</span><span class="p">):</span>
                <span class="c1"># symmrate = sqrtrho[i]*invsqrtrho[j]*rate</span>
                <span class="n">omega_ij</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">symmrate</span>
                <span class="n">omega_ij</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">rate</span>
        <span class="c1"># next, diagonalize:</span>
        <span class="c1"># lamb: eigenvalues, in ascending order, with eigenvalues phi</span>
        <span class="c1"># then, the *largest* should be lamb = 0</span>
        <span class="n">lamb</span><span class="p">,</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">omega_ij</span><span class="p">)</span>
        <span class="n">averate</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">omega_ij</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="n">lambdaL</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># work through the eigenvalues / vectors individually:</span>
        <span class="c1"># NOTE: we should have a negative definite matrix, so negate those eigenvalues...</span>
        <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">-</span><span class="n">lamb</span><span class="p">,</span> <span class="n">phi</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
            <span class="c1"># need to check if lamb is (approximately) 0. Can also check if p is close to sqrtrho</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="o">*</span><span class="n">averate</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">sqrtrho</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span> <span class="k">continue</span>
            <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">sqrtrho</span><span class="p">,</span> <span class="n">sitedipoles</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">tensor_square</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
            <span class="c1"># determine if we have a new mode or not</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">lamb0</span><span class="p">,</span> <span class="n">L0</span><span class="p">)</span> <span class="ow">in</span> <span class="n">lambdaL</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">lamb0</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
                    <span class="n">L0</span> <span class="o">+=</span> <span class="n">L</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
                <span class="n">lambdaL</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">L</span><span class="p">))</span>
        <span class="c1"># pass back list</span>
        <span class="k">return</span> <span class="n">lambdaL</span></div></div>


<span class="c1"># YAML tags</span>
<span class="n">VACANCYTHERMOKINETICS_YAMLTAG</span> <span class="o">=</span> <span class="s1">&#39;!VacancyThermoKinetics&#39;</span>


<div class="viewcode-block" id="vacancyThermoKinetics"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.vacancyThermoKinetics">[docs]</a><span class="k">class</span> <span class="nc">vacancyThermoKinetics</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;vacancyThermoKinetics&#39;</span><span class="p">,</span>
                                                   <span class="s1">&#39;pre betaene preT betaeneT&#39;</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to store (in a hashable manner) the thermodynamics and kinetics for the vacancy</span>

<span class="sd">    :param pre: prefactors for sites</span>
<span class="sd">    :param betaene: energy for sites / kBT</span>
<span class="sd">    :param preT: prefactors for transition states</span>
<span class="sd">    :param betaeneT: transition state energy for sites / kBT</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="vacancyThermoKinetics.__repr__"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.vacancyThermoKinetics.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(pre=</span><span class="si">{}</span><span class="s2">, betaene=</span><span class="si">{}</span><span class="s2">, preT=</span><span class="si">{}</span><span class="s2">, betaeneT=</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                                                     <span class="bp">self</span><span class="o">.</span><span class="n">pre</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">betaene</span><span class="p">,</span>
                                                                     <span class="bp">self</span><span class="o">.</span><span class="n">preT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">betaeneT</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a proper dict&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;pre&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre</span><span class="p">,</span> <span class="s1">&#39;betaene&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">betaene</span><span class="p">,</span> <span class="s1">&#39;preT&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">preT</span><span class="p">,</span> <span class="s1">&#39;betaeneT&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">betaeneT</span><span class="p">}</span>

<div class="viewcode-block" id="vacancyThermoKinetics.__eq__"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.vacancyThermoKinetics.__eq__">[docs]</a>    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Note: could scale all prefactors by min(pre) and subtract all energies by min(ene)...?</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pre</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">pre</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">betaene</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">betaene</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preT</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">preT</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">betaeneT</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">betaeneT</span><span class="p">)</span></div>

<div class="viewcode-block" id="vacancyThermoKinetics.__ne__"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.vacancyThermoKinetics.__ne__">[docs]</a>    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="vacancyThermoKinetics.__hash__"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.vacancyThermoKinetics.__hash__">[docs]</a>    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pre</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">betaene</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span> <span class="o">+</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">preT</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">betaeneT</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span></div>

<div class="viewcode-block" id="vacancyThermoKinetics.vacancyThermoKinetics_representer"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.vacancyThermoKinetics.vacancyThermoKinetics_representer">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">vacancyThermoKinetics_representer</span><span class="p">(</span><span class="n">dumper</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Output a PairState&quot;&quot;&quot;</span>
        <span class="c1"># asdict() returns an OrderedDictionary, so pass through dict()</span>
        <span class="c1"># had to rewrite _asdict() for some reason...?</span>
        <span class="k">return</span> <span class="n">dumper</span><span class="o">.</span><span class="n">represent_mapping</span><span class="p">(</span><span class="n">VACANCYTHERMOKINETICS_YAMLTAG</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">_asdict</span><span class="p">())</span></div>

<div class="viewcode-block" id="vacancyThermoKinetics.vacancyThermoKinetics_constructor"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.vacancyThermoKinetics.vacancyThermoKinetics_constructor">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">vacancyThermoKinetics_constructor</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a GroupOp from YAML&quot;&quot;&quot;</span>
        <span class="c1"># ** turns the dictionary into parameters for GroupOp constructor</span>
        <span class="k">return</span> <span class="n">vacancyThermoKinetics</span><span class="p">(</span><span class="o">**</span><span class="n">loader</span><span class="o">.</span><span class="n">construct_mapping</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></div></div>


<span class="c1"># HDF5 conversion routines: vTK indexed dictionaries</span>
<div class="viewcode-block" id="vTKdict2arrays"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.vTKdict2arrays">[docs]</a><span class="k">def</span> <span class="nf">vTKdict2arrays</span><span class="p">(</span><span class="n">vTKdict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a dictionary indexed by vTK objects, returns two arrays of vTK keys and values,</span>
<span class="sd">    and the splits to separate vTKarray back into vTK</span>

<span class="sd">    :param vTKdict: dictionary, indexed by vTK objects, whose entries are arrays</span>
<span class="sd">    :return vTKarray: array of vTK entries</span>
<span class="sd">    :return valarray: array of values</span>
<span class="sd">    :return vTKsplits: split placement for vTK entries</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vTKdict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">vTKexample</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">vTKdict</span><span class="o">.</span><span class="n">keys</span><span class="p">()][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">vTKsplits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vTKexample</span><span class="p">]))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">vTKlist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">vallist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vTKdict</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">vTKdict</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        <span class="n">vTKlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>  <span class="c1"># k.pre, k.betaene, k.preT, k.betaeneT</span>
        <span class="n">vallist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vTKlist</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vallist</span><span class="p">),</span> <span class="n">vTKsplits</span></div>


<div class="viewcode-block" id="arrays2vTKdict"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.arrays2vTKdict">[docs]</a><span class="k">def</span> <span class="nf">arrays2vTKdict</span><span class="p">(</span><span class="n">vTKarray</span><span class="p">,</span> <span class="n">valarray</span><span class="p">,</span> <span class="n">vTKsplits</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes two arrays of vTK keys and values, and the splits to separate vTKarray back into vTK</span>
<span class="sd">    and returns a dictionary indexed by the vTK.</span>

<span class="sd">    :param vTKarray: array of vTK entries</span>
<span class="sd">    :param valarray: array of values</span>
<span class="sd">    :param vTKsplits: split placement for vTK entries</span>
<span class="sd">    :return vTKdict: dictionary, indexed by vTK objects, whose entries are arrays</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">vTKarray</span><span class="p">,</span> <span class="n">valarray</span><span class="p">,</span> <span class="n">vTKsplits</span><span class="p">)):</span> <span class="k">return</span> <span class="p">{}</span>
    <span class="n">vTKdict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">vTKa</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vTKarray</span><span class="p">,</span> <span class="n">valarray</span><span class="p">):</span>
        <span class="n">vTKdict</span><span class="p">[</span><span class="n">vacancyThermoKinetics</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">hsplit</span><span class="p">(</span><span class="n">vTKa</span><span class="p">,</span> <span class="n">vTKsplits</span><span class="p">))]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">return</span> <span class="n">vTKdict</span></div>


<div class="viewcode-block" id="VacancyMediated"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.VacancyMediated">[docs]</a><span class="k">class</span> <span class="nc">VacancyMediated</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to compute vacancy-mediated solute transport coefficients, specifically</span>
<span class="sd">    L_vv (vacancy diffusion), L_ss (solute), and L_sv (off-diagonal). As part of that,</span>
<span class="sd">    it determines *what* quantities are needed as inputs in order to perform this calculation.</span>

<span class="sd">    Based on crystal class. Also now includes its own GF calculator and cacheing, and</span>
<span class="sd">    storage in HDF5 format.</span>

<span class="sd">    Requires a crystal, chemical identity of vacancy, list of symmetry-equivalent</span>
<span class="sd">    sites for that chemistry, and a jumpnetwork for the vacancy. The thermodynamic</span>
<span class="sd">    range (number of &quot;shells&quot; -- see ``crystalStars.StarSet`` for precise definition).</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="VacancyMediated.__init__"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.VacancyMediated.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crys</span><span class="p">,</span> <span class="n">chem</span><span class="p">,</span> <span class="n">sitelist</span><span class="p">,</span> <span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">Nthermo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">NGFmax</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create our diffusion calculator for a given crystal structure, chemical identity,</span>
<span class="sd">        jumpnetwork (for the vacancy) and thermodynamic shell.</span>

<span class="sd">        :param crys: Crystal object</span>
<span class="sd">        :param chem: index identifying the diffusing species</span>
<span class="sd">        :param sitelist: list, grouped into Wyckoff common positions, of unique sites</span>
<span class="sd">        :param jumpnetwork: list of unique transitions as lists of ((i,j), dx)</span>
<span class="sd">        :param Nthermo: range of thermodynamic interaction (in successive jumpnetworks)</span>
<span class="sd">        :param NGFmax: parameter controlling k-point density of GF calculator; 4 seems reasonably accurate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">crys</span><span class="p">,</span> <span class="n">chem</span><span class="p">,</span> <span class="n">sitelist</span><span class="p">,</span> <span class="n">jumpnetwork</span><span class="p">)):</span> <span class="k">return</span>  <span class="c1"># blank object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crys</span> <span class="o">=</span> <span class="n">crys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="n">crys</span><span class="o">.</span><span class="n">dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chem</span> <span class="o">=</span> <span class="n">chem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">sitelist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">jumpnetwork</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">sitelist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sitelist</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">w</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">invmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">om0_jn</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">jumpnetwork</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">GFcalc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GFcalculator</span><span class="p">(</span><span class="n">NGFmax</span><span class="p">)</span>
        <span class="c1"># do some initial setup:</span>
        <span class="c1"># self.thermo = stars.StarSet(self.jumpnetwork, self.crys, self.chem, Nthermo)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thermo</span> <span class="o">=</span> <span class="n">stars</span><span class="o">.</span><span class="n">StarSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">)</span>  <span class="c1"># just create; call generate later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span> <span class="o">=</span> <span class="n">stars</span><span class="o">.</span><span class="n">StarSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NNstar</span> <span class="o">=</span> <span class="n">stars</span><span class="o">.</span><span class="n">StarSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># self.kinetic = self.thermo + self.NNstar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span> <span class="o">=</span> <span class="n">stars</span><span class="o">.</span><span class="n">VectorStarSet</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">Nthermo</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generatematrices</span><span class="p">()</span>
        <span class="c1"># dict: vacancy, solute, solute-vacancy; omega0, omega1, omega2 (see __taglist__)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tagdict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tagdicttype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generatetags</span><span class="p">()</span></div>

<div class="viewcode-block" id="VacancyMediated.GFcalculator"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.VacancyMediated.GFcalculator">[docs]</a>    <span class="k">def</span> <span class="nf">GFcalculator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">NGFmax</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the GF calculator; create a new one if NGFmax is being changed&quot;&quot;&quot;</span>
        <span class="c1"># if not being set (no parameter passed) or same as what we already use, return calculator</span>
        <span class="k">if</span> <span class="n">NGFmax</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;NGFmax&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">GFcalc</span>
        <span class="k">if</span> <span class="n">NGFmax</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;NGFmax (</span><span class="si">{}</span><span class="s1">) must be &gt;0&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">NGFmax</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NGFmax</span><span class="o">=</span> <span class="n">NGFmax</span>
        <span class="c1"># empty dictionaries to store GF values: necessary if we&#39;re changing NGFmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clearcache</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">GFcalc</span><span class="o">.</span><span class="n">GFCrystalcalc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om0_jn</span><span class="p">,</span> <span class="n">NGFmax</span><span class="p">)</span></div>

<div class="viewcode-block" id="VacancyMediated.clearcache"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.VacancyMediated.clearcache">[docs]</a>    <span class="k">def</span> <span class="nf">clearcache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear out the GF cache values&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">GFvalues</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Lvvvalues</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">etavvalues</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}</span></div>

<div class="viewcode-block" id="VacancyMediated.generate"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.VacancyMediated.generate">[docs]</a>    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Nthermo</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the necessary stars, vector-stars, and jump networks based on the thermodynamic range.</span>

<span class="sd">        :param Nthermo: range of thermodynamic interactions, in terms of &quot;shells&quot;,</span>
<span class="sd">            which is multiple summations of jumpvect</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">Nthermo</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Nthermo&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nthermo</span> <span class="o">=</span> <span class="n">Nthermo</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">thermo</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">Nthermo</span><span class="p">,</span> <span class="n">originstates</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">Nthermo</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">originstates</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># now include origin states (for removal)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="p">)</span>
        <span class="c1"># TODO: check the GF calculator against the range in GFstarset to make sure its adequate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">GFexpansion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">GFstarset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">GFexpansion</span><span class="p">()</span>

        <span class="c1"># some indexing helpers:</span>
        <span class="c1"># thermo2kin maps star index in thermo to kinetic (should just be range(n), but we use this for safety)</span>
        <span class="c1"># kin2vacancy maps star index in kinetic to non-solute configuration from sitelist</span>
        <span class="c1"># outerkin is the list of stars that are in kinetic, but not in thermo</span>
        <span class="c1"># vstar2kin maps each vector star back to the corresponding star index</span>
        <span class="c1"># kin2vstar provides a list of vector stars indices corresponding to the same star index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thermo2kin</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">starindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thermo</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">thermo</span><span class="o">.</span><span class="n">stars</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kin2vacancy</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">invmap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">stars</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outerkin</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">Nstars</span><span class="p">)</span>
                         <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">thermo</span><span class="o">.</span><span class="n">stateindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">stars</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vstar2kin</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">Rs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">Rs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">vecpos</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kin2vstar</span> <span class="o">=</span> <span class="p">[[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vstar2kin</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
                          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">Nstars</span><span class="p">)]</span>
        <span class="c1"># jumpnetwork, jumptype (omega0), star-pair for jump</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">om1_jn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om1_jt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om1_SP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">jumpnetwork_omega1</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">om2_jn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om2_jt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om2_SP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">jumpnetwork_omega2</span><span class="p">()</span>
        <span class="c1"># Prune the om1 list: remove entries that have jumps between stars in outerkin:</span>
        <span class="c1"># work in reverse order so that popping is safe (and most of the offending entries are at the end</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">SP</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om1_SP</span><span class="p">))),</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om1_SP</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">SP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outerkin</span> <span class="ow">and</span> <span class="n">SP</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outerkin</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">om1_jn</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">om1_jt</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">om1_SP</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="c1"># empty dictionaries to store GF values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clearcache</span><span class="p">()</span></div>

<div class="viewcode-block" id="VacancyMediated.generatematrices"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.VacancyMediated.generatematrices">[docs]</a>    <span class="k">def</span> <span class="nf">generatematrices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates all the matrices and &quot;helper&quot; pieces, based on our jump networks.</span>
<span class="sd">        This has been separated out in case the user wants to, e.g., prune / modify the networks</span>
<span class="sd">        after they&#39;ve been created with generate(), then generatematrices() can be rerun.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Dom1_om0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Dom1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">bareexpansions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om1_jn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om1_jt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Dom2_om0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Dom2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">bareexpansions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om2_jn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om2_jt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">om1_om0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om1_om0escape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om1expansion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om1escape</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">rateexpansions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om1_jn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om1_jt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">om2_om0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om2_om0escape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om2expansion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om2escape</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">rateexpansions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om2_jn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om2_jt</span><span class="p">,</span> <span class="n">omega2</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">om1_b0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om1bias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">biasexpansions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om1_jn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om1_jt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">om2_b0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om2bias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">biasexpansions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om2_jn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om2_jt</span><span class="p">,</span> <span class="n">omega2</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">OSindices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">OSfolddown</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">OS_VB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">originstateVectorBasisfolddown</span><span class="p">(</span><span class="s1">&#39;solute&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">OSVfolddown</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">originstateVectorBasisfolddown</span><span class="p">(</span><span class="s1">&#39;vacancy&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># only need the folddown</span>

        <span class="c1"># more indexing helpers:</span>
        <span class="c1"># kineticsvWyckoff: Wyckoff position of solute and vacancy for kinetic stars</span>
        <span class="c1"># omega0vacancyWyckoff: Wyckoff positions of initial and final position in omega0 jumps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kineticsvWyckoff</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">invmap</span><span class="p">[</span><span class="n">PS</span><span class="o">.</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">invmap</span><span class="p">[</span><span class="n">PS</span><span class="o">.</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">PS</span> <span class="ow">in</span>
                                 <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">si</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">stars</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega0vacancyWyckoff</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">invmap</span><span class="p">[</span><span class="n">jumplist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">invmap</span><span class="p">[</span><span class="n">jumplist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
                                     <span class="k">for</span> <span class="n">jumplist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">om0_jn</span><span class="p">]</span></div>

<div class="viewcode-block" id="VacancyMediated.generatetags"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.VacancyMediated.generatetags">[docs]</a>    <span class="k">def</span> <span class="nf">generatetags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create tags for vacancy states, solute states, solute-vacancy complexes;</span>
<span class="sd">        omega0, omega1, and omega2 transition states.</span>

<span class="sd">        :return tags: dictionary of tags; each is a list-of-lists</span>
<span class="sd">        :return tagdict: dictionary that maps tag into the index of the corresponding list.</span>
<span class="sd">        :return tagdicttype: dictionary that maps tag into the key for the corresponding list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tags</span><span class="p">,</span> <span class="n">tagdict</span><span class="p">,</span> <span class="n">tagdicttype</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}</span>
        <span class="n">basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">]</span>  <span class="c1"># shortcut</span>

        <span class="k">def</span> <span class="nf">single_defect</span><span class="p">(</span><span class="n">DEFECT_TAG</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">SINGLE_DEFECT_TAG_3D</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="n">DEFECT_TAG</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="n">u</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> \
                    <span class="n">SINGLE_DEFECT_TAG_2D</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="n">DEFECT_TAG</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="n">u</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">double_defect</span><span class="p">(</span><span class="n">PS</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">DOUBLE_DEFECT_TAG</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> \
                <span class="n">state1</span><span class="o">=</span><span class="n">single_defect</span><span class="p">(</span><span class="n">SOLUTE_TAG</span><span class="p">,</span> <span class="n">basis</span><span class="p">[</span><span class="n">PS</span><span class="o">.</span><span class="n">i</span><span class="p">]),</span> \
                <span class="n">state2</span><span class="o">=</span><span class="n">single_defect</span><span class="p">(</span><span class="n">VACANCY_TAG</span><span class="p">,</span> <span class="n">basis</span><span class="p">[</span><span class="n">PS</span><span class="o">.</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">PS</span><span class="o">.</span><span class="n">R</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">omega1</span><span class="p">(</span><span class="n">PS1</span><span class="p">,</span> <span class="n">PS2</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">OM1_TAG</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> \
                <span class="n">solute</span><span class="o">=</span><span class="n">single_defect</span><span class="p">(</span><span class="n">SOLUTE_TAG</span><span class="p">,</span> <span class="n">basis</span><span class="p">[</span><span class="n">PS1</span><span class="o">.</span><span class="n">i</span><span class="p">]),</span>
                <span class="n">vac1</span><span class="o">=</span><span class="n">single_defect</span><span class="p">(</span><span class="n">VACANCY_TAG</span><span class="p">,</span> <span class="n">basis</span><span class="p">[</span><span class="n">PS1</span><span class="o">.</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">PS1</span><span class="o">.</span><span class="n">R</span><span class="p">),</span> \
                <span class="n">vac2</span><span class="o">=</span><span class="n">single_defect</span><span class="p">(</span><span class="n">VACANCY_TAG</span><span class="p">,</span> <span class="n">basis</span><span class="p">[</span><span class="n">PS2</span><span class="o">.</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">PS2</span><span class="o">.</span><span class="n">R</span><span class="p">))</span>

        <span class="n">tags</span><span class="p">[</span><span class="s1">&#39;vacancy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">single_defect</span><span class="p">(</span><span class="n">VACANCY_TAG</span><span class="p">,</span> <span class="n">basis</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">]</span>
                           <span class="k">for</span> <span class="n">sites</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">]</span>
        <span class="n">tags</span><span class="p">[</span><span class="s1">&#39;solute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">single_defect</span><span class="p">(</span><span class="n">SOLUTE_TAG</span><span class="p">,</span> <span class="n">basis</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">]</span>
                          <span class="k">for</span> <span class="n">sites</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">]</span>
        <span class="n">tags</span><span class="p">[</span><span class="s1">&#39;solute-vacancy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">double_defect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thermo</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">starlist</span><span class="p">]</span>
                                  <span class="k">for</span> <span class="n">starlist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">thermo</span><span class="o">.</span><span class="n">stars</span><span class="p">]</span>
        <span class="n">tags</span><span class="p">[</span><span class="s1">&#39;omega0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">OM0_TAG</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vac1</span><span class="o">=</span><span class="n">single_defect</span><span class="p">(</span><span class="n">VACANCY_TAG</span><span class="p">,</span> <span class="n">basis</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                          <span class="n">vac2</span><span class="o">=</span><span class="n">single_defect</span><span class="p">(</span><span class="n">VACANCY_TAG</span><span class="p">,</span> <span class="n">basis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx</span><span class="p">))</span>
                           <span class="k">for</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dx</span><span class="p">)</span> <span class="ow">in</span> <span class="n">jumplist</span><span class="p">]</span>
                          <span class="k">for</span> <span class="n">jumplist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">jumpnetwork2lattice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om0_jn</span><span class="p">)]</span>
        <span class="n">tags</span><span class="p">[</span><span class="s1">&#39;omega1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">omega1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                           <span class="k">for</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dx</span><span class="p">)</span> <span class="ow">in</span> <span class="n">jumplist</span><span class="p">]</span> <span class="k">for</span> <span class="n">jumplist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">om1_jn</span><span class="p">]</span>
        <span class="n">tags</span><span class="p">[</span><span class="s1">&#39;omega2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">OM2_TAG</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">complex1</span><span class="o">=</span><span class="n">double_defect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                          <span class="n">complex2</span><span class="o">=</span><span class="n">double_defect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                           <span class="k">for</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dx</span><span class="p">)</span> <span class="ow">in</span> <span class="n">jumplist</span><span class="p">]</span> <span class="k">for</span> <span class="n">jumplist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">om2_jn</span><span class="p">]</span>
        <span class="c1"># make the &quot;tagdict&quot; for quick indexing!</span>
        <span class="k">for</span> <span class="n">tagtype</span><span class="p">,</span> <span class="n">taglist</span> <span class="ow">in</span> <span class="n">tags</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tagset</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">taglist</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">tagset</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">tagdict</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Generated repeated tags? </span><span class="si">{}</span><span class="s1"> found twice.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tagdict</span><span class="p">[</span><span class="n">tag</span><span class="p">],</span> <span class="n">tagdicttype</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">tagtype</span>
        <span class="k">return</span> <span class="n">tags</span><span class="p">,</span> <span class="n">tagdict</span><span class="p">,</span> <span class="n">tagdicttype</span></div>

<div class="viewcode-block" id="VacancyMediated.__str__"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.VacancyMediated.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Human readable version of diffuser&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Diffuser for atom </span><span class="si">{}</span><span class="s2"> (</span><span class="si">{}</span><span class="s2">), Nthermo=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">,</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">chemistry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">],</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">Nthermo</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;vacancy&#39;</span><span class="p">,</span> <span class="s1">&#39;solute&#39;</span><span class="p">,</span> <span class="s1">&#39;solute-vacancy&#39;</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">t</span> <span class="o">+</span> <span class="s1">&#39; configurations:</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">taglist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">taglist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="n">t</span><span class="p">]])</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;omega0&#39;</span><span class="p">,</span> <span class="s1">&#39;omega1&#39;</span><span class="p">,</span> <span class="s1">&#39;omega2&#39;</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">t</span> <span class="o">+</span> <span class="s1">&#39; jumps:</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">taglist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">taglist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="n">t</span><span class="p">]])</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="VacancyMediated.makesupercells"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.VacancyMediated.makesupercells">[docs]</a>    <span class="k">def</span> <span class="nf">makesupercells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">super_n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Take in a supercell matrix, then generate all of the supercells needed to compute</span>
<span class="sd">        site energies and transitions (corresponding to the representatives).</span>

<span class="sd">        Note: the states are lone vacancy, lone solute, solute-vacancy complexes in</span>
<span class="sd">        our thermodynamic range. Note that there will be escape states are endpoints of</span>
<span class="sd">        some omega1 jumps. They are not relaxed, and have no pre-existing tag. They will</span>
<span class="sd">        only be output as a single endpoint of an NEB run; there may be symmetry equivalent</span>
<span class="sd">        duplicates, as we construct these supercells on an as needed basis.</span>

<span class="sd">        We&#39;ve got a few classes of warnings (from most egregious to least) that can issued</span>
<span class="sd">        if the supercell is too small; the analysis will continue despite any warnings:</span>

<span class="sd">        1. Thermodynamic shell states map to different states in supercell</span>
<span class="sd">        2. Thermodynamic shell states are not unique in supercell (multiplicity)</span>
<span class="sd">        3. Kinetic shell states map to different states in supercell</span>
<span class="sd">        4. Kinetic shell states are not unique in supercell (multiplicity)</span>

<span class="sd">        The lowest level can still be run reliably but runs the risk of errors in escape transition</span>
<span class="sd">        barriers. Extreme caution should be used if any of the other warnings are raised.</span>

<span class="sd">        :param super_n: 3x3 integer matrix to define our supercell</span>
<span class="sd">        :return superdict: dictionary of ``states``, ``transitions``, ``transmapping``,</span>
<span class="sd">            ``indices`` that correspond to dictionaries with tags; the final tag</span>
<span class="sd">            ``reference`` is the basesupercell for calculations without defects.</span>

<span class="sd">            * superdict[&#39;states&#39;][i] = supercell of state;</span>
<span class="sd">            * superdict[&#39;transitions&#39;][n] = (supercell initial, supercell final);</span>
<span class="sd">            * superdict[&#39;transmapping&#39;][n] = ((site tag, groupop, mapping), (site tag, groupop, mapping))</span>
<span class="sd">            * superdict[&#39;indices&#39;][tag] = (type, index) of tag, where tag is either a state or transition tag.</span>
<span class="sd">            * superdict[&#39;reference&#39;] = supercell reference, no defects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">### NOTE: much of this will *need* to be reimplemented for metastable states.</span>
        <span class="n">vchem</span><span class="p">,</span> <span class="n">schem</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">Nchem</span>
        <span class="n">basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">]</span>
        <span class="n">basesupercell</span> <span class="o">=</span> <span class="n">supercell</span><span class="o">.</span><span class="n">Supercell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="p">,</span> <span class="n">super_n</span><span class="p">,</span> <span class="n">Nsolute</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">basesupercell</span><span class="o">.</span><span class="n">definesolute</span><span class="p">(</span><span class="n">schem</span><span class="p">,</span> <span class="s1">&#39;solute&#39;</span><span class="p">)</span>
        <span class="c1"># check whether our cell is large enough to contain the full thermodynamic range;</span>
        <span class="c1"># also check that our escape endpoint doesn&#39;t accidentally coincide with a &quot;real&quot; state.</span>
        <span class="c1"># The check is simple: we map the dx vector for a PairState into the half cell of the supercell;</span>
        <span class="c1"># it should match exactly. If it doesn&#39;t, there are two options: it has a different magnitude</span>
        <span class="c1"># which indicates a *new* state (mapping error) or it has the same magnitude (multiplicity).</span>
        <span class="c1"># We raise the warning accordingly. We do this with all the kinetic states, and check if it&#39;s in thermo.</span>
        <span class="n">invlatt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">basesupercell</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">PS</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
            <span class="n">dxmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">basesupercell</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">crystal</span><span class="o">.</span><span class="n">inhalf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">invlatt</span><span class="p">,</span> <span class="n">PS</span><span class="o">.</span><span class="n">dx</span><span class="p">)))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">PS</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">dxmap</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">PS</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">thermo</span><span class="p">:</span>
                    <span class="n">failstate</span> <span class="o">=</span> <span class="s1">&#39;thermodynamic range&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">failstate</span> <span class="o">=</span> <span class="s1">&#39;escape endpoint&#39;</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">PS</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">PS</span><span class="o">.</span><span class="n">dx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dxmap</span><span class="p">,</span> <span class="n">dxmap</span><span class="p">),</span> <span class="n">atol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">):</span>
                    <span class="n">failtype</span> <span class="o">=</span> <span class="s1">&#39;multiplicity issue&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">failtype</span> <span class="o">=</span> <span class="s1">&#39;mapping error&#39;</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Supercell:</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s1">too small: </span><span class="si">{}</span><span class="s1"> has </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">super_n</span><span class="p">,</span> <span class="n">failstate</span><span class="p">,</span> <span class="n">failtype</span><span class="p">),</span>
                              <span class="ne">RuntimeWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># fill up the supercell with all the *other* atoms</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">atomindices</span><span class="p">:</span>
            <span class="n">basesupercell</span><span class="o">.</span><span class="n">fillperiodic</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">Wyckoff</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># for efficiency</span>
        <span class="n">superdict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;states&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;transitions&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;transmapping&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;indices&#39;</span><span class="p">:</span> <span class="p">{},</span>
                     <span class="s1">&#39;reference&#39;</span><span class="p">:</span> <span class="n">basesupercell</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">statetype</span><span class="p">,</span> <span class="n">chem</span> <span class="ow">in</span> <span class="p">((</span><span class="s1">&#39;vacancy&#39;</span><span class="p">,</span> <span class="n">vchem</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;solute&#39;</span><span class="p">,</span> <span class="n">schem</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">sites</span><span class="p">,</span> <span class="n">tags</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="n">statetype</span><span class="p">]):</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">tag</span> <span class="o">=</span> <span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">basis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">super0</span> <span class="o">=</span> <span class="n">basesupercell</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">super0</span><span class="o">.</span><span class="n">invsuper</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="o">/</span> <span class="n">super0</span><span class="o">.</span><span class="n">size</span>
                <span class="c1"># put a vacancy / solute in that single state; the &quot;first&quot; one is fine:</span>
                <span class="n">super0</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">chem</span>
                <span class="n">superdict</span><span class="p">[</span><span class="s1">&#39;states&#39;</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">super0</span>
        <span class="k">for</span> <span class="n">starlist</span><span class="p">,</span> <span class="n">tags</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thermo</span><span class="o">.</span><span class="n">stars</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="s1">&#39;solute-vacancy&#39;</span><span class="p">]):</span>
            <span class="n">PS</span><span class="p">,</span> <span class="n">tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">thermo</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">starlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">tags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">us</span><span class="p">,</span> <span class="n">uv</span> <span class="o">=</span> <span class="n">basis</span><span class="p">[</span><span class="n">PS</span><span class="o">.</span><span class="n">i</span><span class="p">],</span> <span class="n">basis</span><span class="p">[</span><span class="n">PS</span><span class="o">.</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">PS</span><span class="o">.</span><span class="n">R</span>
            <span class="n">super0</span> <span class="o">=</span> <span class="n">basesupercell</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">inds</span><span class="p">,</span> <span class="n">indv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">super0</span><span class="o">.</span><span class="n">invsuper</span><span class="p">,</span> <span class="n">us</span><span class="p">)</span> <span class="o">/</span> <span class="n">super0</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">super0</span><span class="o">.</span><span class="n">invsuper</span><span class="p">,</span> <span class="n">uv</span><span class="p">)</span> <span class="o">/</span> <span class="n">super0</span><span class="o">.</span><span class="n">size</span>
            <span class="c1"># put a solute + vacancy in that single state; the &quot;first&quot; one is fine:</span>
            <span class="n">super0</span><span class="p">[</span><span class="n">inds</span><span class="p">],</span> <span class="n">super0</span><span class="p">[</span><span class="n">indv</span><span class="p">]</span> <span class="o">=</span> <span class="n">schem</span><span class="p">,</span> <span class="n">vchem</span>
            <span class="n">superdict</span><span class="p">[</span><span class="s1">&#39;states&#39;</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">super0</span>
        <span class="k">for</span> <span class="n">jumptype</span><span class="p">,</span> <span class="n">jumpnetwork</span> <span class="ow">in</span> <span class="p">((</span><span class="s1">&#39;omega0&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om0_jn</span><span class="p">),</span>
                                      <span class="p">(</span><span class="s1">&#39;omega1&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om1_jn</span><span class="p">),</span>
                                      <span class="p">(</span><span class="s1">&#39;omega2&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om2_jn</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">jumps</span><span class="p">,</span> <span class="n">tags</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">jumpnetwork</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="n">jumptype</span><span class="p">]):</span>
                <span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">j0</span><span class="p">),</span> <span class="n">dx0</span> <span class="o">=</span> <span class="n">jumps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="n">tags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">super0</span><span class="p">,</span> <span class="n">super1</span> <span class="o">=</span> <span class="n">basesupercell</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">basesupercell</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c1"># the supercell building is a bit specific to each jump type</span>
                <span class="k">if</span> <span class="n">jumptype</span> <span class="o">==</span> <span class="s1">&#39;omega0&#39;</span><span class="p">:</span>
                    <span class="n">u0</span> <span class="o">=</span> <span class="n">basis</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span>
                    <span class="n">u1</span> <span class="o">=</span> <span class="n">u0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">invlatt</span><span class="p">,</span> <span class="n">dx0</span><span class="p">)</span>  <span class="c1"># should correspond to the j0</span>
                    <span class="n">ind0</span><span class="p">,</span> <span class="n">ind1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">super0</span><span class="o">.</span><span class="n">invsuper</span><span class="p">,</span> <span class="n">u0</span><span class="p">)</span> <span class="o">/</span> <span class="n">super0</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> \
                                 <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">super1</span><span class="o">.</span><span class="n">invsuper</span><span class="p">,</span> <span class="n">u1</span><span class="p">)</span> <span class="o">/</span> <span class="n">super1</span><span class="o">.</span><span class="n">size</span>
                    <span class="c1"># put vacancies at our corresponding sites:</span>
                    <span class="c1"># we do this by *removing* two atoms in each, and then *placing* the atom back in.</span>
                    <span class="c1"># this ensures that we have correct NEB ordering</span>
                    <span class="n">super0</span><span class="p">[</span><span class="n">ind0</span><span class="p">],</span> <span class="n">super0</span><span class="p">[</span><span class="n">ind1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vchem</span><span class="p">,</span> <span class="n">vchem</span>
                    <span class="n">super1</span><span class="p">[</span><span class="n">ind0</span><span class="p">],</span> <span class="n">super1</span><span class="p">[</span><span class="n">ind1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vchem</span><span class="p">,</span> <span class="n">vchem</span>
                    <span class="n">super0</span><span class="p">[</span><span class="n">ind1</span><span class="p">],</span> <span class="n">super1</span><span class="p">[</span><span class="n">ind0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chem</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">PSi</span><span class="p">,</span> <span class="n">PSf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">j0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">jumptype</span> <span class="o">==</span> <span class="s1">&#39;omega1&#39;</span><span class="p">:</span>
                        <span class="c1"># solute in first; same for each</span>
                        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">super0</span><span class="o">.</span><span class="n">invsuper</span><span class="p">,</span> <span class="n">basis</span><span class="p">[</span><span class="n">PSi</span><span class="o">.</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">super0</span><span class="o">.</span><span class="n">size</span>
                        <span class="n">super0</span><span class="p">[</span><span class="n">inds</span><span class="p">],</span> <span class="n">super1</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">schem</span><span class="p">,</span> <span class="n">schem</span>
                        <span class="c1"># now get the initial and final vacancy locations</span>
                        <span class="n">ind0</span><span class="p">,</span> <span class="n">ind1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">super0</span><span class="o">.</span><span class="n">invsuper</span><span class="p">,</span> <span class="n">basis</span><span class="p">[</span><span class="n">PSi</span><span class="o">.</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">PSi</span><span class="o">.</span><span class="n">R</span><span class="p">)</span> <span class="o">/</span> <span class="n">super0</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> \
                                     <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">super1</span><span class="o">.</span><span class="n">invsuper</span><span class="p">,</span> <span class="n">basis</span><span class="p">[</span><span class="n">PSf</span><span class="o">.</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">PSf</span><span class="o">.</span><span class="n">R</span><span class="p">)</span> <span class="o">/</span> <span class="n">super1</span><span class="o">.</span><span class="n">size</span>
                        <span class="c1"># put vacancies at our corresponding sites:</span>
                        <span class="c1"># we do this by *removing* two atoms in each, and then *placing* the atom back in.</span>
                        <span class="c1"># this ensures that we have correct NEB ordering</span>
                        <span class="n">super0</span><span class="p">[</span><span class="n">ind0</span><span class="p">],</span> <span class="n">super0</span><span class="p">[</span><span class="n">ind1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vchem</span><span class="p">,</span> <span class="n">vchem</span>
                        <span class="n">super1</span><span class="p">[</span><span class="n">ind0</span><span class="p">],</span> <span class="n">super1</span><span class="p">[</span><span class="n">ind1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vchem</span><span class="p">,</span> <span class="n">vchem</span>
                        <span class="n">super0</span><span class="p">[</span><span class="n">ind1</span><span class="p">],</span> <span class="n">super1</span><span class="p">[</span><span class="n">ind0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chem</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># omega2, we do it all using PSi: *assume* PSf is the reverse (exchange s + v)</span>
                        <span class="n">inds</span><span class="p">,</span> <span class="n">indv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">super0</span><span class="o">.</span><span class="n">invsuper</span><span class="p">,</span> <span class="n">basis</span><span class="p">[</span><span class="n">PSi</span><span class="o">.</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">super0</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> \
                                     <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">super0</span><span class="o">.</span><span class="n">invsuper</span><span class="p">,</span> <span class="n">basis</span><span class="p">[</span><span class="n">PSi</span><span class="o">.</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">PSi</span><span class="o">.</span><span class="n">R</span><span class="p">)</span> <span class="o">/</span> <span class="n">super0</span><span class="o">.</span><span class="n">size</span>
                        <span class="c1"># add the solutes:</span>
                        <span class="n">super0</span><span class="p">[</span><span class="n">inds</span><span class="p">],</span> <span class="n">super1</span><span class="p">[</span><span class="n">indv</span><span class="p">]</span> <span class="o">=</span> <span class="n">schem</span><span class="p">,</span> <span class="n">schem</span>
                        <span class="c1"># and the vacancies:</span>
                        <span class="n">super0</span><span class="p">[</span><span class="n">indv</span><span class="p">],</span> <span class="n">super1</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">vchem</span><span class="p">,</span> <span class="n">vchem</span>
                <span class="n">superdict</span><span class="p">[</span><span class="s1">&#39;transitions&#39;</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">super0</span><span class="p">,</span> <span class="n">super1</span><span class="p">)</span>
                <span class="c1"># determine the mappings:</span>
                <span class="n">superdict</span><span class="p">[</span><span class="s1">&#39;transmapping&#39;</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">(</span><span class="n">super0</span><span class="p">,</span> <span class="n">super1</span><span class="p">):</span>
                    <span class="n">nomap</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">superdict</span><span class="p">[</span><span class="s1">&#39;states&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="c1"># attempt the mapping</span>
                        <span class="n">g</span><span class="p">,</span> <span class="n">mapping</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">equivalencemap</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">superdict</span><span class="p">[</span><span class="s1">&#39;transmapping&#39;</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">+=</span> <span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">mapping</span><span class="p">),)</span>
                            <span class="n">nomap</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="n">nomap</span><span class="p">:</span>
                        <span class="n">superdict</span><span class="p">[</span><span class="s1">&#39;transmapping&#39;</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">(</span><span class="n">superdict</span><span class="p">[</span><span class="s1">&#39;states&#39;</span><span class="p">],</span> <span class="n">superdict</span><span class="p">[</span><span class="s1">&#39;transitions&#39;</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">superdict</span><span class="p">[</span><span class="s1">&#39;indices&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tagdicttype</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tagdict</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>  <span class="c1"># keep a local copy of the indices, for transformation later</span>
        <span class="k">return</span> <span class="n">superdict</span></div>

    <span class="c1"># this is part of our *class* definition: list of data that can be directly assigned / read</span>
    <span class="n">__HDF5list__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;chem&#39;</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;Nthermo&#39;</span><span class="p">,</span> <span class="s1">&#39;NGFmax&#39;</span><span class="p">,</span> <span class="s1">&#39;invmap&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;thermo2kin&#39;</span><span class="p">,</span> <span class="s1">&#39;kin2vacancy&#39;</span><span class="p">,</span> <span class="s1">&#39;outerkin&#39;</span><span class="p">,</span> <span class="s1">&#39;vstar2kin&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;om1_jt&#39;</span><span class="p">,</span> <span class="s1">&#39;om1_SP&#39;</span><span class="p">,</span> <span class="s1">&#39;om2_jt&#39;</span><span class="p">,</span> <span class="s1">&#39;om2_SP&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;GFexpansion&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;Dom1_om0&#39;</span><span class="p">,</span> <span class="s1">&#39;Dom1&#39;</span><span class="p">,</span> <span class="s1">&#39;Dom2_om0&#39;</span><span class="p">,</span> <span class="s1">&#39;Dom2&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;om1_om0&#39;</span><span class="p">,</span> <span class="s1">&#39;om1_om0escape&#39;</span><span class="p">,</span> <span class="s1">&#39;om1expansion&#39;</span><span class="p">,</span> <span class="s1">&#39;om1escape&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;om2_om0&#39;</span><span class="p">,</span> <span class="s1">&#39;om2_om0escape&#39;</span><span class="p">,</span> <span class="s1">&#39;om2expansion&#39;</span><span class="p">,</span> <span class="s1">&#39;om2escape&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;om1_b0&#39;</span><span class="p">,</span> <span class="s1">&#39;om1bias&#39;</span><span class="p">,</span> <span class="s1">&#39;om2_b0&#39;</span><span class="p">,</span> <span class="s1">&#39;om2bias&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;OSindices&#39;</span><span class="p">,</span> <span class="s1">&#39;OSfolddown&#39;</span><span class="p">,</span> <span class="s1">&#39;OS_VB&#39;</span><span class="p">,</span> <span class="s1">&#39;OSVfolddown&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;kineticsvWyckoff&#39;</span><span class="p">,</span> <span class="s1">&#39;omega0vacancyWyckoff&#39;</span><span class="p">)</span>
    <span class="n">__taglist__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;vacancy&#39;</span><span class="p">,</span> <span class="s1">&#39;solute&#39;</span><span class="p">,</span> <span class="s1">&#39;solute-vacancy&#39;</span><span class="p">,</span> <span class="s1">&#39;omega0&#39;</span><span class="p">,</span> <span class="s1">&#39;omega1&#39;</span><span class="p">,</span> <span class="s1">&#39;omega2&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="VacancyMediated.addhdf5"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.VacancyMediated.addhdf5">[docs]</a>    <span class="k">def</span> <span class="nf">addhdf5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">HDF5group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an HDF5 representation of object into an HDF5group (needs to already exist).</span>

<span class="sd">        Example: if f is an open HDF5, then VacancyMediated.addhdf5(f.create_group(&#39;Diffuser&#39;)) will</span>
<span class="sd">        (1) create the group named &#39;Diffuser&#39;, and then (2) put the VacancyMediated representation in that group.</span>

<span class="sd">        :param HDF5group: HDF5 group</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">HDF5group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;crystal_yaml&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">crystal</span><span class="o">.</span><span class="n">yaml</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="p">)</span>
        <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;crystal_yaml&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;pythonrep&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
        <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;crystal_lattice&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">T</span>
        <span class="n">basislist</span><span class="p">,</span> <span class="n">basisindex</span> <span class="o">=</span> <span class="n">stars</span><span class="o">.</span><span class="n">doublelist2flatlistindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>
        <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;crystal_basisarray&#39;</span><span class="p">],</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;crystal_basisindex&#39;</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">basislist</span><span class="p">),</span> <span class="n">basisindex</span>
        <span class="c1"># a long way around, but if you want to store an array of variable length strings, this is how to do it:</span>
        <span class="c1"># import h5py</span>
        <span class="c1"># HDF5group.create_dataset(&#39;crystal_chemistry&#39;, data=np.array(self.crys.chemistry, dtype=object),</span>
        <span class="c1">#                          dtype=h5py.special_dtype(vlen=str))</span>
        <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;crystal_chemistry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">chemistry</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;S&#39;</span><span class="p">)</span>
        <span class="c1"># arrays that we can deal with:</span>
        <span class="k">for</span> <span class="n">internal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__HDF5list__</span><span class="p">:</span>
            <span class="n">HDF5group</span><span class="p">[</span><span class="n">internal</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">internal</span><span class="p">)</span>
        <span class="c1"># convert jumplist:</span>
        <span class="n">jumplist</span><span class="p">,</span> <span class="n">jumpindex</span> <span class="o">=</span> <span class="n">stars</span><span class="o">.</span><span class="n">doublelist2flatlistindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork</span><span class="p">)</span>
        <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;jump_ij&#39;</span><span class="p">],</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;jump_dx&#39;</span><span class="p">],</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;jump_index&#39;</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span> <span class="k">for</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dx</span><span class="p">)</span> <span class="ow">in</span> <span class="n">jumplist</span><span class="p">]),</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dx</span> <span class="k">for</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dx</span><span class="p">)</span> <span class="ow">in</span> <span class="n">jumplist</span><span class="p">]),</span> \
            <span class="n">jumpindex</span>
        <span class="c1"># objects with their own addhdf5 functionality:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">GFcalc</span><span class="o">.</span><span class="n">addhdf5</span><span class="p">(</span><span class="n">HDF5group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;GFcalc&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thermo</span><span class="o">.</span><span class="n">addhdf5</span><span class="p">(</span><span class="n">HDF5group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;thermo&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NNstar</span><span class="o">.</span><span class="n">addhdf5</span><span class="p">(</span><span class="n">HDF5group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;NNstar&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">addhdf5</span><span class="p">(</span><span class="n">HDF5group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;kinetic&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">addhdf5</span><span class="p">(</span><span class="n">HDF5group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;vkinetic&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">GFstarset</span><span class="o">.</span><span class="n">addhdf5</span><span class="p">(</span><span class="n">HDF5group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;GFstarset&#39;</span><span class="p">))</span>

        <span class="c1"># jump networks:</span>
        <span class="n">jumplist</span><span class="p">,</span> <span class="n">jumpindex</span> <span class="o">=</span> <span class="n">stars</span><span class="o">.</span><span class="n">doublelist2flatlistindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om1_jn</span><span class="p">)</span>
        <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;omega1_ij&#39;</span><span class="p">],</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;omega1_dx&#39;</span><span class="p">],</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;omega1_index&#39;</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span> <span class="k">for</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dx</span><span class="p">)</span> <span class="ow">in</span> <span class="n">jumplist</span><span class="p">]),</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dx</span> <span class="k">for</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dx</span><span class="p">)</span> <span class="ow">in</span> <span class="n">jumplist</span><span class="p">]),</span> \
            <span class="n">jumpindex</span>

        <span class="n">jumplist</span><span class="p">,</span> <span class="n">jumpindex</span> <span class="o">=</span> <span class="n">stars</span><span class="o">.</span><span class="n">doublelist2flatlistindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om2_jn</span><span class="p">)</span>
        <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;omega2_ij&#39;</span><span class="p">],</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;omega2_dx&#39;</span><span class="p">],</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;omega2_index&#39;</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span> <span class="k">for</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dx</span><span class="p">)</span> <span class="ow">in</span> <span class="n">jumplist</span><span class="p">]),</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dx</span> <span class="k">for</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dx</span><span class="p">)</span> <span class="ow">in</span> <span class="n">jumplist</span><span class="p">]),</span> \
            <span class="n">jumpindex</span>

        <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;kin2vstar_array&#39;</span><span class="p">],</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;kin2vstar_index&#39;</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">stars</span><span class="o">.</span><span class="n">doublelist2flatlistindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kin2vstar</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">GFvalues</span> <span class="o">!=</span> <span class="p">{}:</span>
            <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;GFvalues_vTK&#39;</span><span class="p">],</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;GFvalues_values&#39;</span><span class="p">],</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;GFvalues_splits&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">vTKdict2arrays</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GFvalues</span><span class="p">)</span>
            <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;Lvvvalues_vTK&#39;</span><span class="p">],</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;Lvvvalues_values&#39;</span><span class="p">],</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;Lvvvalues_splits&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">vTKdict2arrays</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Lvvvalues</span><span class="p">)</span>
            <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;etavvalues_vTK&#39;</span><span class="p">],</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;etavvalues_values&#39;</span><span class="p">],</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;etavvalues_splits&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">vTKdict2arrays</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">etavvalues</span><span class="p">)</span>

        <span class="c1"># tags</span>
        <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__taglist__</span><span class="p">:</span>
            <span class="n">taglist</span><span class="p">,</span> <span class="n">tagindex</span> <span class="o">=</span> <span class="n">stars</span><span class="o">.</span><span class="n">doublelist2flatlistindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="n">tag</span><span class="p">])</span>
            <span class="n">HDF5group</span><span class="p">[</span><span class="n">tag</span> <span class="o">+</span> <span class="s1">&#39;_taglist&#39;</span><span class="p">],</span> <span class="n">HDF5group</span><span class="p">[</span><span class="n">tag</span> <span class="o">+</span> <span class="s1">&#39;_tagindex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">taglist</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;S&#39;</span><span class="p">),</span> <span class="n">tagindex</span></div>

<div class="viewcode-block" id="VacancyMediated.loadhdf5"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.VacancyMediated.loadhdf5">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">loadhdf5</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">HDF5group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new VacancyMediated diffuser from an HDF5 group.</span>

<span class="sd">        :param HDFgroup: HDF5 group</span>
<span class="sd">        :return VacancyMediated: new VacancyMediated diffuser object from HDF5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">diffuser</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># initialize</span>
        <span class="n">diffuser</span><span class="o">.</span><span class="n">crys</span> <span class="o">=</span> <span class="n">crystal</span><span class="o">.</span><span class="n">yaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;crystal_yaml&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">diffuser</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="n">diffuser</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">dim</span>
        <span class="k">for</span> <span class="n">internal</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__HDF5list__</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">diffuser</span><span class="p">,</span> <span class="n">internal</span><span class="p">,</span> <span class="n">HDF5group</span><span class="p">[</span><span class="n">internal</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">diffuser</span><span class="o">.</span><span class="n">sitelist</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">diffuser</span><span class="o">.</span><span class="n">invmap</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">diffuser</span><span class="o">.</span><span class="n">invmap</span><span class="p">):</span>
            <span class="n">diffuser</span><span class="o">.</span><span class="n">sitelist</span><span class="p">[</span><span class="n">site</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># convert jumplist:</span>
        <span class="n">diffuser</span><span class="o">.</span><span class="n">jumpnetwork</span> <span class="o">=</span> <span class="n">stars</span><span class="o">.</span><span class="n">flatlistindex2doublelist</span><span class="p">([((</span><span class="n">ij</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ij</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dx</span><span class="p">)</span> <span class="k">for</span> <span class="n">ij</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> \
                                                               <span class="nb">zip</span><span class="p">(</span><span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;jump_ij&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                                                   <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;jump_dx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)],</span>
                                                              <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;jump_index&#39;</span><span class="p">])</span>
        <span class="n">diffuser</span><span class="o">.</span><span class="n">om0_jn</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">diffuser</span><span class="o">.</span><span class="n">jumpnetwork</span><span class="p">)</span>

        <span class="c1"># objects with their own addhdf5 functionality:</span>
        <span class="n">diffuser</span><span class="o">.</span><span class="n">GFcalc</span> <span class="o">=</span> <span class="n">GFcalc</span><span class="o">.</span><span class="n">GFCrystalcalc</span><span class="o">.</span><span class="n">loadhdf5</span><span class="p">(</span><span class="n">diffuser</span><span class="o">.</span><span class="n">crys</span><span class="p">,</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;GFcalc&#39;</span><span class="p">])</span>
        <span class="n">diffuser</span><span class="o">.</span><span class="n">thermo</span> <span class="o">=</span> <span class="n">stars</span><span class="o">.</span><span class="n">StarSet</span><span class="o">.</span><span class="n">loadhdf5</span><span class="p">(</span><span class="n">diffuser</span><span class="o">.</span><span class="n">crys</span><span class="p">,</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;thermo&#39;</span><span class="p">])</span>
        <span class="n">diffuser</span><span class="o">.</span><span class="n">NNstar</span> <span class="o">=</span> <span class="n">stars</span><span class="o">.</span><span class="n">StarSet</span><span class="o">.</span><span class="n">loadhdf5</span><span class="p">(</span><span class="n">diffuser</span><span class="o">.</span><span class="n">crys</span><span class="p">,</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;NNstar&#39;</span><span class="p">])</span>
        <span class="n">diffuser</span><span class="o">.</span><span class="n">kinetic</span> <span class="o">=</span> <span class="n">stars</span><span class="o">.</span><span class="n">StarSet</span><span class="o">.</span><span class="n">loadhdf5</span><span class="p">(</span><span class="n">diffuser</span><span class="o">.</span><span class="n">crys</span><span class="p">,</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;kinetic&#39;</span><span class="p">])</span>
        <span class="n">diffuser</span><span class="o">.</span><span class="n">vkinetic</span> <span class="o">=</span> <span class="n">stars</span><span class="o">.</span><span class="n">VectorStarSet</span><span class="o">.</span><span class="n">loadhdf5</span><span class="p">(</span><span class="n">diffuser</span><span class="o">.</span><span class="n">kinetic</span><span class="p">,</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;vkinetic&#39;</span><span class="p">])</span>
        <span class="n">diffuser</span><span class="o">.</span><span class="n">GFstarset</span> <span class="o">=</span> <span class="n">stars</span><span class="o">.</span><span class="n">StarSet</span><span class="o">.</span><span class="n">loadhdf5</span><span class="p">(</span><span class="n">diffuser</span><span class="o">.</span><span class="n">crys</span><span class="p">,</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;GFstarset&#39;</span><span class="p">])</span>

        <span class="c1"># jump networks:</span>
        <span class="n">diffuser</span><span class="o">.</span><span class="n">om1_jn</span> <span class="o">=</span> <span class="n">stars</span><span class="o">.</span><span class="n">flatlistindex2doublelist</span><span class="p">([((</span><span class="n">ij</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ij</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dx</span><span class="p">)</span> <span class="k">for</span> <span class="n">ij</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> \
                                                          <span class="nb">zip</span><span class="p">(</span><span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;omega1_ij&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                                              <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;omega1_dx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)],</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;omega1_index&#39;</span><span class="p">])</span>
        <span class="n">diffuser</span><span class="o">.</span><span class="n">om2_jn</span> <span class="o">=</span> <span class="n">stars</span><span class="o">.</span><span class="n">flatlistindex2doublelist</span><span class="p">([((</span><span class="n">ij</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ij</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dx</span><span class="p">)</span> <span class="k">for</span> <span class="n">ij</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> \
                                                          <span class="nb">zip</span><span class="p">(</span><span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;omega2_ij&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                                              <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;omega2_dx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)],</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;omega2_index&#39;</span><span class="p">])</span>

        <span class="n">diffuser</span><span class="o">.</span><span class="n">kin2vstar</span> <span class="o">=</span> <span class="n">stars</span><span class="o">.</span><span class="n">flatlistindex2doublelist</span><span class="p">(</span><span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;kin2vstar_array&#39;</span><span class="p">],</span>
                                                            <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;kin2vstar_index&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;GFvalues_vTK&#39;</span> <span class="ow">in</span> <span class="n">HDF5group</span><span class="p">:</span>
            <span class="n">diffuser</span><span class="o">.</span><span class="n">GFvalues</span> <span class="o">=</span> <span class="n">arrays2vTKdict</span><span class="p">(</span><span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;GFvalues_vTK&#39;</span><span class="p">],</span>
                                               <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;GFvalues_values&#39;</span><span class="p">],</span>
                                               <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;GFvalues_splits&#39;</span><span class="p">])</span>
            <span class="n">diffuser</span><span class="o">.</span><span class="n">Lvvvalues</span> <span class="o">=</span> <span class="n">arrays2vTKdict</span><span class="p">(</span><span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;Lvvvalues_vTK&#39;</span><span class="p">],</span>
                                                <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;Lvvvalues_values&#39;</span><span class="p">],</span>
                                                <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;Lvvvalues_splits&#39;</span><span class="p">])</span>
            <span class="n">diffuser</span><span class="o">.</span><span class="n">etavvalues</span> <span class="o">=</span> <span class="n">arrays2vTKdict</span><span class="p">(</span><span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;etavvalues_vTK&#39;</span><span class="p">],</span>
                                                 <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;etavvalues_values&#39;</span><span class="p">],</span>
                                                 <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;etavvalues_splits&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diffuser</span><span class="o">.</span><span class="n">GFvalues</span><span class="p">,</span> <span class="n">diffuser</span><span class="o">.</span><span class="n">Lvvvalues</span><span class="p">,</span> <span class="n">diffuser</span><span class="o">.</span><span class="n">etavvalues</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}</span>
        <span class="c1"># tags</span>
        <span class="n">diffuser</span><span class="o">.</span><span class="n">tags</span><span class="p">,</span> <span class="n">diffuser</span><span class="o">.</span><span class="n">tagdict</span><span class="p">,</span> <span class="n">diffuser</span><span class="o">.</span><span class="n">tagdicttype</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__taglist__</span><span class="p">:</span>
            <span class="c1"># needed because of how HDF5 stores strings...</span>
            <span class="n">utf8list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">HDF5group</span><span class="p">[</span><span class="n">tag</span> <span class="o">+</span> <span class="s1">&#39;_taglist&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>
            <span class="n">diffuser</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">stars</span><span class="o">.</span><span class="n">flatlistindex2doublelist</span><span class="p">(</span><span class="n">utf8list</span><span class="p">,</span> <span class="n">HDF5group</span><span class="p">[</span><span class="n">tag</span> <span class="o">+</span> <span class="s1">&#39;_tagindex&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">tagtype</span><span class="p">,</span> <span class="n">taglist</span> <span class="ow">in</span> <span class="n">diffuser</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tags</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">taglist</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">tags</span><span class="p">:</span> <span class="n">diffuser</span><span class="o">.</span><span class="n">tagdict</span><span class="p">[</span><span class="n">tag</span><span class="p">],</span> <span class="n">diffuser</span><span class="o">.</span><span class="n">tagdicttype</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">tagtype</span>
        <span class="k">return</span> <span class="n">diffuser</span></div>

<div class="viewcode-block" id="VacancyMediated.interactlist"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.VacancyMediated.interactlist">[docs]</a>    <span class="k">def</span> <span class="nf">interactlist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of solute-vacancy configurations for interactions. The points correspond</span>
<span class="sd">        to a vector between a solute atom and a vacancy. Defined by Stars.</span>

<span class="sd">        :return statelist: list of PairStates for the solute-vacancy interactions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Nthermo&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Need to set thermodynamic range first&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">thermo</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">thermo</span><span class="o">.</span><span class="n">stars</span><span class="p">]</span></div>

<div class="viewcode-block" id="VacancyMediated.omegalist"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.VacancyMediated.omegalist">[docs]</a>    <span class="k">def</span> <span class="nf">omegalist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fivefreqindex</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of pairs of endpoints for a vacancy jump, corresponding to omega1 or omega2</span>
<span class="sd">        Solute at the origin, vacancy hopping between two sites. Defined by om1_jumpnetwork</span>

<span class="sd">        :param fivefreqindex: 1 or 2, corresponding to omega1 or omega2</span>
<span class="sd">        :return omegalist: list of tuples of PairStates</span>
<span class="sd">        :return omegajumptype: index of corresponding omega0 jumptype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Nthermo&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Need to set thermodynamic range first&#39;</span><span class="p">)</span>
        <span class="n">om</span><span class="p">,</span> <span class="n">jt</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om1_jn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om1_jt</span><span class="p">),</span>
                  <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om2_jn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om2_jt</span><span class="p">)}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">fivefreqindex</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">om</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Five frequency index should be 1 or 2&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">jlist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">jlist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span> <span class="k">for</span> <span class="n">jlist</span> <span class="ow">in</span> <span class="n">om</span><span class="p">],</span> \
               <span class="n">jt</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="VacancyMediated.maketracerpreene"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.VacancyMediated.maketracerpreene">[docs]</a>    <span class="k">def</span> <span class="nf">maketracerpreene</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">preT0</span><span class="p">,</span> <span class="n">eneT0</span><span class="p">,</span> <span class="o">**</span><span class="n">ignoredextraarguments</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates corresponding energies / prefactors for an isotopic tracer. Returns a dictionary.</span>
<span class="sd">        (we ignore extra arguments so that a dictionary including additional entries can be passed)</span>

<span class="sd">        :param preT0[Nomeg0]: prefactor for vacancy jump transitions (follows jumpnetwork)</span>
<span class="sd">        :param eneT0[Nomega0]: transition energy state for vacancy jumps</span>
<span class="sd">        :return preS[NWyckoff]: prefactor for solute formation</span>
<span class="sd">        :return eneS[NWyckoff]: solute formation energy</span>
<span class="sd">        :return preSV[Nthermo]: prefactor for solute-vacancy interaction</span>
<span class="sd">        :return eneSV[Nthermo]: solute-vacancy binding energy</span>
<span class="sd">        :return preT1[Nomega1]: prefactor for omega1-style transitions (follows om1_jn)</span>
<span class="sd">        :return eneT1[Nomega1]: transition energy for omega1-style jumps</span>
<span class="sd">        :return preT2[Nomega2]: prefactor for omega2-style transitions (follows om2_jn)</span>
<span class="sd">        :return eneT2[Nomega2]: transition energy for omega2-style jumps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">preS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">))</span>
        <span class="n">eneS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">))</span>
        <span class="n">preSV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thermo</span><span class="o">.</span><span class="n">Nstars</span><span class="p">)</span>
        <span class="n">eneSV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thermo</span><span class="o">.</span><span class="n">Nstars</span><span class="p">)</span>
        <span class="n">preT1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om1_jn</span><span class="p">))</span>
        <span class="n">eneT1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om1_jn</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">jt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">om1_jt</span><span class="p">):</span> <span class="n">preT1</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">eneT1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">preT0</span><span class="p">[</span><span class="n">jt</span><span class="p">],</span> <span class="n">eneT0</span><span class="p">[</span><span class="n">jt</span><span class="p">]</span>
        <span class="n">preT2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om2_jn</span><span class="p">))</span>
        <span class="n">eneT2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om2_jn</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">jt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">om2_jt</span><span class="p">):</span> <span class="n">preT2</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">eneT2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">preT0</span><span class="p">[</span><span class="n">jt</span><span class="p">],</span> <span class="n">eneT0</span><span class="p">[</span><span class="n">jt</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;preS&#39;</span><span class="p">:</span> <span class="n">preS</span><span class="p">,</span> <span class="s1">&#39;eneS&#39;</span><span class="p">:</span> <span class="n">eneS</span><span class="p">,</span> <span class="s1">&#39;preSV&#39;</span><span class="p">:</span> <span class="n">preSV</span><span class="p">,</span> <span class="s1">&#39;eneSV&#39;</span><span class="p">:</span> <span class="n">eneSV</span><span class="p">,</span>
                <span class="s1">&#39;preT1&#39;</span><span class="p">:</span> <span class="n">preT1</span><span class="p">,</span> <span class="s1">&#39;eneT1&#39;</span><span class="p">:</span> <span class="n">eneT1</span><span class="p">,</span> <span class="s1">&#39;preT2&#39;</span><span class="p">:</span> <span class="n">preT2</span><span class="p">,</span> <span class="s1">&#39;eneT2&#39;</span><span class="p">:</span> <span class="n">eneT2</span><span class="p">}</span></div>

<div class="viewcode-block" id="VacancyMediated.makeLIMBpreene"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.VacancyMediated.makeLIMBpreene">[docs]</a>    <span class="k">def</span> <span class="nf">makeLIMBpreene</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">preS</span><span class="p">,</span> <span class="n">eneS</span><span class="p">,</span> <span class="n">preSV</span><span class="p">,</span> <span class="n">eneSV</span><span class="p">,</span> <span class="n">preT0</span><span class="p">,</span> <span class="n">eneT0</span><span class="p">,</span> <span class="o">**</span><span class="n">ignoredextraarguments</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates corresponding energies / prefactors for corresponding to LIMB</span>
<span class="sd">        (Linearized interpolation of migration barrier approximation). Returns a dictionary.</span>
<span class="sd">        (we ignore extra arguments so that a dictionary including additional entries can be passed)</span>

<span class="sd">        :param preS[NWyckoff]: prefactor for solute formation</span>
<span class="sd">        :param eneS[NWyckoff]: solute formation energy</span>
<span class="sd">        :param preSV[Nthermo]: prefactor for solute-vacancy interaction</span>
<span class="sd">        :param eneSV[Nthermo]: solute-vacancy binding energy</span>
<span class="sd">        :param preT0[Nomeg0]: prefactor for vacancy jump transitions (follows jumpnetwork)</span>
<span class="sd">        :param eneT0[Nomega0]: transition energy for vacancy jumps</span>
<span class="sd">        :return preT1[Nomega1]: prefactor for omega1-style transitions (follows om1_jn)</span>
<span class="sd">        :return eneT1[Nomega1]: transition energy/kBT for omega1-style jumps</span>
<span class="sd">        :return preT2[Nomega2]: prefactor for omega2-style transitions (follows om2_jn)</span>
<span class="sd">        :return eneT2[Nomega2]: transition energy/kBT for omega2-style jumps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we need the prefactors and energies for all of our kinetic stars... without the</span>
        <span class="c1"># vacancy part (since that reference is already in preT0 and eneT0); we&#39;re going</span>
        <span class="c1"># to add these to preT0 and eneT0 to get the TS prefactor/energy for w1 and w2 jumps</span>
        <span class="n">eneSVkin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">eneS</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kineticsvWyckoff</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>  <span class="c1"># avoid ints</span>
        <span class="n">preSVkin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">preS</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kineticsvWyckoff</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>  <span class="c1"># avoid ints</span>
        <span class="k">for</span> <span class="n">tindex</span><span class="p">,</span> <span class="n">kindex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thermo2kin</span><span class="p">):</span>
            <span class="n">eneSVkin</span><span class="p">[</span><span class="n">kindex</span><span class="p">]</span> <span class="o">+=</span> <span class="n">eneSV</span><span class="p">[</span><span class="n">tindex</span><span class="p">]</span>
            <span class="n">preSVkin</span><span class="p">[</span><span class="n">kindex</span><span class="p">]</span> <span class="o">*=</span> <span class="n">preSV</span><span class="p">[</span><span class="n">tindex</span><span class="p">]</span>
        <span class="n">preT1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om1_jn</span><span class="p">))</span>
        <span class="n">eneT1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om1_jn</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">jt</span><span class="p">,</span> <span class="n">SP</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">om1_jt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om1_SP</span><span class="p">):</span>
            <span class="c1"># need to include solute energy / prefactors</span>
            <span class="n">preT1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">preT0</span><span class="p">[</span><span class="n">jt</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">preSVkin</span><span class="p">[</span><span class="n">SP</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">preSVkin</span><span class="p">[</span><span class="n">SP</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">eneT1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">eneT0</span><span class="p">[</span><span class="n">jt</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">eneSVkin</span><span class="p">[</span><span class="n">SP</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">eneSVkin</span><span class="p">[</span><span class="n">SP</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">preT2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om2_jn</span><span class="p">))</span>
        <span class="n">eneT2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om2_jn</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">jt</span><span class="p">,</span> <span class="n">SP</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">om2_jt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">om2_SP</span><span class="p">):</span>
            <span class="c1"># need to include solute energy / prefactors</span>
            <span class="n">preT2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">preT0</span><span class="p">[</span><span class="n">jt</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">preSVkin</span><span class="p">[</span><span class="n">SP</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">preSVkin</span><span class="p">[</span><span class="n">SP</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">eneT2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">eneT0</span><span class="p">[</span><span class="n">jt</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">eneSVkin</span><span class="p">[</span><span class="n">SP</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">eneSVkin</span><span class="p">[</span><span class="n">SP</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;preT1&#39;</span><span class="p">:</span> <span class="n">preT1</span><span class="p">,</span> <span class="s1">&#39;eneT1&#39;</span><span class="p">:</span> <span class="n">eneT1</span><span class="p">,</span> <span class="s1">&#39;preT2&#39;</span><span class="p">:</span> <span class="n">preT2</span><span class="p">,</span> <span class="s1">&#39;eneT2&#39;</span><span class="p">:</span> <span class="n">eneT2</span><span class="p">}</span></div>

<div class="viewcode-block" id="VacancyMediated.tags2preene"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.VacancyMediated.tags2preene">[docs]</a>    <span class="k">def</span> <span class="nf">tags2preene</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">usertagdict</span><span class="p">,</span> <span class="n">VERBOSE</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates energies and prefactors based on a dictionary of tags.</span>

<span class="sd">        :param usertagdict: dictionary where the keys are tags, and the values are tuples: (pre, ene)</span>
<span class="sd">        :param VERBOSE: (optional) if True, also return a dictionary of missing tags, duplicate tags, and bad tags</span>
<span class="sd">        :return thermodict: dictionary of ene&#39;s and pre&#39;s corresponding to usertagdict</span>
<span class="sd">        :return missingdict: dictionary with keys corresponding to tag types, and the values are</span>
<span class="sd">          lists of lists of symmetry equivalent tags that are missing</span>
<span class="sd">        :return duplicatelist: list of lists of tags in usertagdict that are (symmetry) duplicates</span>
<span class="sd">        :return badtaglist: list of all tags in usertagdict that aren&#39;t found in our dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">N</span><span class="p">,</span> <span class="n">Nst</span><span class="p">,</span> <span class="n">Nom0</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">thermo</span><span class="o">.</span><span class="n">Nstars</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om0_jn</span><span class="p">)</span>
        <span class="c1"># basic thermodict; note: we *don&#39;t* prefill omega1 and omega2, because LIMB does that later</span>
        <span class="n">thermodict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;preV&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="s1">&#39;eneV&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">),</span>
                      <span class="s1">&#39;preS&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="s1">&#39;eneS&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">),</span>
                      <span class="s1">&#39;preSV&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">Nst</span><span class="p">),</span> <span class="s1">&#39;eneSV&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nst</span><span class="p">),</span>
                      <span class="s1">&#39;preT0&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">Nom0</span><span class="p">),</span> <span class="s1">&#39;eneT0&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nom0</span><span class="p">)}</span>
        <span class="k">for</span> <span class="n">tagstring</span><span class="p">,</span> <span class="n">prename</span><span class="p">,</span> <span class="n">enename</span> <span class="ow">in</span> <span class="p">((</span><span class="s1">&#39;vacancy&#39;</span><span class="p">,</span> <span class="s1">&#39;preV&#39;</span><span class="p">,</span> <span class="s1">&#39;eneV&#39;</span><span class="p">),</span>
                                            <span class="p">(</span><span class="s1">&#39;solute&#39;</span><span class="p">,</span> <span class="s1">&#39;preS&#39;</span><span class="p">,</span> <span class="s1">&#39;eneS&#39;</span><span class="p">),</span>
                                            <span class="p">(</span><span class="s1">&#39;solute-vacancy&#39;</span><span class="p">,</span> <span class="s1">&#39;preSV&#39;</span><span class="p">,</span> <span class="s1">&#39;eneSV&#39;</span><span class="p">),</span>
                                            <span class="p">(</span><span class="s1">&#39;omega0&#39;</span><span class="p">,</span> <span class="s1">&#39;preT0&#39;</span><span class="p">,</span> <span class="s1">&#39;eneT0&#39;</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tags</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="n">tagstring</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tags</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">usertagdict</span><span class="p">:</span>
                        <span class="n">thermodict</span><span class="p">[</span><span class="n">prename</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">thermodict</span><span class="p">[</span><span class="n">enename</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">usertagdict</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
                        <span class="k">break</span>
        <span class="c1"># &quot;backfill&quot; with LIMB so that the rest is meaningful:</span>
        <span class="n">thermodict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">makeLIMBpreene</span><span class="p">(</span><span class="o">**</span><span class="n">thermodict</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">tagstring</span><span class="p">,</span> <span class="n">prename</span><span class="p">,</span> <span class="n">enename</span> <span class="ow">in</span> <span class="p">((</span><span class="s1">&#39;omega1&#39;</span><span class="p">,</span> <span class="s1">&#39;preT1&#39;</span><span class="p">,</span> <span class="s1">&#39;eneT1&#39;</span><span class="p">),</span>
                                            <span class="p">(</span><span class="s1">&#39;omega2&#39;</span><span class="p">,</span> <span class="s1">&#39;preT2&#39;</span><span class="p">,</span> <span class="s1">&#39;eneT2&#39;</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tags</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="n">tagstring</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tags</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">usertagdict</span><span class="p">:</span>
                        <span class="n">thermodict</span><span class="p">[</span><span class="n">prename</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">thermodict</span><span class="p">[</span><span class="n">enename</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">usertagdict</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
                        <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">VERBOSE</span><span class="p">:</span> <span class="k">return</span> <span class="n">thermodict</span>
        <span class="n">missingdict</span><span class="p">,</span> <span class="n">duplicatelist</span><span class="p">,</span> <span class="n">badtaglist</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">tupledict</span> <span class="o">=</span> <span class="p">{(</span><span class="n">tagtype</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">tagtype</span><span class="p">,</span> <span class="n">taglist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">taglist</span><span class="p">))}</span>
        <span class="c1"># go through all the types of tags and interactions, and construct a list of usertags for each</span>
        <span class="k">for</span> <span class="n">usertag</span> <span class="ow">in</span> <span class="n">usertagdict</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">usertag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tagdict</span><span class="p">:</span>
                <span class="n">badtaglist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">usertag</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tupledict</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">tagdicttype</span><span class="p">[</span><span class="n">usertag</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tagdict</span><span class="p">[</span><span class="n">usertag</span><span class="p">])]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">usertag</span><span class="p">)</span>
        <span class="c1"># each entry should appear once, and only once</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tupledict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">missingdict</span><span class="p">:</span>
                    <span class="n">missingdict</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">missingdict</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">duplicatelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">thermodict</span><span class="p">,</span> <span class="n">missingdict</span><span class="p">,</span> <span class="n">duplicatelist</span><span class="p">,</span> <span class="n">badtaglist</span></div>

<div class="viewcode-block" id="VacancyMediated.preene2betafree"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.VacancyMediated.preene2betafree">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">preene2betafree</span><span class="p">(</span><span class="n">kT</span><span class="p">,</span> <span class="n">preV</span><span class="p">,</span> <span class="n">eneV</span><span class="p">,</span> <span class="n">preS</span><span class="p">,</span> <span class="n">eneS</span><span class="p">,</span> <span class="n">preSV</span><span class="p">,</span> <span class="n">eneSV</span><span class="p">,</span>
                        <span class="n">preT0</span><span class="p">,</span> <span class="n">eneT0</span><span class="p">,</span> <span class="n">preT1</span><span class="p">,</span> <span class="n">eneT1</span><span class="p">,</span> <span class="n">preT2</span><span class="p">,</span> <span class="n">eneT2</span><span class="p">,</span> <span class="o">**</span><span class="n">ignoredextraarguments</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read in a series of prefactors (:math:`\\exp(S/k_\\text{B})`) and energies, and return</span>
<span class="sd">        :math:`\\beta F` for energies and transition state energies. Used to provide scaled values</span>
<span class="sd">        to Lij().</span>
<span class="sd">        Can specify all of the entries using a dictionary; e.g., ``preene2betafree(kT, **data_dict)``</span>
<span class="sd">        and then send that output as input to Lij: ``Lij(*preene2betafree(kT, **data_dict))``</span>
<span class="sd">        (we ignore extra arguments so that a dictionary including additional entries can be passed)</span>

<span class="sd">        :param kT: temperature times Boltzmann&#39;s constant kB</span>
<span class="sd">        :param preV: prefactor for vacancy formation (prod of inverse vibrational frequencies)</span>
<span class="sd">        :param eneV: vacancy formation energy</span>
<span class="sd">        :param preS: prefactor for solute formation (prod of inverse vibrational frequencies)</span>
<span class="sd">        :param eneS: solute formation energy</span>
<span class="sd">        :param preSV: excess prefactor for solute-vacancy binding</span>
<span class="sd">        :param eneSV: solute-vacancy binding energy</span>
<span class="sd">        :param preT0: prefactor for vacancy transition state</span>
<span class="sd">        :param eneT0: energy for vacancy transition state (relative to eneV)</span>
<span class="sd">        :param preT1: prefactor for vacancy swing transition state</span>
<span class="sd">        :param eneT1: energy for vacancy swing transition state (relative to eneV + eneS + eneSV)</span>
<span class="sd">        :param preT2: prefactor for vacancy exchange transition state</span>
<span class="sd">        :param eneT2: energy for vacancy exchange transition state (relative to eneV + eneS + eneSV)</span>
<span class="sd">        :return bFV: beta*eneV - ln(preV) (relative to minimum value)</span>
<span class="sd">        :return bFS: beta*eneS - ln(preS) (relative to minimum value)</span>
<span class="sd">        :return bFSV: beta*eneSV - ln(preSV) (excess)</span>
<span class="sd">        :return bFT0: beta*eneT0 - ln(preT0) (relative to minimum value of bFV)</span>
<span class="sd">        :return bFT1: beta*eneT1 - ln(preT1) (relative to minimum value of bFV + bFS)</span>
<span class="sd">        :return bFT2: beta*eneT2 - ln(preT2) (relative to minimum value of bFV + bFS)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># do anything to treat kT -&gt; 0?</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">kT</span>
        <span class="n">bFV</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">eneV</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">preV</span><span class="p">)</span>
        <span class="n">bFS</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">eneS</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">preS</span><span class="p">)</span>
        <span class="n">bFSV</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">eneSV</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">preSV</span><span class="p">)</span>
        <span class="n">bFT0</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">eneT0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">preT0</span><span class="p">)</span>
        <span class="n">bFT1</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">eneT1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">preT1</span><span class="p">)</span>
        <span class="n">bFT2</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">eneT2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">preT2</span><span class="p">)</span>

        <span class="n">bFVmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">bFV</span><span class="p">)</span>
        <span class="n">bFSmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">bFS</span><span class="p">)</span>
        <span class="n">bFV</span> <span class="o">-=</span> <span class="n">bFVmin</span>
        <span class="n">bFS</span> <span class="o">-=</span> <span class="n">bFSmin</span>
        <span class="n">bFT0</span> <span class="o">-=</span> <span class="n">bFVmin</span>
        <span class="n">bFT1</span> <span class="o">-=</span> <span class="n">bFVmin</span> <span class="o">+</span> <span class="n">bFSmin</span>
        <span class="n">bFT2</span> <span class="o">-=</span> <span class="n">bFVmin</span> <span class="o">+</span> <span class="n">bFSmin</span>
        <span class="k">return</span> <span class="n">bFV</span><span class="p">,</span> <span class="n">bFS</span><span class="p">,</span> <span class="n">bFSV</span><span class="p">,</span> <span class="n">bFT0</span><span class="p">,</span> <span class="n">bFT1</span><span class="p">,</span> <span class="n">bFT2</span></div>

    <span class="k">def</span> <span class="nf">_symmetricandescaperates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bFV</span><span class="p">,</span> <span class="n">bFSVkinetic</span><span class="p">,</span> <span class="n">bFT0</span><span class="p">,</span> <span class="n">bFT1</span><span class="p">,</span> <span class="n">bFT2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the symmetric, escape, and escape reference rates. Used by _lij().</span>

<span class="sd">        :param bFV[NWyckoff]: beta*eneV - ln(preV) (relative to minimum value)</span>
<span class="sd">        :param bFSVkinetic[Nkinetic]: beta*eneSV - ln(preSV) (TOTAL for solute-vacancy complex)</span>
<span class="sd">        :param bFT0[Nomega0]: beta*eneT0 - ln(preT0) (relative to minimum value of bFV)</span>
<span class="sd">        :param bFT1[Nomega1]: beta*eneT1 - ln(preT1) (relative to minimum value of bFV + bFS)</span>
<span class="sd">        :param bFT2[Nomega2]: beta*eneT2 - ln(preT2) (relative to minimum value of bFV + bFS)</span>
<span class="sd">        :return omega0[Nomega0]: symmetric rate for omega0 jumps</span>
<span class="sd">        :return omega1[Nomega1]: symmetric rate for omega1 jumps</span>
<span class="sd">        :return omega2[Nomega2]: symmetric rate for omega2 jumps</span>
<span class="sd">        :return omega0escape[NWyckoff, Nomega0]: escape rate elements for omega0 jumps</span>
<span class="sd">        :return omega1escape[NVstars, Nomega1]: escape rate elements for omega1 jumps</span>
<span class="sd">        :return omega2escape[NVstars, Nomega2]: escape rate elements for omega2 jumps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">omega0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om0_jn</span><span class="p">))</span>
        <span class="n">omega0escape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om0_jn</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">bF</span><span class="p">,</span> <span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="n">bFT0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega0vacancyWyckoff</span><span class="p">):</span>
            <span class="n">omega0escape</span><span class="p">[</span><span class="n">v1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">bF</span> <span class="o">+</span> <span class="n">bFV</span><span class="p">[</span><span class="n">v1</span><span class="p">])</span>
            <span class="n">omega0escape</span><span class="p">[</span><span class="n">v2</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">bF</span> <span class="o">+</span> <span class="n">bFV</span><span class="p">[</span><span class="n">v2</span><span class="p">])</span>
            <span class="n">omega0</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">omega0escape</span><span class="p">[</span><span class="n">v1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">omega0escape</span><span class="p">[</span><span class="n">v2</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
        <span class="n">omega1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om1_jn</span><span class="p">))</span>
        <span class="n">omega1escape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om1_jn</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">st1</span><span class="p">,</span> <span class="n">st2</span><span class="p">),</span> <span class="n">bFT</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">om1_SP</span><span class="p">,</span> <span class="n">bFT1</span><span class="p">):</span>
            <span class="n">omF</span><span class="p">,</span> <span class="n">omB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">bFT</span> <span class="o">+</span> <span class="n">bFSVkinetic</span><span class="p">[</span><span class="n">st1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">bFT</span> <span class="o">+</span> <span class="n">bFSVkinetic</span><span class="p">[</span><span class="n">st2</span><span class="p">])</span>
            <span class="n">omega1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">omF</span> <span class="o">*</span> <span class="n">omB</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">vst1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kin2vstar</span><span class="p">[</span><span class="n">st1</span><span class="p">]:</span> <span class="n">omega1escape</span><span class="p">[</span><span class="n">vst1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">omF</span>
            <span class="k">for</span> <span class="n">vst2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kin2vstar</span><span class="p">[</span><span class="n">st2</span><span class="p">]:</span> <span class="n">omega1escape</span><span class="p">[</span><span class="n">vst2</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">omB</span>
        <span class="n">omega2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om2_jn</span><span class="p">))</span>
        <span class="n">omega2escape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om2_jn</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">st1</span><span class="p">,</span> <span class="n">st2</span><span class="p">),</span> <span class="n">bFT</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">om2_SP</span><span class="p">,</span> <span class="n">bFT2</span><span class="p">):</span>
            <span class="n">omF</span><span class="p">,</span> <span class="n">omB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">bFT</span> <span class="o">+</span> <span class="n">bFSVkinetic</span><span class="p">[</span><span class="n">st1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">bFT</span> <span class="o">+</span> <span class="n">bFSVkinetic</span><span class="p">[</span><span class="n">st2</span><span class="p">])</span>
            <span class="n">omega2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">omF</span> <span class="o">*</span> <span class="n">omB</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">vst1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kin2vstar</span><span class="p">[</span><span class="n">st1</span><span class="p">]:</span> <span class="n">omega2escape</span><span class="p">[</span><span class="n">vst1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">omF</span>
            <span class="k">for</span> <span class="n">vst2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kin2vstar</span><span class="p">[</span><span class="n">st2</span><span class="p">]:</span> <span class="n">omega2escape</span><span class="p">[</span><span class="n">vst2</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">omB</span>
        <span class="k">return</span> <span class="n">omega0</span><span class="p">,</span> <span class="n">omega1</span><span class="p">,</span> <span class="n">omega2</span><span class="p">,</span> \
               <span class="n">omega0escape</span><span class="p">,</span> <span class="n">omega1escape</span><span class="p">,</span> <span class="n">omega2escape</span>

<div class="viewcode-block" id="VacancyMediated.Lij"><a class="viewcode-back" href="../OnsagerCalc.html#OnsagerCalc.VacancyMediated.Lij">[docs]</a>    <span class="k">def</span> <span class="nf">Lij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bFV</span><span class="p">,</span> <span class="n">bFS</span><span class="p">,</span> <span class="n">bFSV</span><span class="p">,</span> <span class="n">bFT0</span><span class="p">,</span> <span class="n">bFT1</span><span class="p">,</span> <span class="n">bFT2</span><span class="p">,</span> <span class="n">large_om2</span><span class="o">=</span><span class="mf">1e8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the transport coefficients: L0vv, Lss, Lsv, L1vv from the scaled free energies.</span>
<span class="sd">        The Green function entries are calculated from the omega0 info. As this is the most</span>
<span class="sd">        time-consuming part of the calculation, we cache these values with a dictionary</span>
<span class="sd">        and hash function.</span>

<span class="sd">        :param bFV[NWyckoff]: beta*eneV - ln(preV) (relative to minimum value)</span>
<span class="sd">        :param bFS[NWyckoff]: beta*eneS - ln(preS) (relative to minimum value)</span>
<span class="sd">        :param bFSV[Nthermo]: beta*eneSV - ln(preSV) (excess)</span>
<span class="sd">        :param bFT0[Nomega0]: beta*eneT0 - ln(preT0) (relative to minimum value of bFV)</span>
<span class="sd">        :param bFT1[Nomega1]: beta*eneT1 - ln(preT1) (relative to minimum value of bFV + bFS)</span>
<span class="sd">        :param bFT2[Nomega2]: beta*eneT2 - ln(preT2) (relative to minimum value of bFV + bFS)</span>
<span class="sd">        :param large_om2: threshold for changing treatment of omega2 contributions (default: 10^8)</span>
<span class="sd">        :return Lvv[3, 3]: vacancy-vacancy; needs to be multiplied by cv/kBT</span>
<span class="sd">        :return Lss[3, 3]: solute-solute; needs to be multiplied by cv*cs/kBT</span>
<span class="sd">        :return Lsv[3, 3]: solute-vacancy; needs to be multiplied by cv*cs/kBT</span>
<span class="sd">        :return Lvv1[3, 3]: vacancy-vacancy correction due to solute; needs to be multiplied by cv*cs/kBT</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1. bare vacancy diffusivity and Green&#39;s function</span>
        <span class="n">vTK</span> <span class="o">=</span> <span class="n">vacancyThermoKinetics</span><span class="p">(</span><span class="n">pre</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">bFV</span><span class="p">),</span> <span class="n">betaene</span><span class="o">=</span><span class="n">bFV</span><span class="p">,</span>
                                    <span class="n">preT</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">bFT0</span><span class="p">),</span> <span class="n">betaeneT</span><span class="o">=</span><span class="n">bFT0</span><span class="p">)</span>
        <span class="n">GF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GFvalues</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">vTK</span><span class="p">)</span>
        <span class="n">L0vv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Lvvvalues</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">vTK</span><span class="p">)</span>
        <span class="n">etav</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">etavvalues</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">vTK</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">GF</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># calculate, and store in dictionary for cache:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GFcalc</span><span class="o">.</span><span class="n">SetRates</span><span class="p">(</span><span class="o">**</span><span class="p">(</span><span class="n">vTK</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()))</span>
            <span class="n">L0vv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GFcalc</span><span class="o">.</span><span class="n">Diffusivity</span><span class="p">()</span>
            <span class="n">etav</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GFcalc</span><span class="o">.</span><span class="n">biascorrection</span><span class="p">()</span>
            <span class="n">GF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">GFcalc</span><span class="p">(</span><span class="n">PS</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">PS</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="n">PS</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">PS</span> <span class="ow">in</span>
                           <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GFstarset</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">GFstarset</span><span class="o">.</span><span class="n">stars</span><span class="p">]])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GFvalues</span><span class="p">[</span><span class="n">vTK</span><span class="p">]</span> <span class="o">=</span> <span class="n">GF</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Lvvvalues</span><span class="p">[</span><span class="n">vTK</span><span class="p">]</span> <span class="o">=</span> <span class="n">L0vv</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">etavvalues</span><span class="p">[</span><span class="n">vTK</span><span class="p">]</span> <span class="o">=</span> <span class="n">etav</span>

        <span class="c1"># 2. set up probabilities for solute-vacancy configurations</span>
        <span class="n">probVsites</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">bFV</span><span class="p">)</span> <span class="o">-</span> <span class="n">bFV</span><span class="p">[</span><span class="n">wi</span><span class="p">])</span> <span class="k">for</span> <span class="n">wi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">invmap</span><span class="p">])</span>
        <span class="n">probVsites</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probVsites</span><span class="p">)</span>  <span class="c1"># normalize</span>
        <span class="n">probV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">probVsites</span><span class="p">[</span><span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">sites</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">])</span>  <span class="c1"># Wyckoff positions</span>
        <span class="n">probVsqrt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">probV</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kin2vacancy</span><span class="p">[</span><span class="n">starindex</span><span class="p">]])</span>
                              <span class="k">for</span> <span class="n">starindex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vstar2kin</span><span class="p">])</span>
        <span class="n">probSsites</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">bFS</span><span class="p">)</span> <span class="o">-</span> <span class="n">bFS</span><span class="p">[</span><span class="n">wi</span><span class="p">])</span> <span class="k">for</span> <span class="n">wi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">invmap</span><span class="p">])</span>
        <span class="n">probSsites</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probSsites</span><span class="p">)</span>  <span class="c1"># normalize</span>
        <span class="n">probS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">probSsites</span><span class="p">[</span><span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">sites</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sitelist</span><span class="p">])</span>  <span class="c1"># Wyckoff positions</span>
        <span class="n">bFSVkin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bFS</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">+</span> <span class="n">bFV</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kineticsvWyckoff</span><span class="p">])</span>  <span class="c1"># NOT EXCESS: total</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">probS</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">*</span> <span class="n">probV</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kineticsvWyckoff</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">tindex</span><span class="p">,</span> <span class="n">kindex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thermo2kin</span><span class="p">):</span>
            <span class="n">bFSVkin</span><span class="p">[</span><span class="n">kindex</span><span class="p">]</span> <span class="o">+=</span> <span class="n">bFSV</span><span class="p">[</span><span class="n">tindex</span><span class="p">]</span>
            <span class="n">prob</span><span class="p">[</span><span class="n">kindex</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">bFSV</span><span class="p">[</span><span class="n">tindex</span><span class="p">])</span>
        <span class="c1"># zero out probability of any origin states... not clear this is really needed</span>
        <span class="k">for</span> <span class="n">kindex</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">stars</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinetic</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">iszero</span><span class="p">():</span>
                <span class="n">prob</span><span class="p">[</span><span class="n">kindex</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># 3. set up symmetric rates: omega0, omega1, omega2</span>
        <span class="c1">#    and escape rates omega0escape, omega1escape, omega2escape</span>
        <span class="n">omega0</span><span class="p">,</span> <span class="n">omega1</span><span class="p">,</span> <span class="n">omega2</span><span class="p">,</span> <span class="n">omega0escape</span><span class="p">,</span> <span class="n">omega1escape</span><span class="p">,</span> <span class="n">omega2escape</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_symmetricandescaperates</span><span class="p">(</span><span class="n">bFV</span><span class="p">,</span> <span class="n">bFSVkin</span><span class="p">,</span> <span class="n">bFT0</span><span class="p">,</span> <span class="n">bFT1</span><span class="p">,</span> <span class="n">bFT2</span><span class="p">)</span>

        <span class="c1"># 4. expand out: D0ss, D0vv, domega1, domega2, bias1, bias2</span>
        <span class="c1"># Note: we handle the equivalent of om1_om0 for omega2 (om2_om0) differently. Those</span>
        <span class="c1"># jumps correspond to the vacancy *landing* on the solute site; the &quot;origin states&quot;</span>
        <span class="c1"># are treated below--they only need to be considered *if* there is broken symmetry, such</span>
        <span class="c1"># that we have a non-empty VectorBasis in our *unit cell* (NVB &gt; 0)</span>
        <span class="c1"># 4a. Bare diffusivities</span>
        <span class="n">symmprobV0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">probV</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">probV</span><span class="p">[</span><span class="n">f</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega0vacancyWyckoff</span><span class="p">])</span>
        <span class="n">symmprobSV1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">prob</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">prob</span><span class="p">[</span><span class="n">f</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">om1_SP</span><span class="p">])</span>
        <span class="n">symmprobSV2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">prob</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">prob</span><span class="p">[</span><span class="n">f</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">om2_SP</span><span class="p">])</span>
        <span class="n">D0ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Dom2</span><span class="p">,</span> <span class="n">omega2</span> <span class="o">*</span> <span class="n">symmprobSV2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
        <span class="n">D0sv</span> <span class="o">=</span> <span class="o">-</span><span class="n">D0ss</span>
        <span class="n">D0vv</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Dom1</span><span class="p">,</span> <span class="n">omega1</span> <span class="o">*</span> <span class="n">symmprobSV1</span><span class="p">)</span> <span class="o">-</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Dom1_om0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">Dom2_om0</span><span class="p">,</span> <span class="n">omega0</span> <span class="o">*</span> <span class="n">symmprobV0</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
        <span class="n">D2vv</span> <span class="o">=</span> <span class="n">D0ss</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># 4b. Bias vectors (before correction) and rate matrices</span>
        <span class="n">biasSvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">)</span>
        <span class="n">biasVvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">)</span>  <span class="c1"># now, does *not* include -biasSvec</span>
        <span class="n">om2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om2expansion</span><span class="p">,</span> <span class="n">omega2</span><span class="p">)</span>
        <span class="n">delta_om</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om1expansion</span><span class="p">,</span> <span class="n">omega1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om1_om0</span><span class="p">,</span> <span class="n">omega0</span><span class="p">)</span> \
                   <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om2_om0</span><span class="p">,</span> <span class="n">omega0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sv</span><span class="p">,</span> <span class="n">starindex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vstar2kin</span><span class="p">):</span>
            <span class="n">svvacindex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kin2vacancy</span><span class="p">[</span><span class="n">starindex</span><span class="p">]</span>  <span class="c1"># vacancy</span>
            <span class="n">delta_om</span><span class="p">[</span><span class="n">sv</span><span class="p">,</span> <span class="n">sv</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om1escape</span><span class="p">[</span><span class="n">sv</span><span class="p">,</span> <span class="p">:],</span> <span class="n">omega1escape</span><span class="p">[</span><span class="n">sv</span><span class="p">,</span> <span class="p">:])</span> <span class="o">-</span> \
                                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om1_om0escape</span><span class="p">[</span><span class="n">sv</span><span class="p">,</span> <span class="p">:],</span> <span class="n">omega0escape</span><span class="p">[</span><span class="n">svvacindex</span><span class="p">,</span> <span class="p">:])</span> <span class="o">-</span> \
                                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om2_om0escape</span><span class="p">[</span><span class="n">sv</span><span class="p">,</span> <span class="p">:],</span> <span class="n">omega0escape</span><span class="p">[</span><span class="n">svvacindex</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">om2</span><span class="p">[</span><span class="n">sv</span><span class="p">,</span> <span class="n">sv</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om2escape</span><span class="p">[</span><span class="n">sv</span><span class="p">,</span> <span class="p">:],</span> <span class="n">omega2escape</span><span class="p">[</span><span class="n">sv</span><span class="p">,</span> <span class="p">:])</span>
            <span class="c1"># note: our solute bias is negative of the contribution to the vacancy, and also the</span>
            <span class="c1"># reference value is 0</span>
            <span class="n">biasSvec</span><span class="p">[</span><span class="n">sv</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om2bias</span><span class="p">[</span><span class="n">sv</span><span class="p">,</span> <span class="p">:],</span> <span class="n">omega2escape</span><span class="p">[</span><span class="n">sv</span><span class="p">,</span> <span class="p">:])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">prob</span><span class="p">[</span><span class="n">starindex</span><span class="p">])</span>
            <span class="c1"># removed the om2 contribution--will be added back in later. Separation necessary for large_om2 case</span>
            <span class="n">biasVvec</span><span class="p">[</span><span class="n">sv</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om1bias</span><span class="p">[</span><span class="n">sv</span><span class="p">,</span> <span class="p">:],</span> <span class="n">omega1escape</span><span class="p">[</span><span class="n">sv</span><span class="p">,</span> <span class="p">:])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">prob</span><span class="p">[</span><span class="n">starindex</span><span class="p">])</span> <span class="o">-</span> \
                           <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om1_b0</span><span class="p">[</span><span class="n">sv</span><span class="p">,</span> <span class="p">:],</span> <span class="n">omega0escape</span><span class="p">[</span><span class="n">svvacindex</span><span class="p">,</span> <span class="p">:])</span> <span class="o">*</span> <span class="n">probVsqrt</span><span class="p">[</span><span class="n">sv</span><span class="p">]</span> <span class="o">-</span> \
                           <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om2_b0</span><span class="p">[</span><span class="n">sv</span><span class="p">,</span> <span class="p">:],</span> <span class="n">omega0escape</span><span class="p">[</span><span class="n">svvacindex</span><span class="p">,</span> <span class="p">:])</span> <span class="o">*</span> <span class="n">probVsqrt</span><span class="p">[</span><span class="n">sv</span><span class="p">]</span>
            <span class="c1"># - biasSvec[sv]</span>
        <span class="n">biasVvec_om2</span> <span class="o">=</span> <span class="o">-</span><span class="n">biasSvec</span>

        <span class="c1"># 4c. origin state corrections for solute: (corrections for vacancy appear below)</span>
        <span class="c1"># these corrections are due to the null space for the vacancy without solute</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">OSindices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># need to multiply by sqrt(probV) first</span>
            <span class="n">OSprobV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OSfolddown</span><span class="o">*</span><span class="n">probVsqrt</span>  <span class="c1"># proper null space projection</span>
            <span class="n">biasSbar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">OSprobV</span><span class="p">,</span> <span class="n">biasSvec</span><span class="p">)</span>
            <span class="n">om2bar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">OSprobV</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">om2</span><span class="p">,</span> <span class="n">OSprobV</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>  <span class="c1"># OS x OS</span>
            <span class="n">etaSbar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pinv2</span><span class="p">(</span><span class="n">om2bar</span><span class="p">),</span> <span class="n">biasSbar</span><span class="p">)</span>
            <span class="n">dDss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">outer</span><span class="p">[:,</span> <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">OSindices</span><span class="p">,</span> <span class="p">:,</span> <span class="p">][:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">OSindices</span><span class="p">],</span>
                                 <span class="n">etaSbar</span><span class="p">),</span> <span class="n">biasSbar</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
            <span class="n">D0ss</span> <span class="o">+=</span> <span class="n">dDss</span>
            <span class="n">D0sv</span> <span class="o">-=</span> <span class="n">dDss</span>
            <span class="n">biasSvec</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">om2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">OSprobV</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">etaSbar</span><span class="p">))</span>

        <span class="c1"># 5. compute Green function:</span>
        <span class="n">G0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GFexpansion</span><span class="p">,</span> <span class="n">GF</span><span class="p">)</span>
        <span class="c1"># Note: we first do this *just* with omega1, then ... with omega2, depending on how it behaves</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G0</span><span class="p">,</span> <span class="n">delta_om</span><span class="p">)),</span> <span class="n">G0</span><span class="p">)</span>
        <span class="c1"># Now: to identify the omega2 contributions, we need to find all of the sv indices with a</span>
        <span class="c1"># non-zero contribution to om2bias. Hand been, where np.any(self.om2bias[sv,:] != 0)</span>
        <span class="c1"># Now, where np.any(self.om2expansion[sv,:,:] != 0)  --should we put into generatematrices?</span>
        <span class="n">om2_sv_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om2expansion</span><span class="p">))</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">om2expansion</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="mi">0</span><span class="p">)]</span>
        <span class="c1"># looks weird, but this is how we pull out a block in G corresponding to the indices in our list:</span>
        <span class="n">G1</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">om2_sv_indices</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">om2_sv_indices</span><span class="p">]</span>
        <span class="n">om2_slice</span> <span class="o">=</span> <span class="n">om2</span><span class="p">[</span><span class="n">om2_sv_indices</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">om2_sv_indices</span><span class="p">]</span>
        <span class="n">gdom2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="n">om2_slice</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">gdom2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">large_om2</span><span class="p">):</span>
            <span class="n">nom2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">om2_sv_indices</span><span class="p">)</span>
            <span class="n">om2eig</span><span class="p">,</span> <span class="n">om2vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">om2_slice</span><span class="p">)</span>
            <span class="n">G1rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">om2vec</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="n">om2vec</span><span class="p">))</span>  <span class="c1"># rotated matrix</span>
            <span class="c1"># eigenvalues are sorted in ascending order, and omega2 is negative definite</span>
            <span class="c1"># om2min = -np.min(omega2escape)  # this is the smallest that any nonzero eigenvalue can be</span>
            <span class="n">om2min</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="nb">min</span><span class="p">(</span><span class="n">om</span> <span class="k">for</span> <span class="n">omlist</span> <span class="ow">in</span> <span class="n">omega2escape</span> <span class="k">for</span> <span class="n">om</span> <span class="ow">in</span> <span class="n">omlist</span> <span class="k">if</span> <span class="n">om</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">nnull</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nom2</span><span class="p">)</span> <span class="k">if</span> <span class="n">om2eig</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">om2min</span><span class="p">),</span> <span class="n">nom2</span><span class="p">)</span>  <span class="c1"># 0:nnull == not in nullspace</span>
            <span class="c1"># general update (g^-1 + w)^-1:</span>
            <span class="n">G2rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">nom2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G1rot</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">om2eig</span><span class="p">))),</span> <span class="n">G1rot</span><span class="p">)</span>
            <span class="n">om2rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">om2eig</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nnull</span><span class="p">])</span>
            <span class="c1"># in the non-null subspace, replace with (g^-1+w)^-1-w^-1 = -(w+wgw)^-1:</span>
            <span class="n">G2rot</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nnull</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">nnull</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">om2rot</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">om2rot</span><span class="p">,</span>
                                                                     <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G1rot</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nnull</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">nnull</span><span class="p">],</span>
                                                                            <span class="n">om2rot</span><span class="p">)))</span>
            <span class="n">Greplace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">om2vec</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G2rot</span><span class="p">,</span> <span class="n">om2vec</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>  <span class="c1"># transform back</span>
            <span class="n">om2_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">om2_slice</span><span class="p">)</span>  <span class="c1"># only used here for testing purposes...</span>
            <span class="c1"># update with omega2, and then put in change due to omega2</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">om2</span><span class="p">)),</span> <span class="n">G</span><span class="p">)</span>
            <span class="n">Gfull</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ni</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">om2_sv_indices</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">nj</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">om2_sv_indices</span><span class="p">):</span>
                    <span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Greplace</span><span class="p">[</span><span class="n">ni</span><span class="p">,</span> <span class="n">nj</span><span class="p">]</span>

            <span class="n">bV</span><span class="p">,</span> <span class="n">bV2</span><span class="p">,</span> <span class="n">bS</span><span class="p">,</span> <span class="o">=</span> <span class="n">biasVvec</span><span class="p">[</span><span class="n">om2_sv_indices</span><span class="p">],</span> <span class="n">biasVvec_om2</span><span class="p">[</span><span class="n">om2_sv_indices</span><span class="p">],</span> <span class="n">biasSvec</span><span class="p">[</span><span class="n">om2_sv_indices</span><span class="p">]</span>
            <span class="n">om2_outer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">outer</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">om2_sv_indices</span><span class="p">,</span> <span class="p">:][:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">om2_sv_indices</span><span class="p">]</span>
            <span class="n">D0ss_correct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">om2_outer</span><span class="p">,</span> <span class="n">bS</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">om2_inv</span><span class="p">,</span> <span class="n">bS</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
            <span class="n">D0ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">D0ss</span><span class="p">)</span>  <span class="c1"># exact cancellation of bare term</span>
            <span class="n">D0sv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">om2_outer</span><span class="p">,</span> <span class="n">bV</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">om2_inv</span><span class="p">,</span> <span class="n">bS</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
            <span class="n">D2vv</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">om2_outer</span><span class="p">,</span> <span class="n">bV</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">om2_inv</span><span class="p">,</span> <span class="n">bV</span><span class="p">))</span> <span class="o">+</span>
                    <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">om2_outer</span><span class="p">,</span> <span class="n">bV2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">om2_inv</span><span class="p">,</span> <span class="n">bV</span><span class="p">)))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># update with omega2 (&quot;small&quot; omega2):</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">om2</span><span class="p">)),</span> <span class="n">G</span><span class="p">)</span>
            <span class="n">Gfull</span> <span class="o">=</span> <span class="n">G</span>

        <span class="c1"># 6. Compute bias contributions to Onsager coefficients</span>
        <span class="c1"># 6a. add in the om2 contribution to biasVvec:</span>
        <span class="n">biasVvec</span> <span class="o">+=</span> <span class="n">biasVvec_om2</span>

        <span class="c1"># 6b. GF pieces:</span>
        <span class="n">etaVvec</span><span class="p">,</span> <span class="n">etaSvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">biasVvec</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">biasSvec</span><span class="p">)</span>
        <span class="n">outer_etaVvec</span><span class="p">,</span> <span class="n">outer_etaSvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">outer</span><span class="p">,</span> <span class="n">etaVvec</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">outer</span><span class="p">,</span> <span class="n">etaSvec</span><span class="p">)</span>

        <span class="n">L1ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">outer_etaSvec</span><span class="p">,</span> <span class="n">biasSvec</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
        <span class="n">L1sv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">outer_etaSvec</span><span class="p">,</span> <span class="n">biasVvec</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
        <span class="n">L1vv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">outer_etaVvec</span><span class="p">,</span> <span class="n">biasVvec</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>

        <span class="c1"># 6c. origin state corrections for vacancy:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">OSindices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">etaV0</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">OS_VB</span><span class="p">,</span> <span class="n">etav</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
            <span class="n">outer_etaV0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vkinetic</span><span class="o">.</span><span class="n">outer</span><span class="p">[:,</span> <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">OSindices</span><span class="p">,</span> <span class="p">:][:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">OSindices</span><span class="p">],</span> <span class="n">etaV0</span><span class="p">)</span>
            <span class="n">dom</span> <span class="o">=</span> <span class="n">delta_om</span> <span class="o">+</span> <span class="n">om2</span>  <span class="c1"># sum of the terms</span>
            <span class="c1"># dgd = -dom + np.dot(dom, np.dot(G, dom))  # delta_g = g0*dgd*g0</span>
            <span class="n">dgd</span> <span class="o">=</span> <span class="o">-</span><span class="n">dom</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dom</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Gfull</span><span class="p">,</span> <span class="n">dom</span><span class="p">))</span>  <span class="c1"># delta_g = g0*dgd*g0</span>
            <span class="n">G0db</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G0</span><span class="p">,</span> <span class="n">biasVvec</span><span class="p">)</span>  <span class="c1"># G0*db</span>
            <span class="c1"># 2 eta0*db + 2 eta0*dgd*G0*db + eta0*dgd*eta0  (domega = delta_om + om2)</span>
            <span class="c1"># - etaV0*biasV0 (correction due to removing states)</span>
            <span class="n">L1vv</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">outer_etaV0</span><span class="p">,</span>
                           <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">OSVfolddown</span><span class="p">,</span> <span class="n">biasVvec</span><span class="p">)</span>
                           <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">OSVfolddown</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dgd</span><span class="p">,</span> <span class="n">G0db</span><span class="p">))</span>
                           <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">OSVfolddown</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dgd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">OSVfolddown</span><span class="o">.</span><span class="n">T</span><span class="p">)),</span> <span class="n">etaV0</span><span class="p">)</span>
                           <span class="o">-</span> <span class="n">biasVvec</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">OSindices</span><span class="p">]</span>
                           <span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>

        <span class="k">return</span> <span class="n">L0vv</span><span class="p">,</span> <span class="n">D0ss</span> <span class="o">+</span> <span class="n">L1ss</span><span class="p">,</span> <span class="n">D0sv</span> <span class="o">+</span> <span class="n">L1sv</span><span class="p">,</span> <span class="n">D0vv</span> <span class="o">+</span> <span class="n">D2vv</span> <span class="o">+</span> <span class="n">L1vv</span></div></div>


<span class="n">crystal</span><span class="o">.</span><span class="n">yaml</span><span class="o">.</span><span class="n">add_representer</span><span class="p">(</span><span class="n">vacancyThermoKinetics</span><span class="p">,</span> <span class="n">vacancyThermoKinetics</span><span class="o">.</span><span class="n">vacancyThermoKinetics_representer</span><span class="p">)</span>
<span class="n">crystal</span><span class="o">.</span><span class="n">yaml</span><span class="o">.</span><span class="n">add_constructor</span><span class="p">(</span><span class="n">VACANCYTHERMOKINETICS_YAMLTAG</span><span class="p">,</span> <span class="n">vacancyThermoKinetics</span><span class="o">.</span><span class="n">vacancyThermoKinetics_constructor</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Dallas R. Trinkle.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.3.2',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>