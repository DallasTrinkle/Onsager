

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>crystalStars &mdash; Onsager 1.3.3 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Onsager
          

          
          </a>

          
            
            
              <div class="version">
                1.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../includeme.html">Onsager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../InputOutput.html">Input and output for Onsager transport calculation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks.html">Example Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">Modules</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Onsager</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>crystalStars</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for crystalStars</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Stars module, modified to work with crystal class</span>

<span class="sd">Classes to generate star sets, double star sets, and vector star sets; a lot of indexing functionality.</span>

<span class="sd">NOTE: The naming follows that of stars; the functionality is extremely similar, and this code</span>
<span class="sd">was modified as little as possible to translate that functionality to *crystals* which possess</span>
<span class="sd">a basis. In the case of a single atom basis, this should reduce to the stars object functionality.</span>

<span class="sd">The big changes are:</span>

<span class="sd">* Replacing NNvect star (which represents the jumps) with the jumpnetwork type found in crystal</span>
<span class="sd">* Using the jumpnetwork_latt representation from crystal</span>
<span class="sd">* Representing a &quot;point&quot; as a solute + vacancy. In this case, it is a tuple (s,v) of unit cell</span>
<span class="sd">  indices and a vector dx or dR (dx = Cartesian vector pointing from solute to vacancy;</span>
<span class="sd">  dR = lattice vector pointing from unit cell of solute to unit cell of vacancy). This is equivalent</span>
<span class="sd">  to our old representation if the tuple (s,v) = (0,0) for all sites. Due to translational invariance,</span>
<span class="sd">  the solute always stays inside the unit cell</span>
<span class="sd">* Using indices into the point list rather than just making lists of the vectors themselves. This</span>
<span class="sd">  is because the &quot;points&quot; now have a more complex representation (see above).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Dallas R. Trinkle&#39;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">onsager</span> <span class="k">import</span> <span class="n">crystal</span>

<span class="c1"># YAML tags</span>
<span class="n">PAIRSTATE_YAMLTAG</span> <span class="o">=</span> <span class="s1">&#39;!PairState&#39;</span>


<div class="viewcode-block" id="PairState"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.PairState">[docs]</a><span class="k">class</span> <span class="nc">PairState</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;PairState&#39;</span><span class="p">,</span> <span class="s1">&#39;i j R dx&#39;</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class corresponding to a &quot;pair&quot; state; in this case, a solute-vacancy pair, but can</span>
<span class="sd">    also be a transition state pair. The solute (or initial state) is in unit cell 0, in position</span>
<span class="sd">    indexed i; the vacancy (or final state) is in unit cell R, in position indexed j.</span>
<span class="sd">    The cartesian vector dx connects them. We can add and subtract, negate, and &quot;endpoint&quot;</span>
<span class="sd">    subtract (useful for determining what Green function entry to use)</span>

<span class="sd">    :param i: index of the first member of the pair (solute)</span>
<span class="sd">    :param j: index of the second member of the pair (vacancy)</span>
<span class="sd">    :param R: lattice vector pointing from unit cell of i to unit cell of j</span>
<span class="sd">    :param dx: Cartesian vector pointing from first to second member of pair</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PairState.zero"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.PairState.zero">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">zero</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a &quot;zero&quot; state&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">dx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">))</span></div>

<div class="viewcode-block" id="PairState.fromcrys"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.PairState.fromcrys">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromcrys</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">crys</span><span class="p">,</span> <span class="n">chem</span><span class="p">,</span> <span class="n">ij</span><span class="p">,</span> <span class="n">dx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert (i,j), dx into PairState&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">ij</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                   <span class="n">j</span><span class="o">=</span><span class="n">ij</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                   <span class="n">R</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">crys</span><span class="o">.</span><span class="n">invlatt</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span> <span class="o">-</span> <span class="n">crys</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">chem</span><span class="p">][</span><span class="n">ij</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="n">crys</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">chem</span><span class="p">][</span><span class="n">ij</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
                   <span class="n">dx</span><span class="o">=</span><span class="n">dx</span><span class="p">)</span></div>

<div class="viewcode-block" id="PairState.fromcrys_latt"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.PairState.fromcrys_latt">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromcrys_latt</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">crys</span><span class="p">,</span> <span class="n">chem</span><span class="p">,</span> <span class="n">ij</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert (i,j), R into PairState&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">ij</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                   <span class="n">j</span><span class="o">=</span><span class="n">ij</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                   <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span>
                   <span class="n">dx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">crys</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">R</span> <span class="o">+</span> <span class="n">crys</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">chem</span><span class="p">][</span><span class="n">ij</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">crys</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">chem</span><span class="p">][</span><span class="n">ij</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span></div>

    <span class="k">def</span> <span class="nf">_asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a proper dict&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="s1">&#39;dx&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">}</span>

<div class="viewcode-block" id="PairState.__sane__"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.PairState.__sane__">[docs]</a>    <span class="k">def</span> <span class="nf">__sane__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crys</span><span class="p">,</span> <span class="n">chem</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine if the dx value makes sense given everything else...&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">crys</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">+</span> <span class="n">crys</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">chem</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">crys</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">chem</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">]))</span></div>

<div class="viewcode-block" id="PairState.iszero"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.PairState.iszero">[docs]</a>    <span class="k">def</span> <span class="nf">iszero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Quicker than self == PairState.zero()&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="PairState.__eq__"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.PairState.__eq__">[docs]</a>    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test for equality--we don&#39;t bother checking dx&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">i</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">j</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">R</span><span class="p">))</span></div>

<div class="viewcode-block" id="PairState.__ne__"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.PairState.__ne__">[docs]</a>    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inequality == not __eq__&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="PairState.__hash__"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.PairState.__hash__">[docs]</a>    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Hash, so that we can make sets of states&quot;&quot;&quot;</span>
        <span class="c1"># return self.i ^ (self.j &lt;&lt; 1) ^ (self.R[0] &lt;&lt; 2) ^ (self.R[1] &lt;&lt; 3) ^ (self.R[2] &lt;&lt; 4)</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">))</span></div>

<div class="viewcode-block" id="PairState.__add__"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.PairState.__add__">[docs]</a>    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add two states: works if and only if self.j == other.i</span>
<span class="sd">        (i,j) R + (j,k) R&#39; = (i,k) R+R&#39;  : works for thinking about transitions...</span>
<span class="sd">        Note: a + b != b + a, and may be that only one of those is even defined</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span> <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iszero</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="n">other</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">iszero</span><span class="p">()</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">i</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span>
                <span class="s1">&#39;Can only add matching endpoints: (</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">)+(</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">) not compatible&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">i</span><span class="p">,</span>
                                                                                         <span class="n">other</span><span class="o">.</span><span class="n">j</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span></div>

<div class="viewcode-block" id="PairState.__neg__"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.PairState.__neg__">[docs]</a>    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Negation of state (swap members of pair)</span>
<span class="sd">        - (i,j) R = (j,i) -R</span>
<span class="sd">        Note: a + (-a) == (-a) + a == 0 because we define what &quot;zero&quot; is.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">R</span><span class="o">=-</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">dx</span><span class="o">=-</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span></div>

<div class="viewcode-block" id="PairState.__sub__"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.PairState.__sub__">[docs]</a>    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a negative:</span>
<span class="sd">        a-b points from initial of a to initial of b if same final state</span>
<span class="sd">        (i,j) R - (k,j) R&#39; = (i,k) R-R&#39;</span>
<span class="sd">        Note: this means that (a-b) + b = a, but b + (a-b) is an error. (b-a) + a = b</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span> <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="o">-</span><span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="PairState.__xor__"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.PairState.__xor__">[docs]</a>    <span class="k">def</span> <span class="nf">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Subtraction on the endpoints (sort of the &quot;opposite&quot; of a-b):</span>
<span class="sd">        a^b points from final of b to final of a if same initial state</span>
<span class="sd">        (i,j) R ^ (i,k) R&#39; = (k,j) R-R&#39;</span>
<span class="sd">        Note: b + (a^b) = a but (a^b) + b is an error. a + (b^a) = b</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span> <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="c1"># if self.iszero(): raise ArithmeticError(&#39;Cannot endpoint substract from zero&#39;)</span>
        <span class="c1"># if other.iszero(): raise ArithmeticError(&#39;Cannot endpoint subtract zero&#39;)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">i</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span>
                <span class="s1">&#39;Can only endpoint subtract matching starts: (</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">)^(</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">) not compatible&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span><span class="p">,</span>
                                                                                                    <span class="n">other</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">j</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span></div>

<div class="viewcode-block" id="PairState.g"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.PairState.g">[docs]</a>    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crys</span><span class="p">,</span> <span class="n">chem</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply group operation.</span>

<span class="sd">        :param crys: crystal</span>
<span class="sd">        :param chem: chemical index</span>
<span class="sd">        :param g: group operation (from crys)</span>
<span class="sd">        :return g*PairState: corresponding to group operation applied to self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gRi</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">gi</span><span class="p">)</span> <span class="o">=</span> <span class="n">crys</span><span class="o">.</span><span class="n">g_pos</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="n">chem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">))</span>
        <span class="n">gRj</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">gj</span><span class="p">)</span> <span class="o">=</span> <span class="n">crys</span><span class="o">.</span><span class="n">g_pos</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="p">(</span><span class="n">chem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span><span class="p">))</span>
        <span class="n">gdx</span> <span class="o">=</span> <span class="n">crys</span><span class="o">.</span><span class="n">g_direc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">gi</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">gj</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">gRj</span> <span class="o">-</span> <span class="n">gRi</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="n">gdx</span><span class="p">)</span></div>

<div class="viewcode-block" id="PairState.__str__"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.PairState.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Human readable version&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">.[0,0,0]:</span><span class="si">{}</span><span class="s2">.[</span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">] (dx=[</span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">])&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span><span class="p">,</span>
                                                                     <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                                                     <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">.[0,0]:</span><span class="si">{}</span><span class="s2">.[</span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">] (dx=[</span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">])&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span><span class="p">,</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">sortkey</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">entry</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">entry</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>

<div class="viewcode-block" id="PairState.PairState_representer"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.PairState.PairState_representer">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">PairState_representer</span><span class="p">(</span><span class="n">dumper</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Output a PairState&quot;&quot;&quot;</span>
        <span class="c1"># asdict() returns an OrderedDictionary, so pass through dict()</span>
        <span class="c1"># had to rewrite _asdict() for some reason...?</span>
        <span class="k">return</span> <span class="n">dumper</span><span class="o">.</span><span class="n">represent_mapping</span><span class="p">(</span><span class="n">PAIRSTATE_YAMLTAG</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">_asdict</span><span class="p">())</span></div>

<div class="viewcode-block" id="PairState.PairState_constructor"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.PairState.PairState_constructor">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">PairState_constructor</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a GroupOp from YAML&quot;&quot;&quot;</span>
        <span class="c1"># ** turns the dictionary into parameters for PairState constructor</span>
        <span class="k">return</span> <span class="n">PairState</span><span class="p">(</span><span class="o">**</span><span class="n">loader</span><span class="o">.</span><span class="n">construct_mapping</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></div></div>


<span class="n">crystal</span><span class="o">.</span><span class="n">yaml</span><span class="o">.</span><span class="n">add_representer</span><span class="p">(</span><span class="n">PairState</span><span class="p">,</span> <span class="n">PairState</span><span class="o">.</span><span class="n">PairState_representer</span><span class="p">)</span>
<span class="n">crystal</span><span class="o">.</span><span class="n">yaml</span><span class="o">.</span><span class="n">add_constructor</span><span class="p">(</span><span class="n">PAIRSTATE_YAMLTAG</span><span class="p">,</span> <span class="n">PairState</span><span class="o">.</span><span class="n">PairState_constructor</span><span class="p">)</span>


<span class="c1"># HDF5 conversion routines: PairState, and list-of-list structures</span>
<div class="viewcode-block" id="PSlist2array"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.PSlist2array">[docs]</a><span class="k">def</span> <span class="nf">PSlist2array</span><span class="p">(</span><span class="n">PSlist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take in a list of pair states; return arrays that can be stored in HDF5 format</span>

<span class="sd">    :param PSlist: list of pair states</span>
<span class="sd">    :return ij: int_array[N][2] = (i,j)</span>
<span class="sd">    :return R: int[N][3]</span>
<span class="sd">    :return dx: float[N][3]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">PSlist</span><span class="p">)</span>
    <span class="n">ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">PSlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">dim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">PS</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">PSlist</span><span class="p">):</span>
        <span class="n">ij</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">ij</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:],</span> <span class="n">dx</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">PS</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">PS</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="n">PS</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">PS</span><span class="o">.</span><span class="n">dx</span>
    <span class="k">return</span> <span class="n">ij</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">dx</span></div>


<div class="viewcode-block" id="array2PSlist"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.array2PSlist">[docs]</a><span class="k">def</span> <span class="nf">array2PSlist</span><span class="p">(</span><span class="n">ij</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">dx</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take in arrays of ij, R, dx (from HDF5), return a list of PairStates</span>

<span class="sd">    :param ij: int_array[N][2] = (i,j)</span>
<span class="sd">    :param R: int[N][3]</span>
<span class="sd">    :param dx: float[N][3]</span>
<span class="sd">    :return PSlist: list of pair states</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">PairState</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">ij0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">j</span><span class="o">=</span><span class="n">ij0</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="o">=</span><span class="n">R0</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="n">dx0</span><span class="p">)</span> <span class="k">for</span> <span class="n">ij0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">dx0</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ij</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">dx</span><span class="p">)]</span></div>


<div class="viewcode-block" id="doublelist2flatlistindex"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.doublelist2flatlistindex">[docs]</a><span class="k">def</span> <span class="nf">doublelist2flatlistindex</span><span class="p">(</span><span class="n">listlist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a list of lists, returns a flattened list and an index array</span>

<span class="sd">    :param listlist: list of lists of objects</span>
<span class="sd">    :return flatlist: flat list of objects (preserving order)</span>
<span class="sd">    :return indexarray: array indexing which original list it came from</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">flatlist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">indexlist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">entries</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">listlist</span><span class="p">):</span>
        <span class="n">flatlist</span> <span class="o">+=</span> <span class="n">entries</span>
        <span class="n">indexlist</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ind</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">flatlist</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indexlist</span><span class="p">)</span></div>


<div class="viewcode-block" id="flatlistindex2doublelist"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.flatlistindex2doublelist">[docs]</a><span class="k">def</span> <span class="nf">flatlistindex2doublelist</span><span class="p">(</span><span class="n">flatlist</span><span class="p">,</span> <span class="n">indexarray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a flattened list and an index array, returns a list of lists</span>

<span class="sd">    :param flatlist: flat list of objects (preserving order)</span>
<span class="sd">    :param indexarray: array indexing which original list it came from</span>
<span class="sd">    :return listlist: list of lists of objects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Nlist</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">indexarray</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">listlist</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nlist</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">entry</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">flatlist</span><span class="p">,</span> <span class="n">indexarray</span><span class="p">):</span>
        <span class="n">listlist</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">listlist</span></div>


<div class="viewcode-block" id="StarSet"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.StarSet">[docs]</a><span class="k">class</span> <span class="nc">StarSet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to construct crystal stars, and be able to efficiently index.</span>

<span class="sd">    Takes in a jumpnetwork, which is used to construct the corresponding stars, a crystal</span>
<span class="sd">    object with which to operate, a specification of the chemical index for the atom moving</span>
<span class="sd">    (needs to be consistent with jumpnetwork and crys), and then the number of shells.</span>

<span class="sd">    In this case, ``shells`` = number of successive &quot;jumps&quot; from a state. As an example,</span>
<span class="sd">    in FCC, 1 shell = 1st neighbor, 2 shell = 1-4th neighbors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="StarSet.__init__"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.StarSet.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">crys</span><span class="p">,</span> <span class="n">chem</span><span class="p">,</span> <span class="n">Nshells</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">originstates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initiates a star set generator for a given jumpnetwork, crystal, and specified</span>
<span class="sd">        chemical index. Does not include &quot;origin states&quot; by default; these are PairStates that</span>
<span class="sd">        iszero() is True; they are only needed if crystal has a nonzero VectorBasis.</span>

<span class="sd">        :param jumpnetwork: list of symmetry unique jumps, as a list of list of tuples; either</span>
<span class="sd">            ``((i,j), dx)`` for jump from i to j with displacement dx, or</span>
<span class="sd">            ``((i,j), R)`` for jump from i in unit cell 0 -&gt; j in unit cell R</span>
<span class="sd">        :param crys: crystal where jumps take place</span>
<span class="sd">        :param chem: chemical index of atom to consider jumps</span>
<span class="sd">        :param Nshells: number of shells to generate</span>
<span class="sd">        :param originstates: include origin states in generate?</span>
<span class="sd">        :param lattice: which form does the jumpnetwork take?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># jumpnetwork_index: list of lists of indices into jumplist; matches structure of jumpnetwork</span>
        <span class="c1"># jumplist: list of jumps, as pair states (i=initial state, j=final state)</span>
        <span class="c1"># states: list of pair states, out to Nshells</span>
        <span class="c1"># Nstates: size of list</span>
        <span class="c1"># stars: list of lists of indices into states; each list are states equivalent by symmetry</span>
        <span class="c1"># Nstars: size of list</span>
        <span class="c1"># index[Nstates]: index of star that state belongs to</span>

        <span class="c1"># empty StarSet</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">crys</span><span class="p">,</span> <span class="n">chem</span><span class="p">)):</span> <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork_index</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of list of indices into...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jumplist</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of our jumps, as PairStates</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">jlist</span> <span class="ow">in</span> <span class="n">jumpnetwork</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork_index</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">ij</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">jlist</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                <span class="n">ind</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">lattice</span><span class="p">:</span>
                    <span class="n">PS</span> <span class="o">=</span> <span class="n">PairState</span><span class="o">.</span><span class="n">fromcrys_latt</span><span class="p">(</span><span class="n">crys</span><span class="p">,</span> <span class="n">chem</span><span class="p">,</span> <span class="n">ij</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">PS</span> <span class="o">=</span> <span class="n">PairState</span><span class="o">.</span><span class="n">fromcrys</span><span class="p">(</span><span class="n">crys</span><span class="p">,</span> <span class="n">chem</span><span class="p">,</span> <span class="n">ij</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">jumplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PS</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crys</span> <span class="o">=</span> <span class="n">crys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chem</span> <span class="o">=</span> <span class="n">chem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">Nshells</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">crys</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span> <span class="n">originstates</span><span class="o">=</span><span class="n">originstates</span><span class="p">)</span></div>

<div class="viewcode-block" id="StarSet.__str__"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.StarSet.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Human readable version&quot;&quot;&quot;</span>
        <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Nshells: </span><span class="si">{}</span><span class="s2">  Nstates: </span><span class="si">{}</span><span class="s2">  Nstars: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nshells</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nstates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nstars</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nstars</span><span class="p">):</span>
            <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot;Star </span><span class="si">{}</span><span class="s2"> (</span><span class="si">{}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stars</span><span class="p">[</span><span class="n">si</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stars</span><span class="p">[</span><span class="n">si</span><span class="p">]:</span>
                <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot;  </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">str</span></div>

<div class="viewcode-block" id="StarSet.generate"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.StarSet.generate">[docs]</a>    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Nshells</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">originstates</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the points and the stars in the set. Does not include &quot;origin states&quot; by default; these</span>
<span class="sd">        are PairStates that iszero() is True; they are only needed if crystal has a nonzero VectorBasis.</span>

<span class="sd">        :param Nshells: number of shells to generate; this is interpreted as subsequent</span>
<span class="sd">          &quot;sums&quot; of jumplist (as we need the solute to be connected to the vacancy by at least one jump)</span>
<span class="sd">        :param threshold: threshold for determining equality with symmetry</span>
<span class="sd">        :param originstates: include origin states in generate?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">Nshells</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Nshells&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nshells</span> <span class="o">=</span> <span class="n">Nshells</span>
        <span class="k">if</span> <span class="n">Nshells</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stateset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumplist</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stateset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="n">lastshell</span> <span class="o">=</span> <span class="n">stateset</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">originstates</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">])):</span>
                <span class="n">stateset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">PairState</span><span class="o">.</span><span class="n">zero</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nshells</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># add all NNvect to last shell produced, always excluding 0</span>
            <span class="c1"># lastshell = [v1+v2 for v1 in lastshell for v2 in self.NNvect if not all(abs(v1 + v2) &lt; threshold)]</span>
            <span class="n">nextshell</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">lastshell</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">s2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">jumplist</span><span class="p">:</span>
                    <span class="c1"># this try/except structure lets us attempt addition and kick out if not possible</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="o">.</span><span class="n">iszero</span><span class="p">():</span>
                        <span class="n">nextshell</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                        <span class="n">stateset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">lastshell</span> <span class="o">=</span> <span class="n">nextshell</span>
        <span class="c1"># now to sort our set of vectors (easiest by magnitude, and then reduce down:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stateset</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="n">PairState</span><span class="o">.</span><span class="n">sortkey</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nstates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nstates</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x2_indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">x2old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">st</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span> <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">x2</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">x2old</span> <span class="o">+</span> <span class="n">threshold</span><span class="p">):</span>
                    <span class="n">x2_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">x2old</span> <span class="o">=</span> <span class="n">x2</span>
            <span class="n">x2_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">))</span>
            <span class="c1"># x2_indices now contains a list of indices with the same magnitudes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stars</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">xmax</span> <span class="ow">in</span> <span class="n">x2_indices</span><span class="p">:</span>
                <span class="n">complist_stars</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># for finding unique stars</span>
                <span class="n">symmstate_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of sets corresponding to those stars...</span>
                <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">):</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span>
                    <span class="c1"># is this a new rep. for a unique star?</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">symmstate_list</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gs</span><span class="p">:</span>
                            <span class="c1"># update star</span>
                            <span class="n">complist_stars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
                            <span class="n">match</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">continue</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                        <span class="c1"># new symmetry point!</span>
                        <span class="n">complist_stars</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xi</span><span class="p">])</span>
                        <span class="n">symmstate_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">g</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">G</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stars</span> <span class="o">+=</span> <span class="n">complist_stars</span>
                <span class="n">xmin</span> <span class="o">=</span> <span class="n">xmax</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stars</span> <span class="o">=</span> <span class="p">[[]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nstars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stars</span><span class="p">)</span>
        <span class="c1"># generate index: which star is each state a member of?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nstates</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexdict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">si</span><span class="p">,</span> <span class="n">star</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stars</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">star</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="n">si</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">indexdict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">xi</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">si</span><span class="p">)</span></div>

<div class="viewcode-block" id="StarSet.addhdf5"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.StarSet.addhdf5">[docs]</a>    <span class="k">def</span> <span class="nf">addhdf5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">HDF5group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an HDF5 representation of object into an HDF5group (needs to already exist).</span>

<span class="sd">        Example: if f is an open HDF5, then StarSet.addhdf5(f.create_group(&#39;StarSet&#39;)) will</span>
<span class="sd">        (1) create the group named &#39;StarSet&#39;, and then (2) put the StarSet representation in that group.</span>

<span class="sd">        :param HDF5group: HDF5 group</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">HDF5group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">HDF5group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;crystal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
        <span class="n">HDF5group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;chem&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chem</span>
        <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;Nshells&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nshells</span>
        <span class="c1"># convert jumplist (list of PS) into arrays to store:</span>
        <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;jumplist_ij&#39;</span><span class="p">],</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;jumplist_R&#39;</span><span class="p">],</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;jumplist_dx&#39;</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">PSlist2array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumplist</span><span class="p">)</span>
        <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;jumplist_Nunique&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork_index</span><span class="p">)</span>
        <span class="n">jumplistinvmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumplist</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">jlist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork_index</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">jlist</span><span class="p">:</span> <span class="n">jumplistinvmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
        <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;jumplist_invmap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">jumplistinvmap</span>
        <span class="c1"># convert states into arrays to store:</span>
        <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;states_ij&#39;</span><span class="p">],</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;states_R&#39;</span><span class="p">],</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;states_dx&#39;</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">PSlist2array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>
        <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;states_index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span></div>

<div class="viewcode-block" id="StarSet.loadhdf5"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.StarSet.loadhdf5">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">loadhdf5</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">crys</span><span class="p">,</span> <span class="n">HDF5group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new StarSet from an HDF5 group.</span>

<span class="sd">        :param crys: crystal object--MUST BE PASSED IN as it is not stored with the StarSet</span>
<span class="sd">        :param HDFgroup: HDF5 group</span>
<span class="sd">        :return StarSet: new StarSet object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">SSet</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># initialize</span>
        <span class="n">SSet</span><span class="o">.</span><span class="n">crys</span> <span class="o">=</span> <span class="n">crys</span>
        <span class="n">SSet</span><span class="o">.</span><span class="n">chem</span> <span class="o">=</span> <span class="n">HDF5group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;chem&#39;</span><span class="p">]</span>
        <span class="n">SSet</span><span class="o">.</span><span class="n">Nshells</span> <span class="o">=</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;Nshells&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="n">SSet</span><span class="o">.</span><span class="n">jumplist</span> <span class="o">=</span> <span class="n">array2PSlist</span><span class="p">(</span><span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;jumplist_ij&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                     <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;jumplist_R&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                     <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;jumplist_dx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">SSet</span><span class="o">.</span><span class="n">jumpnetwork_index</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;jumplist_Nunique&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">jump</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;jumplist_invmap&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
            <span class="n">SSet</span><span class="o">.</span><span class="n">jumpnetwork_index</span><span class="p">[</span><span class="n">jump</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">SSet</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="n">array2PSlist</span><span class="p">(</span><span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;states_ij&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                   <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;states_R&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                   <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;states_dx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">SSet</span><span class="o">.</span><span class="n">Nstates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">SSet</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>
        <span class="n">SSet</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;states_index&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="c1"># construct the states, and the index dictionary:</span>
        <span class="n">SSet</span><span class="o">.</span><span class="n">Nstars</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">SSet</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">SSet</span><span class="o">.</span><span class="n">stars</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">SSet</span><span class="o">.</span><span class="n">Nstars</span><span class="p">)]</span>
        <span class="n">SSet</span><span class="o">.</span><span class="n">indexdict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="n">si</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">SSet</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="n">SSet</span><span class="o">.</span><span class="n">stars</span><span class="p">[</span><span class="n">si</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
            <span class="n">SSet</span><span class="o">.</span><span class="n">indexdict</span><span class="p">[</span><span class="n">SSet</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">xi</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">si</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SSet</span></div>

<div class="viewcode-block" id="StarSet.copy"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.StarSet.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">empty</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of the StarSet; done as efficiently as possible; empty means skip the shells, etc.&quot;&quot;&quot;</span>
        <span class="n">newStarSet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># a little hacky... creates an empty class</span>
        <span class="n">newStarSet</span><span class="o">.</span><span class="n">jumpnetwork_index</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork_index</span><span class="p">)</span>
        <span class="n">newStarSet</span><span class="o">.</span><span class="n">jumplist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jumplist</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">newStarSet</span><span class="o">.</span><span class="n">crys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span>
        <span class="n">newStarSet</span><span class="o">.</span><span class="n">chem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chem</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">empty</span><span class="p">:</span>
            <span class="n">newStarSet</span><span class="o">.</span><span class="n">Nshells</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nshells</span>
            <span class="n">newStarSet</span><span class="o">.</span><span class="n">stars</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stars</span><span class="p">)</span>
            <span class="n">newStarSet</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">newStarSet</span><span class="o">.</span><span class="n">Nstars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nstars</span>
            <span class="n">newStarSet</span><span class="o">.</span><span class="n">Nstates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nstates</span>
            <span class="n">newStarSet</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">newStarSet</span><span class="o">.</span><span class="n">indexdict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexdict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newStarSet</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newStarSet</span></div>

    <span class="c1"># removed combine; all it does is generate(s1.Nshells + s2.Nshells) with lots of checks...</span>
    <span class="c1"># replaced with (more efficient?) __add__ and __iadd__.</span>

<div class="viewcode-block" id="StarSet.__add__"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.StarSet.__add__">[docs]</a>    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add two StarSets together; done by making a copy of one, and iadding&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span> <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nshells</span> <span class="o">&gt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">Nshells</span><span class="p">:</span>
            <span class="n">scopy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">scopy</span><span class="o">.</span><span class="fm">__iadd__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scopy</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">scopy</span><span class="o">.</span><span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scopy</span></div>

<div class="viewcode-block" id="StarSet.__iadd__"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.StarSet.__iadd__">[docs]</a>    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add another StarSet to this one; very similar to generate()&quot;&quot;&quot;</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="mf">1e-8</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span> <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">chem</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">chem</span><span class="p">:</span> <span class="k">return</span> <span class="ne">ArithmeticError</span><span class="p">(</span><span class="s1">&#39;Cannot add different chemistry index&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">Nshells</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nshells</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Nshells</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">Nshells</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stars</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">stars</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Nstars</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">Nstars</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Nstates</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">Nstates</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indexdict</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">indexdict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nshells</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">Nshells</span>
        <span class="n">Nold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nstates</span>
        <span class="n">oldstateset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>
        <span class="n">newstateset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[:</span><span class="n">Nold</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">s2</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
                <span class="c1"># this try/except structure lets us attempt addition and kick out if not possible</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="o">.</span><span class="n">iszero</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">oldstateset</span><span class="p">:</span> <span class="n">newstateset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="c1"># now to sort our set of vectors (easiest by magnitude, and then reduce down:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">+=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">newstateset</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="n">PairState</span><span class="o">.</span><span class="n">sortkey</span><span class="p">)</span>
        <span class="n">Nnew</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>
        <span class="n">x2_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">x2old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">Nold</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">Nold</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nold</span><span class="p">,</span> <span class="n">Nnew</span><span class="p">):</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x2</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">x2old</span> <span class="o">+</span> <span class="n">threshold</span><span class="p">):</span>
                <span class="n">x2_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">x2old</span> <span class="o">=</span> <span class="n">x2</span>
        <span class="n">x2_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Nnew</span><span class="p">)</span>
        <span class="c1"># x2_indices now contains a list of indices with the same magnitudes</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="n">Nold</span>
        <span class="k">for</span> <span class="n">xmax</span> <span class="ow">in</span> <span class="n">x2_indices</span><span class="p">:</span>
            <span class="n">complist_stars</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># for finding unique stars</span>
            <span class="n">symmstate_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of sets corresponding to those stars...</span>
            <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span>
                <span class="c1"># is this a new rep. for a unique star?</span>
                <span class="n">match</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">symmstate_list</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gs</span><span class="p">:</span>
                        <span class="c1"># update star</span>
                        <span class="n">complist_stars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
                        <span class="n">match</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                    <span class="c1"># new symmetry point!</span>
                    <span class="n">complist_stars</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xi</span><span class="p">])</span>
                    <span class="n">symmstate_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">g</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">G</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stars</span> <span class="o">+=</span> <span class="n">complist_stars</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="n">xmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nstates</span> <span class="o">=</span> <span class="n">Nnew</span>
        <span class="c1"># generate new index entries: which star is each state a member of?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nnew</span> <span class="o">-</span> <span class="n">Nold</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>
        <span class="n">Nold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nstars</span>
        <span class="n">Nnew</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stars</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nold</span><span class="p">,</span> <span class="n">Nnew</span><span class="p">):</span>
            <span class="n">star</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stars</span><span class="p">[</span><span class="n">si</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">star</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="n">si</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">indexdict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">xi</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">si</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nstars</span> <span class="o">=</span> <span class="n">Nnew</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="StarSet.__contains__"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.StarSet.__contains__">[docs]</a>    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PS</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return true if PS is in the star&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">PS</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexdict</span></div>

    <span class="c1"># replaces pointindex:</span>
<div class="viewcode-block" id="StarSet.stateindex"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.StarSet.stateindex">[docs]</a>    <span class="k">def</span> <span class="nf">stateindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PS</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the index of pair state PS; None if not found&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexdict</span><span class="p">[</span><span class="n">PS</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="StarSet.starindex"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.StarSet.starindex">[docs]</a>    <span class="k">def</span> <span class="nf">starindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PS</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the index for the star to which pair state PS belongs; None if not found&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexdict</span><span class="p">[</span><span class="n">PS</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="StarSet.symmatch"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.StarSet.symmatch">[docs]</a>    <span class="k">def</span> <span class="nf">symmatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PS1</span><span class="p">,</span> <span class="n">PS2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if there exists a group operation that makes PS1 == PS2.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">PS1</span> <span class="o">==</span> <span class="n">PS2</span><span class="o">.</span><span class="n">g</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">G</span><span class="p">)</span></div>

    <span class="c1"># replaces DoubleStarSet</span>
<div class="viewcode-block" id="StarSet.jumpnetwork_omega1"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.StarSet.jumpnetwork_omega1">[docs]</a>    <span class="k">def</span> <span class="nf">jumpnetwork_omega1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a jumpnetwork corresponding to vacancy jumping while the solute remains fixed.</span>

<span class="sd">        :return jumpnetwork: list of symmetry unique jumps; list of list of tuples (i,f), dx where</span>
<span class="sd">            i,f index into states for the initial and final states, and dx = displacement of vacancy</span>
<span class="sd">            in Cartesian coordinates. Note: if (i,f), dx is present, so if (f,i), -dx</span>
<span class="sd">        :return jumptype: list of indices corresponding to the (original) jump type for each</span>
<span class="sd">            symmetry unique jump; useful for constructing a LIMB approximation, and needed to</span>
<span class="sd">            construct delta_omega</span>
<span class="sd">        :return starpair: list of tuples of the star indices of the i and f states for each</span>
<span class="sd">            symmetry unique jump</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nshells</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>
        <span class="n">jumpnetwork</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">jumptype</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">starpair</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">jt</span><span class="p">,</span> <span class="n">jumpindices</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork_index</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">jump</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">jumplist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">jumpindices</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">PSi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">PSi</span><span class="o">.</span><span class="n">iszero</span><span class="p">():</span> <span class="k">continue</span>
                    <span class="c1"># attempt to add...</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">PSf</span> <span class="o">=</span> <span class="n">PSi</span> <span class="o">+</span> <span class="n">jump</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">PSf</span><span class="o">.</span><span class="n">iszero</span><span class="p">():</span> <span class="k">continue</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stateindex</span><span class="p">(</span><span class="n">PSf</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">continue</span>  <span class="c1"># outside our StarSet</span>
                    <span class="c1"># see if we&#39;ve already generated this jump (works since all of our states are distinct)</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">i0</span> <span class="ow">and</span> <span class="n">f</span> <span class="o">==</span> <span class="n">f0</span> <span class="k">for</span> <span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">f0</span><span class="p">),</span> <span class="n">dx</span> <span class="ow">in</span> <span class="n">jlist</span><span class="p">)</span> <span class="k">for</span> <span class="n">jlist</span> <span class="ow">in</span> <span class="n">jumpnetwork</span><span class="p">):</span> <span class="k">continue</span>
                    <span class="n">dx</span> <span class="o">=</span> <span class="n">PSf</span><span class="o">.</span><span class="n">dx</span> <span class="o">-</span> <span class="n">PSi</span><span class="o">.</span><span class="n">dx</span>
                    <span class="n">jumpnetwork</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symmequivjumplist</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">dx</span><span class="p">))</span>
                    <span class="n">jumptype</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jt</span><span class="p">)</span>
                    <span class="n">starpair</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">f</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">jumptype</span><span class="p">,</span> <span class="n">starpair</span></div>

<div class="viewcode-block" id="StarSet.jumpnetwork_omega2"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.StarSet.jumpnetwork_omega2">[docs]</a>    <span class="k">def</span> <span class="nf">jumpnetwork_omega2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a jumpnetwork corresponding to vacancy exchanging with a solute.</span>

<span class="sd">        :return jumpnetwork: list of symmetry unique jumps; list of list of tuples (i,f), dx where</span>
<span class="sd">            i,f index into states for the initial and final states, and dx = displacement of vacancy</span>
<span class="sd">            in Cartesian coordinates. Note: if (i,f), dx is present, so if (f,i), -dx</span>
<span class="sd">        :return jumptype: list of indices corresponding to the (original) jump type for each</span>
<span class="sd">            symmetry unique jump; useful for constructing a LIMB approximation, and needed to</span>
<span class="sd">            construct delta_omega</span>
<span class="sd">        :return starpair: list of tuples of the star indices of the i and f states for each</span>
<span class="sd">            symmetry unique jump</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nshells</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>
        <span class="n">jumpnetwork</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">jumptype</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">starpair</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">jt</span><span class="p">,</span> <span class="n">jumpindices</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jumpnetwork_index</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">jump</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">jumplist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">jumpindices</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">PSi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">PSi</span><span class="o">.</span><span class="n">iszero</span><span class="p">():</span> <span class="k">continue</span>
                    <span class="c1"># attempt to add...</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">PSf</span> <span class="o">=</span> <span class="n">PSi</span> <span class="o">+</span> <span class="n">jump</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">PSf</span><span class="o">.</span><span class="n">iszero</span><span class="p">():</span> <span class="k">continue</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stateindex</span><span class="p">(</span><span class="o">-</span><span class="n">PSi</span><span class="p">)</span>  <span class="c1"># exchange</span>
                    <span class="c1"># see if we&#39;ve already generated this jump (works since all of our states are distinct)</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">i0</span> <span class="ow">and</span> <span class="n">f</span> <span class="o">==</span> <span class="n">f0</span> <span class="k">for</span> <span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">f0</span><span class="p">),</span> <span class="n">dx</span> <span class="ow">in</span> <span class="n">jlist</span><span class="p">)</span> <span class="k">for</span> <span class="n">jlist</span> <span class="ow">in</span> <span class="n">jumpnetwork</span><span class="p">):</span> <span class="k">continue</span>
                    <span class="n">dx</span> <span class="o">=</span> <span class="o">-</span><span class="n">PSi</span><span class="o">.</span><span class="n">dx</span>  <span class="c1"># the vacancy jumps into the solute position (exchange)</span>
                    <span class="n">jumpnetwork</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symmequivjumplist</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">dx</span><span class="p">))</span>
                    <span class="n">jumptype</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jt</span><span class="p">)</span>
                    <span class="n">starpair</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">f</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">jumptype</span><span class="p">,</span> <span class="n">starpair</span></div>

<div class="viewcode-block" id="StarSet.symmequivjumplist"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.StarSet.symmequivjumplist">[docs]</a>    <span class="k">def</span> <span class="nf">symmequivjumplist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">dx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of tuples of symmetry equivalent jumps</span>

<span class="sd">        :param i: index of initial state</span>
<span class="sd">        :param f: index of final state</span>
<span class="sd">        :param dx: displacement vector</span>
<span class="sd">        :return symmjumplist: list of tuples of ((gi, gf), gdx) for every group op</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">PSi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">PSf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
        <span class="n">symmjumplist</span> <span class="o">=</span> <span class="p">[((</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">),</span> <span class="n">dx</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">f</span><span class="p">:</span> <span class="n">symmjumplist</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">f</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="o">-</span><span class="n">dx</span><span class="p">))</span>  <span class="c1"># i should not equal f... but in case we allow 0 as a jump</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">G</span><span class="p">:</span>
            <span class="n">gi</span><span class="p">,</span> <span class="n">gf</span><span class="p">,</span> <span class="n">gdx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stateindex</span><span class="p">(</span><span class="n">PSi</span><span class="o">.</span><span class="n">g</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">,</span> <span class="n">g</span><span class="p">)),</span> \
                          <span class="bp">self</span><span class="o">.</span><span class="n">stateindex</span><span class="p">(</span><span class="n">PSf</span><span class="o">.</span><span class="n">g</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">,</span> <span class="n">g</span><span class="p">)),</span> \
                          <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">g_direc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">gi</span> <span class="o">==</span> <span class="n">i0</span> <span class="ow">and</span> <span class="n">gf</span> <span class="o">==</span> <span class="n">f0</span> <span class="k">for</span> <span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">f0</span><span class="p">),</span> <span class="n">dx</span> <span class="ow">in</span> <span class="n">symmjumplist</span><span class="p">):</span>
                <span class="n">symmjumplist</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">gi</span><span class="p">,</span> <span class="n">gf</span><span class="p">),</span> <span class="n">gdx</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">gi</span> <span class="o">!=</span> <span class="n">gf</span><span class="p">:</span> <span class="n">symmjumplist</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">gf</span><span class="p">,</span> <span class="n">gi</span><span class="p">),</span> <span class="o">-</span><span class="n">gdx</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">symmjumplist</span></div>

<div class="viewcode-block" id="StarSet.diffgenerate"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.StarSet.diffgenerate">[docs]</a>    <span class="k">def</span> <span class="nf">diffgenerate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S1</span><span class="p">,</span> <span class="n">S2</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a starSet using endpoint subtraction from starset S1 to starset S2. Will</span>
<span class="sd">        include zero. Points from vacancy states of S1 to vacancy states of S2.</span>

<span class="sd">        :param S1: starSet for start</span>
<span class="sd">        :param S2: starSet for final</span>
<span class="sd">        :param threshold: threshold for sorting magnitudes (can influence symmetry efficiency)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">S1</span><span class="o">.</span><span class="n">Nshells</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">S2</span><span class="o">.</span><span class="n">Nshells</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Need to initialize stars&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nshells</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">Nshells</span> <span class="o">+</span> <span class="n">S2</span><span class="o">.</span><span class="n">Nshells</span>  <span class="c1"># an estimate...</span>
        <span class="n">stateset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="c1"># self.states = []</span>
        <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">S1</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s2</span> <span class="ow">in</span> <span class="n">S2</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
                <span class="c1"># this try/except structure lets us attempt addition and kick out if not possible</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">s2</span> <span class="o">^</span> <span class="n">s1</span>  <span class="c1"># points from vacancy state of s1 to vacancy state of s2</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">stateset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="c1"># now to sort our set of vectors (easiest by magnitude, and then reduce down:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stateset</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="n">PairState</span><span class="o">.</span><span class="n">sortkey</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nstates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nstates</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x2_indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">x2old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">st</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span> <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">x2</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">x2old</span> <span class="o">+</span> <span class="n">threshold</span><span class="p">):</span>
                    <span class="n">x2_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">x2old</span> <span class="o">=</span> <span class="n">x2</span>
            <span class="n">x2_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">))</span>
            <span class="c1"># x2_indices now contains a list of indices with the same magnitudes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stars</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">xmax</span> <span class="ow">in</span> <span class="n">x2_indices</span><span class="p">:</span>
                <span class="n">complist_stars</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># for finding unique stars</span>
                <span class="n">symmstate_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of sets corresponding to those stars...</span>
                <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">):</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span>
                    <span class="c1"># is this a new rep. for a unique star?</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">symmstate_list</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gs</span><span class="p">:</span>
                            <span class="c1"># update star</span>
                            <span class="n">complist_stars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
                            <span class="n">match</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">continue</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                        <span class="c1"># new symmetry point!</span>
                        <span class="n">complist_stars</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xi</span><span class="p">])</span>
                        <span class="n">symmstate_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">g</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chem</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">G</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stars</span> <span class="o">+=</span> <span class="n">complist_stars</span>
                <span class="n">xmin</span> <span class="o">=</span> <span class="n">xmax</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stars</span> <span class="o">=</span> <span class="p">[[]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nstars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stars</span><span class="p">)</span>
        <span class="c1"># generate index: which star is each state a member of?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nstates</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexdict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">si</span><span class="p">,</span> <span class="n">star</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stars</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">star</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="n">si</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">indexdict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">xi</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">si</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="zeroclean"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.zeroclean">[docs]</a><span class="k">def</span> <span class="nf">zeroclean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Modify x in place, return 0 if x is below a threshold; useful for &quot;symmetrizing&quot; our expansions&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">op_flags</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;readwrite&#39;</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="VectorStarSet"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.VectorStarSet">[docs]</a><span class="k">class</span> <span class="nc">VectorStarSet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to construct vector star sets, and be able to efficiently index.</span>

<span class="sd">    All based on a StarSet</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="VectorStarSet.__init__"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.VectorStarSet.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initiates a vector-star generator; work with a given star.</span>

<span class="sd">        :param starset: StarSet, from which we pull nearly all of the info that we need</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># vecpos: list of &quot;positions&quot; (state indices) for each vector star (list of lists)</span>
        <span class="c1"># vecvec: list of vectors for each vector star (list of lists of vectors)</span>
        <span class="c1"># Nvstars: number of vector stars</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">starset</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">starset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">starset</span><span class="o">.</span><span class="n">Nshells</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">starset</span><span class="p">)</span></div>

<div class="viewcode-block" id="VectorStarSet.generate"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.VectorStarSet.generate">[docs]</a>    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starset</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the actual vectors stars</span>

<span class="sd">        :param starset: StarSet, from which we pull nearly all of the info that we need</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">starset</span><span class="o">.</span><span class="n">Nshells</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span>
        <span class="k">if</span> <span class="n">starset</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="p">:</span> <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">starset</span> <span class="o">=</span> <span class="n">starset</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">starset</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vecpos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vecvec</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">states</span> <span class="o">=</span> <span class="n">starset</span><span class="o">.</span><span class="n">states</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">starset</span><span class="o">.</span><span class="n">stars</span><span class="p">:</span>
            <span class="c1"># start by generating the parallel star-vector; always trivially present:</span>
            <span class="n">PS0</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">PS0</span><span class="o">.</span><span class="n">iszero</span><span class="p">():</span>
                <span class="c1"># origin state; we can easily generate our vlist</span>
                <span class="n">vlist</span> <span class="o">=</span> <span class="n">starset</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">vectlist</span><span class="p">(</span><span class="n">starset</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">VectorBasis</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="o">.</span><span class="n">chem</span><span class="p">,</span> <span class="n">PS0</span><span class="o">.</span><span class="n">i</span><span class="p">)))</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>  <span class="c1"># normalization factor; vectors are already normalized</span>
                <span class="n">vlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="o">*</span> <span class="n">scale</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vlist</span><span class="p">]</span>
                <span class="c1"># add the positions</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vlist</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vecpos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                    <span class="n">veclist</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">PSi</span> <span class="ow">in</span> <span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]:</span>
                        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">starset</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">G</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">PS0</span><span class="o">.</span><span class="n">g</span><span class="p">(</span><span class="n">starset</span><span class="o">.</span><span class="n">crys</span><span class="p">,</span> <span class="n">starset</span><span class="o">.</span><span class="n">chem</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="o">==</span> <span class="n">PSi</span><span class="p">:</span>
                                <span class="n">veclist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">starset</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">g_direc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                                <span class="k">break</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vecvec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">veclist</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># not an origin state</span>
                <span class="n">vpara</span> <span class="o">=</span> <span class="n">PS0</span><span class="o">.</span><span class="n">dx</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vpara</span><span class="p">,</span> <span class="n">vpara</span><span class="p">))</span>  <span class="c1"># normalization factor</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vecpos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vecvec</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">states</span><span class="p">[</span><span class="n">si</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span> <span class="o">*</span> <span class="n">scale</span> <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="n">s</span><span class="p">])</span>
                <span class="c1"># next, try to generate perpendicular star-vectors, if present:</span>
                <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">v0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">vpara</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">:</span>
                        <span class="n">v0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">vpara</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
                    <span class="n">v1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">vpara</span><span class="p">,</span> <span class="n">v0</span><span class="p">)</span>
                    <span class="c1"># normalization:</span>
                    <span class="n">v0</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v0</span><span class="p">))</span>
                    <span class="n">v1</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v1</span><span class="p">))</span>
                    <span class="n">Nvect</span> <span class="o">=</span> <span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># 2d is very simple...</span>
                    <span class="n">v0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vpara</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">vpara</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                    <span class="n">v0</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v0</span><span class="p">))</span>
                    <span class="n">Nvect</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="c1"># run over the invariant group operations for state PS0</span>
                <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">G</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">Nvect</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">PS0</span> <span class="o">!=</span> <span class="n">PS0</span><span class="o">.</span><span class="n">g</span><span class="p">(</span><span class="n">starset</span><span class="o">.</span><span class="n">crys</span><span class="p">,</span> <span class="n">starset</span><span class="o">.</span><span class="n">chem</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span> <span class="k">continue</span>
                    <span class="n">gv0</span> <span class="o">=</span> <span class="n">starset</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">g_direc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">v0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">Nvect</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># we only need to check that we still have an invariant vector</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v0</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span><span class="s1">&#39;Somehow got unnormalized vector?&#39;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">gv0</span><span class="p">,</span> <span class="n">v0</span><span class="p">):</span> <span class="n">Nvect</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">Nvect</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v0</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span><span class="s1">&#39;Somehow got unnormalized vector?&#39;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v1</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span><span class="s1">&#39;Somehow got unnormalized vector?&#39;</span><span class="p">)</span>
                        <span class="n">gv1</span> <span class="o">=</span> <span class="n">starset</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">g_direc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
                        <span class="n">g00</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">gv0</span><span class="p">)</span>
                        <span class="n">g11</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">gv1</span><span class="p">)</span>
                        <span class="n">g01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">gv1</span><span class="p">)</span>
                        <span class="n">g10</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">gv0</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">abs</span><span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">g00</span> <span class="o">*</span> <span class="n">g11</span> <span class="o">-</span> <span class="n">g01</span> <span class="o">*</span> <span class="n">g10</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">g01</span> <span class="o">-</span> <span class="n">g10</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
                            <span class="c1"># we don&#39;t have an orthogonal matrix, or we have a rotation, so kick out</span>
                            <span class="n">Nvect</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">g00</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">g11</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">):</span>
                            <span class="c1"># if we don&#39;t have the identify matrix, then we have to find the one vector that survives</span>
                            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">g00</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">:</span>
                                <span class="n">Nvect</span> <span class="o">=</span> <span class="mi">1</span>
                                <span class="k">continue</span>
                            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">g11</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">:</span>
                                <span class="n">v0</span> <span class="o">=</span> <span class="n">v1</span>
                                <span class="n">Nvect</span> <span class="o">=</span> <span class="mi">1</span>
                                <span class="k">continue</span>
                            <span class="n">v0</span> <span class="o">=</span> <span class="p">(</span><span class="n">g01</span> <span class="o">*</span> <span class="n">v0</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">g00</span><span class="p">)</span> <span class="o">*</span> <span class="n">v1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">g01</span> <span class="o">*</span> <span class="n">g10</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">g00</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                            <span class="n">Nvect</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="c1"># so... do we have any vectors to add?</span>
                <span class="k">if</span> <span class="n">Nvect</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">v0</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v0</span><span class="p">))</span>
                    <span class="n">vlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">v0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">Nvect</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">v1</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v1</span><span class="p">))</span>
                        <span class="n">vlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
                    <span class="c1"># add the positions</span>
                    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vlist</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">vecpos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                        <span class="n">veclist</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">PSi</span> <span class="ow">in</span> <span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]:</span>
                            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">starset</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">G</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">PS0</span><span class="o">.</span><span class="n">g</span><span class="p">(</span><span class="n">starset</span><span class="o">.</span><span class="n">crys</span><span class="p">,</span> <span class="n">starset</span><span class="o">.</span><span class="n">chem</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="o">==</span> <span class="n">PSi</span><span class="p">:</span>
                                    <span class="n">veclist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">starset</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">g_direc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                                    <span class="k">break</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">vecvec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">veclist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vecpos</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generateouter</span><span class="p">()</span></div>

<div class="viewcode-block" id="VectorStarSet.generateouter"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.VectorStarSet.generateouter">[docs]</a>    <span class="k">def</span> <span class="nf">generateouter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate our outer products for our star-vectors.</span>

<span class="sd">        :return outer: array [3, 3, Nvstars, Nvstars]</span>
<span class="sd">            outer[:, :, i, j] is the 3x3 tensor outer product for two vector-stars vs[i] and vs[j]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># dim = len(self.vecvec[0][0])</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">dim</span>
        <span class="n">outer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sR0</span><span class="p">,</span> <span class="n">sv0</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vecpos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vecvec</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">sR1</span><span class="p">,</span> <span class="n">sv1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vecpos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vecvec</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">sR0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">sR1</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">outer</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span> <span class="k">for</span> <span class="n">v0</span><span class="p">,</span> <span class="n">v1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sv0</span><span class="p">,</span> <span class="n">sv1</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">zeroclean</span><span class="p">(</span><span class="n">outer</span><span class="p">)</span></div>

<div class="viewcode-block" id="VectorStarSet.addhdf5"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.VectorStarSet.addhdf5">[docs]</a>    <span class="k">def</span> <span class="nf">addhdf5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">HDF5group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an HDF5 representation of object into an HDF5group (needs to already exist).</span>

<span class="sd">        Example: if f is an open HDF5, then StarSet.addhdf5(f.create_group(&#39;VectorStarSet&#39;)) will</span>
<span class="sd">          (1) create the group named &#39;VectorStarSet&#39;, and then (2) put the VectorStarSet</span>
<span class="sd">          representation in that group.</span>

<span class="sd">        :param HDF5group: HDF5 group</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">HDF5group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;Nvstars&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span>
        <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;vecposlist&#39;</span><span class="p">],</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;vecposindex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">doublelist2flatlistindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vecpos</span><span class="p">)</span>
        <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;vecveclist&#39;</span><span class="p">],</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;vecvecindex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">doublelist2flatlistindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vecvec</span><span class="p">)</span>
        <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;outer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outer</span></div>

<div class="viewcode-block" id="VectorStarSet.loadhdf5"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.VectorStarSet.loadhdf5">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">loadhdf5</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">SSet</span><span class="p">,</span> <span class="n">HDF5group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new VectorStarSet from an HDF5 group.</span>

<span class="sd">        :param SSet: StarSet--MUST BE PASSED IN as it is not stored with the VectorStarSet</span>
<span class="sd">        :param HDFgroup: HDF5 group</span>
<span class="sd">        :return VectorStarSet: new VectorStarSet object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">VSSet</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># initialize</span>
        <span class="n">VSSet</span><span class="o">.</span><span class="n">starset</span> <span class="o">=</span> <span class="n">SSet</span>
        <span class="n">VSSet</span><span class="o">.</span><span class="n">Nvstars</span> <span class="o">=</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;Nvstars&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="n">VSSet</span><span class="o">.</span><span class="n">vecpos</span> <span class="o">=</span> <span class="n">flatlistindex2doublelist</span><span class="p">(</span><span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;vecposlist&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                                <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;vecposindex&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">VSSet</span><span class="o">.</span><span class="n">vecvec</span> <span class="o">=</span> <span class="n">flatlistindex2doublelist</span><span class="p">(</span><span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;vecveclist&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                                <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;vecvecindex&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">VSSet</span><span class="o">.</span><span class="n">outer</span> <span class="o">=</span> <span class="n">HDF5group</span><span class="p">[</span><span class="s1">&#39;outer&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="n">VSSet</span></div>

<div class="viewcode-block" id="VectorStarSet.GFexpansion"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.VectorStarSet.GFexpansion">[docs]</a>    <span class="k">def</span> <span class="nf">GFexpansion</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the GF matrix expansion in terms of the star vectors, and indexed</span>
<span class="sd">        to GFstarset.</span>

<span class="sd">        :return GFexpansion: array[Nsv, Nsv, NGFstars]</span>
<span class="sd">            the GF matrix[i, j] = sum(GFexpansion[i, j, k] * GF(starGF[k]))</span>
<span class="sd">        :return GFstarset: starSet corresponding to the GF</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">GFstarset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">empty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">GFstarset</span><span class="o">.</span><span class="n">diffgenerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="p">)</span>
        <span class="n">GFexpansion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">,</span> <span class="n">GFstarset</span><span class="o">.</span><span class="n">Nstars</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">si</span><span class="p">,</span> <span class="n">vi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vecpos</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">vecvec</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">sj</span><span class="p">,</span> <span class="n">vj</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vecpos</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">vecvec</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">sj</span><span class="p">]</span> <span class="o">^</span> <span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">si</span><span class="p">]</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="n">GFstarset</span><span class="o">.</span><span class="n">starindex</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ArithmeticError</span><span class="p">(</span><span class="s1">&#39;GF star not large enough to include </span><span class="si">{}</span><span class="s1">?&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ds</span><span class="p">))</span>
                        <span class="n">GFexpansion</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">vj</span><span class="p">)</span>
        <span class="c1"># symmetrize</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                <span class="n">GFexpansion</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">GFexpansion</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># cleanup on return:</span>
        <span class="k">return</span> <span class="n">zeroclean</span><span class="p">(</span><span class="n">GFexpansion</span><span class="p">),</span> <span class="n">GFstarset</span></div>

<div class="viewcode-block" id="VectorStarSet.rateexpansions"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.VectorStarSet.rateexpansions">[docs]</a>    <span class="k">def</span> <span class="nf">rateexpansions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">jumptype</span><span class="p">,</span> <span class="n">omega2</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the omega0 and omega1 matrix expansions in terms of the jumpnetwork;</span>
<span class="sd">        includes the escape terms separately. The escape terms are tricky because they have</span>
<span class="sd">        probability factors that differ from the transitions; the PS (pair stars) is useful for</span>
<span class="sd">        finding this. We just call it the &#39;probfactor&#39; below.</span>
<span class="sd">        *Note:* this used to be separated into rate0expansion, and rate1expansion, and</span>
<span class="sd">        partly in bias1expansion. Note also that if jumpnetwork_omega2 is passed, it also works</span>
<span class="sd">        for that. However, in that case we have a different approach for the calculation of</span>
<span class="sd">        rate0expansion: if there are origin states, then we need to &quot;jump&quot; to those; if there</span>
<span class="sd">        is a non-empty VectorBasis we will want to account for them there.</span>

<span class="sd">        :param jumpnetwork: jumpnetwork of symmetry unique omega1-type jumps,</span>
<span class="sd">            corresponding to our starset. List of lists of (IS, FS), dx tuples, where IS and FS</span>
<span class="sd">            are indices corresponding to states in our starset.</span>
<span class="sd">        :param jumptype: specific omega0 jump type that the jump corresponds to</span>
<span class="sd">        :param omega2: (optional) are we dealing with the omega2 list, so we need to remove</span>
<span class="sd">            origin states? (default=False)</span>
<span class="sd">        :return rate0expansion: array[Nsv, Nsv, Njump_omega0]</span>
<span class="sd">            the omega0 matrix[i, j] = sum(rate0expansion[i, j, k] * omega0[k]); *IF* NVB&gt;0</span>
<span class="sd">            we &quot;hijack&quot; this and use it for [NVB, Nsv, Njump_omega0], as we&#39;re doing an omega2</span>
<span class="sd">            calc and rate0expansion won&#39;t be used *anyway*.</span>
<span class="sd">        :return rate0escape: array[Nsv, Njump_omega0]</span>
<span class="sd">            the escape contributions: omega0[i,i] += sum(rate0escape[i,k]*omega0[k]*probfactor0(PS[k]))</span>
<span class="sd">        :return rate1expansion: array[Nsv, Nsv, Njump_omega1]</span>
<span class="sd">            the omega1 matrix[i, j] = sum(rate1expansion[i, j, k] * omega1[k])</span>
<span class="sd">        :return rate1escape: array[Nsv, Njump_omega1]</span>
<span class="sd">            the escape contributions: omega1[i,i] += sum(rate1escape[i,k]*omega1[k]*probfactor(PS[k]))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span>
        <span class="n">rate0expansion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="o">.</span><span class="n">jumpnetwork_index</span><span class="p">)))</span>
        <span class="n">rate1expansion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">jumpnetwork</span><span class="p">)))</span>
        <span class="n">rate0escape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="o">.</span><span class="n">jumpnetwork_index</span><span class="p">)))</span>
        <span class="n">rate1escape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">jumpnetwork</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">jumplist</span><span class="p">,</span> <span class="n">jt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">jumptype</span><span class="p">):</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">IS</span><span class="p">,</span> <span class="n">FS</span><span class="p">),</span> <span class="n">dx</span> <span class="ow">in</span> <span class="n">jumplist</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">Ri</span><span class="p">,</span> <span class="n">vi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vecpos</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">vecvec</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                        <span class="k">if</span> <span class="n">Ri</span> <span class="o">==</span> <span class="n">IS</span><span class="p">:</span>
                            <span class="n">rate0escape</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">jt</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">vi</span><span class="p">)</span>
                            <span class="n">rate1escape</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">vi</span><span class="p">)</span>
                            <span class="c1"># for j in range(i+1):</span>
                            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">):</span>
                                <span class="k">for</span> <span class="n">Rj</span><span class="p">,</span> <span class="n">vj</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vecpos</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">vecvec</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                                    <span class="k">if</span> <span class="n">Rj</span> <span class="o">==</span> <span class="n">FS</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="ow">not</span> <span class="n">omega2</span><span class="p">:</span> <span class="n">rate0expansion</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">jt</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">vj</span><span class="p">)</span>
                                        <span class="n">rate1expansion</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">vj</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">omega2</span><span class="p">:</span>
                                <span class="c1"># find the &quot;origin state&quot; corresponding to the solute; &quot;remove&quot; those rates</span>
                                <span class="n">OSindex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="o">.</span><span class="n">stateindex</span><span class="p">(</span><span class="n">PairState</span><span class="o">.</span><span class="n">zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">IS</span><span class="p">]</span><span class="o">.</span><span class="n">i</span><span class="p">,</span>
                                                                                 <span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
                                <span class="k">if</span> <span class="n">OSindex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">):</span>
                                        <span class="k">for</span> <span class="n">Rj</span><span class="p">,</span> <span class="n">vj</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vecpos</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">vecvec</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                                            <span class="k">if</span> <span class="n">Rj</span> <span class="o">==</span> <span class="n">OSindex</span><span class="p">:</span>
                                                <span class="n">rate0expansion</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">jt</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">vj</span><span class="p">)</span>
                                                <span class="n">rate0expansion</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">jt</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">vj</span><span class="p">)</span>
                                                <span class="n">rate0escape</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">jt</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vj</span><span class="p">,</span> <span class="n">vj</span><span class="p">)</span>
        <span class="c1"># cleanup on return</span>
        <span class="k">return</span> <span class="n">zeroclean</span><span class="p">(</span><span class="n">rate0expansion</span><span class="p">),</span> <span class="n">zeroclean</span><span class="p">(</span><span class="n">rate0escape</span><span class="p">),</span> \
               <span class="n">zeroclean</span><span class="p">(</span><span class="n">rate1expansion</span><span class="p">),</span> <span class="n">zeroclean</span><span class="p">(</span><span class="n">rate1escape</span><span class="p">)</span></div>

<div class="viewcode-block" id="VectorStarSet.biasexpansions"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.VectorStarSet.biasexpansions">[docs]</a>    <span class="k">def</span> <span class="nf">biasexpansions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">jumptype</span><span class="p">,</span> <span class="n">omega2</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the bias1 and bias0 vector expansion in terms of the jumpnetwork.</span>
<span class="sd">        We return the bias0 contribution so that the db = bias1 - bias0 can be determined.</span>
<span class="sd">        This saves us from having to deal with issues with our outer shell where we only</span>
<span class="sd">        have a fraction of the escapes, but as long as the kinetic shell is one more than</span>
<span class="sd">        the thermodynamics (so that the interaction energy is 0, hence no change in probability),</span>
<span class="sd">        this will work. The PS (pair stars) is useful for including the probability factor</span>
<span class="sd">        for the endpoint of the jump; we just call it the &#39;probfactor&#39; below.</span>
<span class="sd">        *Note:* this used to be separated into bias1expansion, and bias2expansion,and</span>
<span class="sd">        had terms that are now in rateexpansions.</span>
<span class="sd">        Note also that if jumpnetwork_omega2 is passed, it also works for that. However,</span>
<span class="sd">        in that case we have a different approach for the calculation of bias1expansion:</span>
<span class="sd">        if there are origin states, they get the negative summed bias of the others.</span>

<span class="sd">        :param jumpnetwork: jumpnetwork of symmetry unique omega1-type jumps,</span>
<span class="sd">            corresponding to our starset. List of lists of (IS, FS), dx tuples, where IS and FS</span>
<span class="sd">            are indices corresponding to states in our starset.</span>
<span class="sd">        :param jumptype: specific omega0 jump type that the jump corresponds to</span>
<span class="sd">        :param omega2: (optional) are we dealing with the omega2 list, so we need to remove</span>
<span class="sd">            origin states? (default=False)</span>
<span class="sd">        :return bias0expansion: array[Nsv, Njump_omega0]</span>
<span class="sd">            the gen0 vector[i] = sum(bias0expasion[i, k] * sqrt(probfactor0[PS[k]]) * omega0[k])</span>
<span class="sd">        :return bias1expansion: array[Nsv, Njump_omega1]</span>
<span class="sd">            the gen1 vector[i] = sum(bias1expansion[i, k] * sqrt(probfactor[PS[k]] * omega1[k])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span>
        <span class="n">bias0expansion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="o">.</span><span class="n">jumpnetwork_index</span><span class="p">)))</span>
        <span class="n">bias1expansion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">jumpnetwork</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">jumplist</span><span class="p">,</span> <span class="n">jt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">jumptype</span><span class="p">):</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">IS</span><span class="p">,</span> <span class="n">FS</span><span class="p">),</span> <span class="n">dx</span> <span class="ow">in</span> <span class="n">jumplist</span><span class="p">:</span>
                <span class="c1"># run through the star-vectors; just use first as representative</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">svR</span><span class="p">,</span> <span class="n">svv</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vecpos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vecvec</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">svR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">IS</span><span class="p">:</span>
                        <span class="n">geom_bias</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">svv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">svR</span><span class="p">)</span>
                        <span class="n">bias1expansion</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">geom_bias</span>
                        <span class="n">bias0expansion</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">jt</span><span class="p">]</span> <span class="o">+=</span> <span class="n">geom_bias</span>
                <span class="k">if</span> <span class="n">omega2</span><span class="p">:</span>
                    <span class="c1"># find the &quot;origin state&quot; corresponding to the solute; incorporate the change in bias</span>
                    <span class="n">OSindex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="o">.</span><span class="n">stateindex</span><span class="p">(</span><span class="n">PairState</span><span class="o">.</span><span class="n">zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">IS</span><span class="p">]</span><span class="o">.</span><span class="n">i</span><span class="p">,</span>
                                                                     <span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">OSindex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">Rj</span><span class="p">,</span> <span class="n">vj</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vecpos</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">vecvec</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                                <span class="k">if</span> <span class="n">Rj</span> <span class="o">==</span> <span class="n">OSindex</span><span class="p">:</span>
                                    <span class="n">geom_bias</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vj</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
                                    <span class="n">bias1expansion</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">geom_bias</span>  <span class="c1"># do we need this??</span>
                                    <span class="n">bias0expansion</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">jt</span><span class="p">]</span> <span class="o">+=</span> <span class="n">geom_bias</span>

        <span class="c1"># cleanup on return</span>
        <span class="k">return</span> <span class="n">zeroclean</span><span class="p">(</span><span class="n">bias0expansion</span><span class="p">),</span> <span class="n">zeroclean</span><span class="p">(</span><span class="n">bias1expansion</span><span class="p">)</span></div>

    <span class="c1"># this is *almost* a static method--it only need to know how many omega0 type jumps there are</span>
    <span class="c1"># in the starset. We *could* make it static and use max(jumptype), but that may not be strictly safe</span>
<div class="viewcode-block" id="VectorStarSet.bareexpansions"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.VectorStarSet.bareexpansions">[docs]</a>    <span class="k">def</span> <span class="nf">bareexpansions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jumpnetwork</span><span class="p">,</span> <span class="n">jumptype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the bare diffusivity expansion in terms of the jumpnetwork.</span>
<span class="sd">        We return the reference (0) contribution so that the change can be determined; this</span>
<span class="sd">        is useful for the vacancy contributions.</span>
<span class="sd">        This saves us from having to deal with issues with our outer shell where we only</span>
<span class="sd">        have a fraction of the escapes, but as long as the kinetic shell is one more than</span>
<span class="sd">        the thermodynamics (so that the interaction energy is 0, hence no change in probability),</span>
<span class="sd">        this will work. The PS (pair stars) is useful for including the probability factor</span>
<span class="sd">        for the endpoint of the jump; we just call it the &#39;probfactor&#39; below.</span>

<span class="sd">        Note also: this *currently assumes* that the displacement vector *does not change* between</span>
<span class="sd">        omega0 and omega(1/2).</span>

<span class="sd">        :param jumpnetwork: jumpnetwork of symmetry unique omega1-type jumps,</span>
<span class="sd">            corresponding to our starset. List of lists of (IS, FS), dx tuples, where IS and FS</span>
<span class="sd">            are indices corresponding to states in our starset.</span>
<span class="sd">        :param jumptype: specific omega0 jump type that the jump corresponds to</span>
<span class="sd">        :return D0expansion: array[3,3, Njump_omega0]</span>
<span class="sd">            the D0[a,b,jt] = sum(D0expansion[a,b, jt] * sqrt(probfactor0[PS[jt][0]]*probfactor0[PS[jt][1]) * omega0[jt])</span>
<span class="sd">        :return D1expansion: array[3,3, Njump_omega1]</span>
<span class="sd">            the D1[a,b,k] = sum(D1expansion[a,b, k] * sqrt(probfactor[PS[k][0]]*probfactor[PS[k][1]) * omega[k])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># dim = len(jumpnetwork[0][0][1])</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">dim</span>
        <span class="n">D0expansion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="o">.</span><span class="n">jumpnetwork_index</span><span class="p">)))</span>
        <span class="n">D1expansion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">jumpnetwork</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">jt</span><span class="p">,</span> <span class="n">jumplist</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="n">jumptype</span><span class="p">,</span> <span class="n">jumpnetwork</span><span class="p">):</span>
            <span class="n">d0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span> <span class="k">for</span> <span class="n">ISFS</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="n">jumplist</span><span class="p">)</span>  <span class="c1"># we don&#39;t need initial/final state</span>
            <span class="n">D0expansion</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">jt</span><span class="p">]</span> <span class="o">+=</span> <span class="n">d0</span>
            <span class="n">D1expansion</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">d0</span>
        <span class="c1"># cleanup on return</span>
        <span class="k">return</span> <span class="n">zeroclean</span><span class="p">(</span><span class="n">D0expansion</span><span class="p">),</span> <span class="n">zeroclean</span><span class="p">(</span><span class="n">D1expansion</span><span class="p">)</span></div>

<div class="viewcode-block" id="VectorStarSet.originstateVectorBasisfolddown"><a class="viewcode-back" href="../CrystalStars.html#crystalStars.VectorStarSet.originstateVectorBasisfolddown">[docs]</a>    <span class="k">def</span> <span class="nf">originstateVectorBasisfolddown</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elemtype</span><span class="o">=</span><span class="s1">&#39;solute&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the expansion to &quot;fold down&quot; from vector stars to origin states.</span>

<span class="sd">        :param elemtype: &#39;solute&#39; of &#39;vacancy&#39;, depending on which site we need to reduce</span>
<span class="sd">        :return OSindices: list of indices corresponding to origin states</span>
<span class="sd">        :return folddown: [NOS, Nvstars] to map vector stars to origin states</span>
<span class="sd">        :return OS_VB: [NOS, Nsites, 3] mapping of origin state to a vector basis</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;solute&#39;</span><span class="p">:</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;vacancy&#39;</span><span class="p">:</span> <span class="s1">&#39;j&#39;</span><span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">elemtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;elemtype needs to be &quot;solute&quot; or &quot;vacancy&quot; not </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">elemtype</span><span class="p">))</span>
        <span class="n">OSindices</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vecpos</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">iszero</span><span class="p">()]</span>
        <span class="n">NOS</span><span class="p">,</span> <span class="n">Nsites</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">OSindices</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="o">.</span><span class="n">chem</span><span class="p">])</span>
        <span class="n">folddown</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NOS</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nvstars</span><span class="p">))</span>
        <span class="c1"># dim = len(self.vecvec[0][0])</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="o">.</span><span class="n">crys</span><span class="o">.</span><span class="n">dim</span>
        <span class="n">OS_VB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NOS</span><span class="p">,</span> <span class="n">Nsites</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">NOS</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">OSindices</span><span class="p">,</span> <span class="n">folddown</span><span class="p">,</span> <span class="n">OS_VB</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ni</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">OSindices</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">OS</span><span class="p">,</span> <span class="n">OSv</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vecpos</span><span class="p">[</span><span class="n">ni</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">vecvec</span><span class="p">[</span><span class="n">ni</span><span class="p">]):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">OS</span><span class="p">],</span> <span class="n">attr</span><span class="p">)</span>
                <span class="n">OS_VB</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">OSv</span><span class="p">[:]</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">svR</span><span class="p">,</span> <span class="n">svv</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vecpos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vecvec</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">svR</span><span class="p">,</span> <span class="n">svv</span><span class="p">):</span>
                        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">starset</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">attr</span><span class="p">)</span> <span class="o">==</span> <span class="n">index</span><span class="p">:</span>
                            <span class="n">folddown</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">OSv</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="c1"># cleanup on return</span>
        <span class="k">return</span> <span class="n">OSindices</span><span class="p">,</span> <span class="n">zeroclean</span><span class="p">(</span><span class="n">folddown</span><span class="p">),</span> <span class="n">zeroclean</span><span class="p">(</span><span class="n">OS_VB</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Dallas R. Trinkle

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>