

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Welcome to Onsager’s documentation! &mdash; Onsager 0.9 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Onsager 0.9 documentation" href="#"/>
        <link rel="next" title="Onsager" href="includeme.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="#" class="icon icon-home"> Onsager
          

          
          </a>

          
            
            
              <div class="version">
                0.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="includeme.html">Onsager</a></li>
<li class="toctree-l1"><a class="reference internal" href="includeme.html#references">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="includeme.html#contributors">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="includeme.html#support">Support</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="#">Onsager</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="#">Docs</a> &raquo;</li>
      
    <li>Welcome to Onsager&#8217;s documentation!</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/index.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="welcome-to-onsager-s-documentation">
<h1>Welcome to Onsager&#8217;s documentation!<a class="headerlink" href="#welcome-to-onsager-s-documentation" title="Permalink to this headline">¶</a></h1>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="includeme.html">Onsager</a></li>
<li class="toctree-l1"><a class="reference internal" href="includeme.html#references">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="includeme.html#contributors">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="includeme.html#support">Support</a></li>
</ul>
</div>
<p>Crystal:</p>
<span class="target" id="module-crystal"></span><p>Crystal class</p>
<p>Class to store definition of a crystal, along with some analysis
1. geometric analysis (nearest neighbor displacements)
2. space group operations
3. point group operations for each basis position
4. Wyckoff position generation (for interstitials)</p>
<dl class="function">
<dt id="crystal.CombineTensorBasis">
<code class="descclassname">crystal.</code><code class="descname">CombineTensorBasis</code><span class="sig-paren">(</span><em>b1</em>, <em>b2</em>, <em>symmetric=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#CombineTensorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.CombineTensorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines (intersects) two tensor spaces into one; uses SVD to compute null space.
:param b1: list of tensors
:param b2: list of tensors
:return: list of tensors</p>
</dd></dl>

<dl class="function">
<dt id="crystal.CombineVectorBasis">
<code class="descclassname">crystal.</code><code class="descname">CombineVectorBasis</code><span class="sig-paren">(</span><em>b1</em>, <em>b2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#CombineVectorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.CombineVectorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines (intersects) two vector spaces into one.
:param b1: (dim, vect) &#8211; dimensionality (0..3), vector defining line direction (1) or plane normal (2)
:param b2: (dim, vect)
:return: (dim, vect)</p>
</dd></dl>

<dl class="class">
<dt id="crystal.Crystal">
<em class="property">class </em><code class="descclassname">crystal.</code><code class="descname">Crystal</code><span class="sig-paren">(</span><em>lattice</em>, <em>basis</em>, <em>chemistry=None</em>, <em>NOSYM=False</em>, <em>noreduce=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal" title="Permalink to this definition">¶</a></dt>
<dd><p>A class that defines a crystal, as well as the symmetry analysis that goes along with it.</p>
<dl class="classmethod">
<dt id="crystal.Crystal.BCC">
<em class="property">classmethod </em><code class="descname">BCC</code><span class="sig-paren">(</span><em>a0</em>, <em>chemistry=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.BCC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.BCC" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a body-centered cubic crystal with lattice constant a0
:param a0: lattice constant
:return: BCC crystal</p>
</dd></dl>

<dl class="classmethod">
<dt id="crystal.Crystal.FCC">
<em class="property">classmethod </em><code class="descname">FCC</code><span class="sig-paren">(</span><em>a0</em>, <em>chemistry=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.FCC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.FCC" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a face-centered cubic crystal with lattice constant a0
:param a0: lattice constant
:return: FCC crystal</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.FullVectorBasis">
<code class="descname">FullVectorBasis</code><span class="sig-paren">(</span><em>chem=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.FullVectorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.FullVectorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate our full vector basis, using the information from our crystal
:param chem: (optional) chemical index to consider; otherwise return a list of such
:return: (list) of our unique vector basis lattice functions, normalized; each is an array
:return: (list) of ouf VV &#8220;outer&#8221; expansion</p>
</dd></dl>

<dl class="classmethod">
<dt id="crystal.Crystal.HCP">
<em class="property">classmethod </em><code class="descname">HCP</code><span class="sig-paren">(</span><em>a0</em>, <em>c_a=1.6329931618554521</em>, <em>chemistry=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.HCP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.HCP" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a hexagonal closed packed crystal with lattice constant a0, c/a ratio c_a
:param a0: lattice constant
:param c_a: c/a ratio
:return: HCP crystal</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.SymmTensorBasis">
<code class="descname">SymmTensorBasis</code><span class="sig-paren">(</span><em>ind</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.SymmTensorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.SymmTensorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the symmetric tensor basis corresponding to an atomic site
:param ind: tuple index for atom
:return: (dim, vect) &#8211; dimension of basis, vector = normal for plane, direction for line</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.VectorBasis">
<code class="descname">VectorBasis</code><span class="sig-paren">(</span><em>ind</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.VectorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.VectorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the vector basis corresponding to an atomic site
:param ind: tuple index for atom
:return: (dim, vect) &#8211; dimension of basis, vector = normal for plane, direction for line</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.Wyckoffpos">
<code class="descname">Wyckoffpos</code><span class="sig-paren">(</span><em>uvec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.Wyckoffpos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.Wyckoffpos" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates all the equivalent Wyckoff positions for a unit cell vector.
:param uvec: 3-vector (float) vector in direct coordinates
:return: list of equivalent Wyckoff positions</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.addbasis">
<code class="descname">addbasis</code><span class="sig-paren">(</span><em>basis</em>, <em>chemistry=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.addbasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.addbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Crystal object that contains additional sites (assumed to be new chemistry).
This is intended to &#8220;add in&#8221; interstitial sites. Note: if the symmetry is to be
maintained, should be the output from Wyckoffpos().
:param basis: list (or list of lists) of new sites
:paran chemistry: (optional) list of chemistry names
:return: new Crystal object, with additional sites</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.calcmetric">
<code class="descname">calcmetric</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.calcmetric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.calcmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the volume of the cell and the metric tensor
:return: volume, metric tensor</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.cart2pos">
<code class="descname">cart2pos</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.cart2pos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.cart2pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the lattvec and index corresponding to an atomic position in cartesian coord.
:param v: 3-vector (float) position in Cartesian coordinates
:return: 3-vector (integer) lattice vector in direct coordinates, index tuple</p>
<blockquote>
<div>of corresponding atom.
Returns None on tuple if no match</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.cart2unit">
<code class="descname">cart2unit</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.cart2unit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.cart2unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the lattvec and unit cell coord. corresponding to a position
in cartesian coord.
:param v: 3-vector (float) position in Cartesian coordinates
:return: 3-vector (integer) lattice vector in direct coordinates,</p>
<blockquote>
<div>3-vector (float) inside unit cell</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.center">
<code class="descname">center</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.center"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.center" title="Permalink to this definition">¶</a></dt>
<dd><p>Center the atoms in the cell if there is an inversion operation present.</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.chemindex">
<code class="descname">chemindex</code><span class="sig-paren">(</span><em>chemistry</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.chemindex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.chemindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return index corresponding to chemistry; None if not present.
:param chemistry: value to check
:return: index corresponding to chemistry</p>
</dd></dl>

<dl class="classmethod">
<dt id="crystal.Crystal.fromdict">
<em class="property">classmethod </em><code class="descname">fromdict</code><span class="sig-paren">(</span><em>yamldict</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.fromdict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.fromdict" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a Crystal object from a YAML-created dictionary
:param yamldict: dictionary; must contain &#8216;lattice&#8217; (using <em>row</em> vectors!) and &#8216;basis&#8217;;
can contain optional &#8216;lattice_constant&#8217;
:return: Crystal(lattice.T, basis)</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.fullkptmesh">
<code class="descname">fullkptmesh</code><span class="sig-paren">(</span><em>Nmesh</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.fullkptmesh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.fullkptmesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a k-point mesh of density given by Nmesh; does not symmetrize but does put the
k-points inside the BZ. Does not return any <em>weights</em> as every point is equally weighted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Nmesh</strong> &#8211; mesh divisions Nmesh[0] x Nmesh[1] x Nmesh[2]</td>
</tr>
<tr class="field-even field"><th class="field-name">Return kpt:</th><td class="field-body">array[Nkpt][3] of kpoints</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.g_cart">
<code class="descname">g_cart</code><span class="sig-paren">(</span><em>g</em>, <em>x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.g_cart"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.g_cart" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a space group operation to a (Cartesian) vector position
:param g: group operation (GroupOp)
:param x: 3-vector position in space
:return: 3-vector position in space (Cartesian coordinates)</p>
</dd></dl>

<dl class="staticmethod">
<dt id="crystal.Crystal.g_direc">
<em class="property">static </em><code class="descname">g_direc</code><span class="sig-paren">(</span><em>g</em>, <em>direc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.g_direc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.g_direc" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a space group operation to a direction
:param g: group operation (GroupOp)
:param direc: 3-vector direction
:return: 3-vector direction</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.g_direc_equivalent">
<code class="descname">g_direc_equivalent</code><span class="sig-paren">(</span><em>d1</em>, <em>d2</em>, <em>threshold=1e-08</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.g_direc_equivalent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.g_direc_equivalent" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells us if two directions are equivalent by according to the space group
:param d1: direction one (array[3])
:param d2: direction two (array[3])
:param threshold: threshold for equality</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if equivalent by a point group operation</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.g_pos">
<code class="descname">g_pos</code><span class="sig-paren">(</span><em>g</em>, <em>lattvec</em>, <em>ind</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.g_pos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.g_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a space group operation to an atom position specified by its lattice and index
:param g: group operation (GroupOp)
:param lattvec: 3-vector (integer) lattice vector in direct coordinates
:param ind: two-tuple index specifying the atom: (atomtype, atomindex)
:return: 3-vector (integer) lattice vector in direct coordinates, index</p>
</dd></dl>

<dl class="staticmethod">
<dt id="crystal.Crystal.g_tensor">
<em class="property">static </em><code class="descname">g_tensor</code><span class="sig-paren">(</span><em>g</em>, <em>tensor</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.g_tensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.g_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a space group operation to a 2nd-rank tensor
:param g: group operation (GroupOp)
:param tensor: 2nd-rank tensor
:return: 2nd-rank tensor</p>
</dd></dl>

<dl class="staticmethod">
<dt id="crystal.Crystal.g_vect">
<em class="property">static </em><code class="descname">g_vect</code><span class="sig-paren">(</span><em>g</em>, <em>lattvec</em>, <em>uvec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.g_vect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.g_vect" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a space group operation to a vector position specified by its lattice and a location
in the unit cell in direct coordinates
:param g:  group operation (GroupOp)
:param lattvec: 3-vector (integer) lattice vector in direct coordinates
:param uvec: 3-vector (float) vector in direct coordinates
:return: 3-vector (integer) lattice vector in direct coordinates, location in unit cell in</p>
<blockquote>
<div>direct coordinates</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.genBZG">
<code class="descname">genBZG</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.genBZG"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.genBZG" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the reciprocal lattice G points that define the Brillouin zone.
:return: array of G vectors that define the BZ, in Cartesian coordinates</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.genWyckoffsets">
<code class="descname">genWyckoffsets</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.genWyckoffsets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.genWyckoffsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate our Wykcoff sets.
:return: set of sets of tuples of positions that correspond to identical Wyckoff positions</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.gengroup">
<code class="descname">gengroup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.gengroup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.gengroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate all of the space group operations.
:return: list of group operations</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.genpoint">
<code class="descname">genpoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.genpoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.genpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate our point group indices. Done with crazy list comprehension due to the
structure of our basis.
:return: list of sets of point group operations that leave a site unchanged</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.inBZ">
<code class="descname">inBZ</code><span class="sig-paren">(</span><em>vec</em>, <em>BZG=None</em>, <em>threshold=1e-05</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.inBZ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.inBZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells us if vec is inside our set of defining points.
:param vec: array [3], vector to be tested
:param BGZ: array [:,3], optional (default = self.BZG), array of vectors that define the BZ
:param threshold: double, optional, threshold to use for &#8220;equality&#8221;
:return: False if outside the BZ, True otherwise</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.jumpnetwork">
<code class="descname">jumpnetwork</code><span class="sig-paren">(</span><em>chem</em>, <em>cutoff</em>, <em>closestdistance=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.jumpnetwork"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.jumpnetwork" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the full jump network for a specific chemical index, out to a cutoff. Organized
by symmetry-unique transitions. Note that i-&gt;j and j-&gt;i are always related to one-another,
but by equivalence of transition state, not symmetry. Now updated with closest-distance
parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>chem</strong> &#8211; index corresponding to the chemistry to consider</li>
<li><strong>cutoff</strong> &#8211; distance cutoff</li>
<li><strong>closestdistance</strong> &#8211; closest distance allowed in transition (can be a list)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of symmetry-unique transitions; each is a list of tuples:
((i,j), dx) corresponding to jump from i-&gt;j with vector dx</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.jumpnetwork2lattice">
<code class="descname">jumpnetwork2lattice</code><span class="sig-paren">(</span><em>chem</em>, <em>jumpnetwork</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.jumpnetwork2lattice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.jumpnetwork2lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a &#8220;standard&#8221; jumpnetwork (that specifies displacement vectors dx) into a lattice
representation, where we replace dx with the lattice vector from i to j.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>chem</strong> &#8211; index corresponding to the chemistry to consider</li>
<li><strong>jumpnetwork</strong> &#8211; list of symmetry-unique transitions; each is a list of tuples:
((i,j), dx) corresponding to jump from i-&gt;j with vector dx</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of symmetry-unique transitions; each is a list of tuples:
((i,j), R) corresponding to jump from i in unit cell 0 -&gt; j in unit cell R</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.minlattice">
<code class="descname">minlattice</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.minlattice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.minlattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to find the optimal lattice vector definition for a crystal. Our definition of optimal
is (a) length of each lattice vector is minimal; (b) the vectors are ordered from
shortest to longest; (c) the vectors have minimal dot product; (d) the basis is right-handed.</p>
<p>Works recursively.</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.nnlist">
<code class="descname">nnlist</code><span class="sig-paren">(</span><em>ind</em>, <em>cutoff</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.nnlist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.nnlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the nearest neighbor list for a given cutoff. Only consider
neighbor vectors for atoms of the same type. Returns a list of
cartesian vectors.
:param ind: tuple index for atom
:param cutoff:  distance cutoff
:return: list of nearest neighbor vectors</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.pos2cart">
<code class="descname">pos2cart</code><span class="sig-paren">(</span><em>lattvec</em>, <em>ind</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.pos2cart"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.pos2cart" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cartesian coordinates of an atom specified by its lattice and index
:param lattvec: 3-vector (integer) lattice vector in direct coordinates
:param ind: two-tuple index specifying the atom: (atomtype, atomindex)
:return: 3-vector (float) in Cartesian coordinates</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.reduce">
<code class="descname">reduce</code><span class="sig-paren">(</span><em>threshold=1e-08</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.reduce"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduces the lattice and basis, if needed. Works (tail) recursively.</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.reducekptmesh">
<code class="descname">reducekptmesh</code><span class="sig-paren">(</span><em>kptfull</em>, <em>threshold=1e-08</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.reducekptmesh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.reducekptmesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a fully expanded mesh, and reduces it by symmetry. Assumes every point is
equally weighted. We would need a different (more complicated) algorithm if not true...
:param kptfull: array[Nkpt][3] of kpoints
:param threshold: threshold for symmetry equality</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return kptsymm:</th><td class="field-body">array[Nsymm][3] of kpoints</td>
</tr>
<tr class="field-even field"><th class="field-name">Return weight:</th><td class="field-body">array[Nsymm] of weights (integrates to 1)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.remapbasis">
<code class="descname">remapbasis</code><span class="sig-paren">(</span><em>supercell</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.remapbasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.remapbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the basis definition, and using a supercell definition, returns a new basis
:param supercell: integer array[3,3]
:return: atomic basis</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.simpleYAML">
<code class="descname">simpleYAML</code><span class="sig-paren">(</span><em>a0=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.simpleYAML"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.simpleYAML" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simplified YAML dump, in case we don&#8217;t want to output the full symmetry analysis
:return: YAML dump</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.sitelist">
<code class="descname">sitelist</code><span class="sig-paren">(</span><em>chem</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.sitelist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.sitelist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of lists of Wyckoff-related sites for a given chemistry.
Done with a single list comprehension&#8211;useful as input for diffusion calculation
:param chem: index corresponding to chemistry to consider
:return: list of lists of indices that are equivalent by symmetry</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.strain">
<code class="descname">strain</code><span class="sig-paren">(</span><em>eps</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.strain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.strain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Crystal object that is a strained version of the current.
:param eps: strain tensor
:return: new Crystal object, strained</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.unit2cart">
<code class="descname">unit2cart</code><span class="sig-paren">(</span><em>lattvec</em>, <em>uvec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.unit2cart"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.unit2cart" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cartesian coordinates of a position specified by its lattice and
unit cell coordinates
:param lattvec: 3-vector (integer) lattice vector in direct coordinates
:param uvec: 3-vector (float) unit cell vector in direct coordinates
:return: 3-vector (float) in Cartesian coordinates</p>
</dd></dl>

<dl class="staticmethod">
<dt id="crystal.Crystal.vectlist">
<em class="property">static </em><code class="descname">vectlist</code><span class="sig-paren">(</span><em>vb</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.vectlist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.vectlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of orthonormal vectors corresponding to our vector basis.
:param vb: (dim, v)
:return: list of vectors</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="crystal.GroupOp">
<em class="property">class </em><code class="descclassname">crystal.</code><code class="descname">GroupOp</code><a class="reference internal" href="_modules/crystal.html#GroupOp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp" title="Permalink to this definition">¶</a></dt>
<dd><p>A class corresponding to a group operation. Based on namedtuple, so it is immutable.</p>
<p>Intended to be used in combination with Crystal, we have a few operations that
can be defined out-of-the-box.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rot</strong> &#8211; np.array(3,3) integer idempotent matrix</li>
<li><strong>trans</strong> &#8211; np.array(3) real vector</li>
<li><strong>cartrot</strong> &#8211; np.array(3,3) real unitary matrix</li>
<li><strong>indexmap</strong> &#8211; list of list, containing the atom mapping</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="staticmethod">
<dt id="crystal.GroupOp.GroupOp_constructor">
<em class="property">static </em><code class="descname">GroupOp_constructor</code><span class="sig-paren">(</span><em>loader</em>, <em>node</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.GroupOp_constructor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.GroupOp_constructor" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a GroupOp from YAML</p>
</dd></dl>

<dl class="staticmethod">
<dt id="crystal.GroupOp.GroupOp_representer">
<em class="property">static </em><code class="descname">GroupOp_representer</code><span class="sig-paren">(</span><em>dumper</em>, <em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.GroupOp_representer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.GroupOp_representer" title="Permalink to this definition">¶</a></dt>
<dd><p>Output a GroupOp</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.eigen">
<code class="descname">eigen</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.eigen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.eigen" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the type of group operation (single integer) and eigenvectors.
1 = identity
2, 3, 4, 6 = n- fold rotation around an axis
negative = rotation + mirror operation, perpendicular to axis
&#8220;special cases&#8221;: -1 = mirror, -2 = inversion</p>
<p>eigenvect[0] = axis of rotation / mirror
eigenvect[1], eigenvect[2] = orthonormal vectors to define the plane giving a right-handed</p>
<blockquote>
<div>coordinate system and where rotation around [0] is positive, and the positive imaginary
eigenvector for the complex eigenvalue is [1] + i [2].</div></blockquote>
</dd></dl>

<dl class="classmethod">
<dt id="crystal.GroupOp.ident">
<em class="property">classmethod </em><code class="descname">ident</code><span class="sig-paren">(</span><em>basis</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.ident"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.ident" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a group operation corresponding to identity for a given basis</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.incell">
<code class="descname">incell</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.incell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.incell" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a version of groupop where the translation is in the unit cell</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.inhalf">
<code class="descname">inhalf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.inhalf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.inhalf" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a version of groupop where the translation is in the centered unit cell</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.inv">
<code class="descname">inv</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.inv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct and return the inverse of the group operation</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="crystal.ProjectTensorBasis">
<code class="descclassname">crystal.</code><code class="descname">ProjectTensorBasis</code><span class="sig-paren">(</span><em>tensor</em>, <em>basis</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#ProjectTensorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.ProjectTensorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a tensor, project it onto the basis.
:param tensor: tensor
:param basis: list consisting of an orthonormal basis
:return: tensor, projected</p>
</dd></dl>

<dl class="function">
<dt id="crystal.SymmTensorBasis">
<code class="descclassname">crystal.</code><code class="descname">SymmTensorBasis</code><span class="sig-paren">(</span><em>rottype</em>, <em>eigenvect</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#SymmTensorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.SymmTensorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a symmetric second-rank tensor basis corresponding to the optype and eigenvectors
for a GroupOp
:param rottype: output from eigen()
:param eigenvect: eigenvectors
:return: list of 2nd-rank symmetric tensors making up the basis</p>
</dd></dl>

<dl class="function">
<dt id="crystal.VectorBasis">
<code class="descclassname">crystal.</code><code class="descname">VectorBasis</code><span class="sig-paren">(</span><em>rottype</em>, <em>eigenvect</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#VectorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.VectorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector basis corresponding to the optype and eigenvectors for a GroupOp
:param rottype: output from eigen()
:param eigenvect: eigenvectors
:return: (dim, vect) &#8211; dimensionality (0..3), vector defining line direction (1) or plane normal (2)</p>
</dd></dl>

<dl class="function">
<dt id="crystal.Voigtstrain">
<code class="descclassname">crystal.</code><code class="descname">Voigtstrain</code><span class="sig-paren">(</span><em>e1</em>, <em>e2</em>, <em>e3</em>, <em>e4</em>, <em>e5</em>, <em>e6</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Voigtstrain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Voigtstrain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a symmetric strain tensor from the Voigt reduced strain values.
:param e1: xx
:param e2: yy
:param e3: zz
:param e4: yz + zx
:param e5: zx + xz
:param e6: xy + yx
:return: symmetric strain tensor</p>
</dd></dl>

<dl class="function">
<dt id="crystal.incell">
<code class="descclassname">crystal.</code><code class="descname">incell</code><span class="sig-paren">(</span><em>vec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#incell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.incell" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vector inside the unit cell (in [0,1)**3)</p>
</dd></dl>

<dl class="function">
<dt id="crystal.inhalf">
<code class="descclassname">crystal.</code><code class="descname">inhalf</code><span class="sig-paren">(</span><em>vec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#inhalf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.inhalf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vector inside the centered cell (in [-0.5,0.5)**3)</p>
</dd></dl>

<dl class="function">
<dt id="crystal.maptranslation">
<code class="descclassname">crystal.</code><code class="descname">maptranslation</code><span class="sig-paren">(</span><em>oldpos</em>, <em>newpos</em>, <em>threshold=1e-08</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#maptranslation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.maptranslation" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of transformed positions, identify if there&#8217;s a translation vector
that maps from the current positions to the new position.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>oldpos</strong> &#8211; list of list of array[3]</li>
<li><strong>newpos</strong> &#8211; list of list of array[3], same layout as oldpos</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">translation (array[3]), mapping (list of list of indices)</p>
</td>
</tr>
</tbody>
</table>
<p>The mapping specifies the index that the <em>translated</em> atom corresponds to in the
original position set. If unable to construct a mapping, the mapping return is
None; the translation vector will be meaningless.</p>
</dd></dl>

<dl class="function">
<dt id="crystal.ndarray_representer">
<code class="descclassname">crystal.</code><code class="descname">ndarray_representer</code><span class="sig-paren">(</span><em>dumper</em>, <em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#ndarray_representer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.ndarray_representer" title="Permalink to this definition">¶</a></dt>
<dd><p>Output a numpy array</p>
</dd></dl>

<p>CrystalStars:</p>
<p>PowerExpansion:</p>
<span class="target" id="module-PowerExpansion"></span><p>Power expansion class</p>
<p>Class to store and manipulate 3-dimensional Taylor (power) expansions of functions
Particularly useful for inverting the FT of the evolution matrix, and subtracting off
analytically calculated IFT for the Green function.</p>
<p>Really designed to get used by other code.</p>
<dl class="class">
<dt id="PowerExpansion.Taylor3D">
<em class="property">class </em><code class="descclassname">PowerExpansion.</code><code class="descname">Taylor3D</code><span class="sig-paren">(</span><em>coefflist=[]</em>, <em>Lmax=4</em>, <em>nodeepcopy=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Class that stores a Taylor expansion of a function in 3D, and defines some arithmetic</p>
<dl class="method">
<dt id="PowerExpansion.Taylor3D.addhdf5">
<code class="descname">addhdf5</code><span class="sig-paren">(</span><em>HDF5group</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.addhdf5"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.addhdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds an HDF5 representation of object into an HDF5group (needs to already exist).</p>
<dl class="docutils">
<dt>Example: if f is an open HDF5, then T3D.addhdf5(f.create_group(&#8216;T3D&#8217;)) will</dt>
<dd><ol class="first last arabic simple">
<li>create the group named &#8216;T3D&#8217;, and then (2) put the T3D representation in that group.</li>
</ol>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>HDF5group</strong> &#8211; HDF5 group</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PowerExpansion.Taylor3D.addterms">
<code class="descname">addterms</code><span class="sig-paren">(</span><em>coefflist</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.addterms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.addterms" title="Permalink to this definition">¶</a></dt>
<dd><p>Add additional coefficients into our object. No type checking. Only works if
terms are completely non-overlapping (otherwise, need to use sum).
:param coefflist: list((n, lmax, powexpansion))</p>
</dd></dl>

<dl class="classmethod">
<dt id="PowerExpansion.Taylor3D.checkinternalsHDF5">
<em class="property">classmethod </em><code class="descname">checkinternalsHDF5</code><span class="sig-paren">(</span><em>HDF5group</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.checkinternalsHDF5"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.checkinternalsHDF5" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the power expansion internals into an HDF5group, and performs sanity check
:param HDF5group:</p>
</dd></dl>

<dl class="classmethod">
<dt id="PowerExpansion.Taylor3D.coeffproductcoeff">
<em class="property">classmethod </em><code class="descname">coeffproductcoeff</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.coeffproductcoeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.coeffproductcoeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a direction expansion a and b, and returns the product expansion.
:param a, b = list((n, lmax, powexpansion):</p>
<blockquote>
<div>written as a series of coefficients; n defines the magnitude function, which
is additive; lmax is the largest cumulative power of coefficients, and
powexpansion is a numpy array that can multiplied. We assume that a and b
have consistent shapes throughout&#8211;we <em>do not test this</em>; runtime will likely
fail if not true. The entries in the list are <em>tuples</em> of n, lmax, pow</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Return c = list((n, lmax, powexpansion)):</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">product of a and b</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="PowerExpansion.Taylor3D.collectcoeff">
<em class="property">classmethod </em><code class="descname">collectcoeff</code><span class="sig-paren">(</span><em>a</em>, <em>inplace=False</em>, <em>atol=1e-10</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.collectcoeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.collectcoeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Collects coefficients: sums up all the common n values. Best to be done <em>after</em>
reduce is called.
:param a = list((n, lmax, powexpansion): expansion of function in powers
:param inplace: modify a in place?
:return coefflist: a</p>
</dd></dl>

<dl class="classmethod">
<dt id="PowerExpansion.Taylor3D.constructexpansion">
<em class="property">classmethod </em><code class="descname">constructexpansion</code><span class="sig-paren">(</span><em>basis</em>, <em>N=-1</em>, <em>pre=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.constructexpansion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.constructexpansion" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a &#8220;basis&#8221; for constructing an expansion &#8211; list of vectors and matrices &#8211;
and constructs the expansions up to power N (default = Lmax)
Takes a direction expansion a and b, and returns the sum of the expansions.
:param basis = list((coeffmatrix, vect)): expansions to create;</p>
<blockquote>
<div>sum(coeffmatrix * (vect*q)^n), for powers n = 0..N</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>N</strong> &#8211; maximum power to consider; for N=-1, use Lmax</li>
<li><strong>pre</strong> &#8211; list of prefactors, defining the Taylor expansion. Default = 1</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:returns list((n, lmax, powexpansion)), ...</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">our expansion, as input to create</span><dd>Taylor3D objects</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="PowerExpansion.Taylor3D.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the current expansion</p>
</dd></dl>

<dl class="method">
<dt id="PowerExpansion.Taylor3D.dumpinternalsHDF5">
<code class="descname">dumpinternalsHDF5</code><span class="sig-paren">(</span><em>HDF5group</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.dumpinternalsHDF5"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.dumpinternalsHDF5" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the initialized power expansion internals into an HDF5group&#8211;should be stored for a
sanity check
:param HDF5group:</p>
</dd></dl>

<dl class="method">
<dt id="PowerExpansion.Taylor3D.ildot">
<code class="descname">ildot</code><span class="sig-paren">(</span><em>c</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.ildot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.ildot" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes c.self in place</p>
</dd></dl>

<dl class="method">
<dt id="PowerExpansion.Taylor3D.inv">
<code class="descname">inv</code><span class="sig-paren">(</span><em>Nmax=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.inv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inverse of the expansion, up to order Nmax
:param Nmax: maximum order in the inverse expansion
:return: Taylor series of inverse</p>
</dd></dl>

<dl class="classmethod">
<dt id="PowerExpansion.Taylor3D.inversecoeff">
<em class="property">classmethod </em><code class="descname">inversecoeff</code><span class="sig-paren">(</span><em>a</em>, <em>Nmax=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.inversecoeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.inversecoeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a direction expansion , and returns the inversion expansion (approximated
based on the Taylor expansion of 1/(1-x) = sum_i=0^infinity x^i, or
(A + B)^-1 = ((1+BA^-1)A)^-1 = A^-1(1-(-BA^1))^-1 = A^1 sum_i=0 (-BA^-1)^n
:param a = list((n, lmax, powexpansion):</p>
<blockquote>
<div>written as a series of coefficients; n defines the magnitude function, which
is additive; lmax is the largest cumulative power of coefficients, and
powexpansion is a numpy array that can multiplied. We assume that a and b
have consistent shapes throughout&#8211;we <em>do not test this</em>; runtime will likely
fail if not true. The entries in the list are <em>tuples</em> of n, lmax, pow</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Nmax</strong> &#8211; maximum remaining n value in expansion. Default value of 0 means
up to a discontinuity correction in an inversion, but higher (or lower) values are
possible.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return c = list((n, lmax, powexpansion)):</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">inverse of a</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>NOTE: assumes SMALLEST n coefficient is the leading order; only works if that coefficient</dt>
<dd>is also isotropic (l=0). Otherwise, raises an error</dd>
<dt>NOTE: there is no sanity check on whether Nmax is reasonable given the expansion and Lmax</dt>
<dd>values; caveat emptor</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="PowerExpansion.Taylor3D.irdot">
<code class="descname">irdot</code><span class="sig-paren">(</span><em>c</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.irdot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.irdot" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes self.c in place</p>
</dd></dl>

<dl class="method">
<dt id="PowerExpansion.Taylor3D.irotate">
<code class="descname">irotate</code><span class="sig-paren">(</span><em>powtrans</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.irotate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.irotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate in place.
:param powtrans: Npow x Npow matrix, of [oldpow,newpow] corresponding to the rotation
:return: self</p>
</dd></dl>

<dl class="method">
<dt id="PowerExpansion.Taylor3D.ldot">
<code class="descname">ldot</code><span class="sig-paren">(</span><em>c</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.ldot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.ldot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns c.self</p>
</dd></dl>

<dl class="classmethod">
<dt id="PowerExpansion.Taylor3D.loadhdf5">
<em class="property">classmethod </em><code class="descname">loadhdf5</code><span class="sig-paren">(</span><em>HDF5group</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.loadhdf5"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.loadhdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new T3D from an HDF5 group.
:param HDFgroup: HDF5 group
:return: new T3D object</p>
</dd></dl>

<dl class="classmethod">
<dt id="PowerExpansion.Taylor3D.makeLprojections">
<em class="property">classmethod </em><code class="descname">makeLprojections</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.makeLprojections"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.makeLprojections" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a series of projection matrices for each l component in our power series
:return: projL[l][p][p&#8217;]</p>
<blockquote>
<div>projection of powers containing <em>only</em> l component.
-1 component = sum(l=0..Lmax, projL[l]) = simplification projection</div></blockquote>
</dd></dl>

<dl class="classmethod">
<dt id="PowerExpansion.Taylor3D.makeYlmpow">
<em class="property">classmethod </em><code class="descname">makeYlmpow</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.makeYlmpow"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.makeYlmpow" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the expansion of the Ylm&#8217;s in powers of x,y,z. Done via brute force.
:return Ylmpow[lm, p]: expansion of each Ylm in powers</p>
</dd></dl>

<dl class="classmethod">
<dt id="PowerExpansion.Taylor3D.makedirectmult">
<em class="property">classmethod </em><code class="descname">makedirectmult</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.makedirectmult"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.makedirectmult" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Return direcmult[p][p&#8217;]:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">index that corresponds to the multiplication of power indices p and p&#8217;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="PowerExpansion.Taylor3D.makeindexPowerYlm">
<em class="property">static </em><code class="descname">makeindexPowerYlm</code><span class="sig-paren">(</span><em>Lmax</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.makeindexPowerYlm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.makeindexPowerYlm" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyzes the spherical harmonics and powers for a given Lmax; returns a
series of index functions.
:param Lmax: maximum l value to consider; equal to the sum of powers
:return NYlm: number of Ylm coefficients
:return Npower: number of power coefficients
:return pow2ind[n1][n2][n3]: powers to index
:return ind2pow[n]: powers for a given index
:return Ylm2ind[l][m]: (l,m) to index
:return ind2Ylm[lm]: (l,m) for a given index
:return powlrange[l]: upper limit of power indices for a given l value; note: [-1] = 0</p>
</dd></dl>

<dl class="classmethod">
<dt id="PowerExpansion.Taylor3D.makepowYlm">
<em class="property">classmethod </em><code class="descname">makepowYlm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.makepowYlm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.makepowYlm" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the expansion of the powers in Ylm&#8217;s. Done using recursion relations
instead of direct calculation. Note: an alternative approach would be Gaussian
quadrature.
:return powYlm[p][lm]: expansion of powers in Ylm; uses indexing scheme above</p>
</dd></dl>

<dl class="classmethod">
<dt id="PowerExpansion.Taylor3D.makepowercoeff">
<em class="property">classmethod </em><code class="descname">makepowercoeff</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.makepowercoeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.makepowercoeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Make our power coefficients for our construct expansion method
:return powercoeff[n][p]: vector we multiply by our power expansion to get the n&#8217;th coefficients</p>
</dd></dl>

<dl class="classmethod">
<dt id="PowerExpansion.Taylor3D.negcoeff">
<em class="property">classmethod </em><code class="descname">negcoeff</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.negcoeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.negcoeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Negates a coefficient expansion a
:param a = list((n, lmax, powexpansion): expansion of function in powers
:return coefflist: -a</p>
</dd></dl>

<dl class="method">
<dt id="PowerExpansion.Taylor3D.nl">
<code class="descname">nl</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.nl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.nl" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of (n,l) pairs in the coefflist
:return nl_list: all of the (n,l) pairs that are present in our coefflist</p>
</dd></dl>

<dl class="classmethod">
<dt id="PowerExpansion.Taylor3D.powexp">
<em class="property">classmethod </em><code class="descname">powexp</code><span class="sig-paren">(</span><em>u</em>, <em>normalize=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.powexp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.powexp" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a vector u, normalize it and return the power expansion of uvec
:param u[3]: vector to apply
:param normalize: do we normalize u first?
:return upow[Npower]: ux uy uz products of powers
:return umagn: magnitude of u (if normalized)</p>
</dd></dl>

<dl class="method">
<dt id="PowerExpansion.Taylor3D.rdot">
<code class="descname">rdot</code><span class="sig-paren">(</span><em>c</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.rdot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.rdot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns self.c</p>
</dd></dl>

<dl class="method">
<dt id="PowerExpansion.Taylor3D.reduce">
<code class="descname">reduce</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.reduce"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce the coefficients: eliminate any n that has zero coefficients, collect all of
the same values of n together. Done in place.</p>
</dd></dl>

<dl class="classmethod">
<dt id="PowerExpansion.Taylor3D.reducecoeff">
<em class="property">classmethod </em><code class="descname">reducecoeff</code><span class="sig-paren">(</span><em>a</em>, <em>inplace=False</em>, <em>atol=1e-10</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.reducecoeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.reducecoeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Projects coefficients through Ylm space, then eliminates any zero contributions
(including possible reduction in l values, too).
:param a = list((n, lmax, powexpansion): expansion of function in powers
:param inplace: modify a in place?
:return coefflist: a</p>
</dd></dl>

<dl class="method">
<dt id="PowerExpansion.Taylor3D.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>powtrans</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.rotate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a rotated version of the expansion.
:param powtrans: Npow x Npow matrix, of [oldpow,newpow] corresponding to the rotation
:return: coefficient list, rotated</p>
</dd></dl>

<dl class="classmethod">
<dt id="PowerExpansion.Taylor3D.rotatecoeff">
<em class="property">classmethod </em><code class="descname">rotatecoeff</code><span class="sig-paren">(</span><em>a</em>, <em>npowtrans</em>, <em>inplace=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.rotatecoeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.rotatecoeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a rotated version of the expansion. Needs to use pad to work with reduced representations.
:param a: coefficiant list
:param npowtrans: Lmax+1 x Npow x Npow matrix, of [n,oldpow,newpow] corresponding to the rotation
:return: coefficient list, rotated</p>
</dd></dl>

<dl class="classmethod">
<dt id="PowerExpansion.Taylor3D.rotatedirections">
<em class="property">classmethod </em><code class="descname">rotatedirections</code><span class="sig-paren">(</span><em>qptrans</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.rotatedirections"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.rotatedirections" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a transformation matrix qptrans, where q[i] = sum_j qptrans[i][j] p[j], and
returns the Npow x Npow transformation matrix for the new components in terms of
the old.
NOTE: This is more complex than one might first realize. If we only work with cases
where all of the entries for a given power n have those same n (that is, not reduced),
then this is straightforward. However, we run into problems with <em>reductions</em>: e.g.,
for n=2, the power x^0 y^0 z^0 is, in reality, x^2+y^2+z^2, and hence <em>it must be
transformed</em> because we allow non-orthogonal transformation matrices.
:param qptrans: 3x3 matrix
:return: Lmax +1 x Npow x Npow transformation matrix [n][original pow][new pow] for
each n from 0 up to Lmax</p>
</dd></dl>

<dl class="classmethod">
<dt id="PowerExpansion.Taylor3D.scalarproductcoeff">
<em class="property">classmethod </em><code class="descname">scalarproductcoeff</code><span class="sig-paren">(</span><em>c</em>, <em>a</em>, <em>inplace=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.scalarproductcoeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.scalarproductcoeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplies an coefficient expansion a by a scalar c
:param c: scalar <em>or</em> dictionary mapping (n,l) to scalars
:param a = list((n, lmax, powexpansion): expansion of function in powers
:param inplace: modify a in place?
:return coefflist: c*a</p>
</dd></dl>

<dl class="method">
<dt id="PowerExpansion.Taylor3D.separate">
<code class="descname">separate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.separate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.separate" title="Permalink to this definition">¶</a></dt>
<dd><p>Separate out the coefficients into (n,l) terms where <em>only</em> l contributions
appear in each.</p>
</dd></dl>

<dl class="classmethod">
<dt id="PowerExpansion.Taylor3D.separatecoeff">
<em class="property">classmethod </em><code class="descname">separatecoeff</code><span class="sig-paren">(</span><em>a</em>, <em>inplace=False</em>, <em>atol=1e-10</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.separatecoeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.separatecoeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Projects coefficients through Ylm space, one by one. Assumes they&#8217;ve already been
reduced and collected first; if not, could lead to duplicated (n,l) entries in list, which
is inefficient (should still <em>evaluate</em> the same, just with extra steps). After this,
each (n,l) term <em>only</em> contains terms equal to l, rather than terms &lt;= l.
:param a = list((n, lmax, powexpansion): expansion of function in powers
:param inplace: modify a in place?
:return coefflist: a</p>
</dd></dl>

<dl class="classmethod">
<dt id="PowerExpansion.Taylor3D.sumcoeff">
<em class="property">classmethod </em><code class="descname">sumcoeff</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>alpha=1</em>, <em>beta=1</em>, <em>inplace=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.sumcoeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.sumcoeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes Taylor3D expansion a and b, and returns the sum of the expansions.
:param: a, b = list((n, lmax, powexpansion)</p>
<blockquote>
<div>written as a series of coefficients; n defines the magnitude function, which
is additive; lmax is the largest cumulative power of coefficients, and
powexpansion is a numpy array that can multiplied. We assume that a and b
have consistent shapes throughout&#8211;we <em>do not test this</em>; runtime will likely
fail if not true. The entries in the list are <em>tuples</em> of n, lmax, pow</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>beta</strong> (<em>alpha,</em>) &#8211; optional scalars: c = alpha*a + beta*b; allows for more efficient expansions</li>
<li><strong>inplace</strong> &#8211; True if the summation should modify a in place</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return c:</th><td class="field-body"><p class="first last">coeff of sum of a and b (! NOTE ! does not return the class!)
sum of a and b</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="PowerExpansion.Taylor3D.tensorproductcoeff">
<em class="property">classmethod </em><code class="descname">tensorproductcoeff</code><span class="sig-paren">(</span><em>c</em>, <em>a</em>, <em>leftmultiply=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.tensorproductcoeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.tensorproductcoeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplies an coefficient expansion a by a scalar c
:param c: array <em>or</em> dictionary mapping (n,l) to arrays
:param a = list((n, lmax, powexpansion): expansion of function in powers
:param leftmultiply: tensordot(c,a) vs. tensordot(a,c)
:return coefflist: c.a (or a.c)</p>
</dd></dl>

<dl class="method">
<dt id="PowerExpansion.Taylor3D.truncate">
<code class="descname">truncate</code><span class="sig-paren">(</span><em>Nmax</em>, <em>inplace=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.truncate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.truncate" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the coefficients above a given Nmax; normally returns a new object
:param Nmax: maximum coefficient to include
:param inplace: do it in place?</p>
</dd></dl>

<dl class="classmethod">
<dt id="PowerExpansion.Taylor3D.truncatecoeff">
<em class="property">classmethod </em><code class="descname">truncatecoeff</code><span class="sig-paren">(</span><em>a</em>, <em>Nmax</em>, <em>inplace=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.truncatecoeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.truncatecoeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the coefficients above a given Nmax; normally returns a new object
:param Nmax: maximum coefficient to include
:param a = list((n, lmax, powexpansion): expansion of function in powers
:param inplace: do it in place?</p>
</dd></dl>

<dl class="classmethod">
<dt id="PowerExpansion.Taylor3D.zeros">
<em class="property">classmethod </em><code class="descname">zeros</code><span class="sig-paren">(</span><em>nmin</em>, <em>nmax</em>, <em>shape</em>, <em>dtype=&lt;class 'complex'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PowerExpansion.html#Taylor3D.zeros"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PowerExpansion.Taylor3D.zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs (and returns) a &#8220;zero&#8221; Taylor expansion with the prescribed shape.
This will be useful for doing slicing assignments. Because of the manner in
which slicing works for assignment, we create what looks like a <em>lot</em> of
zeros, by explicitly making the full range of l values.
:param nmin: minimum value of n
:param nmax: maximum value of n (inclusive)
:param shape: shape of matrix, as zeros would expect.
:return: Taylor3D, with a zero coefficient list</p>
</dd></dl>

</dd></dl>

<p>GFcalc:</p>
<p>OnsagerCalc:</p>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></li>
<li><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></li>
<li><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></li>
</ul>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="includeme.html" class="btn btn-neutral float-right" title="Onsager" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Dallas R. Trinkle.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.9',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>