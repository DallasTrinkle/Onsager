

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Crystal &mdash; Onsager 1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Onsager 1.0 documentation" href="index.html"/>
        <link rel="next" title="CrystalStars" href="CrystalStars.html"/>
        <link rel="prev" title="Onsager" href="includeme.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Onsager
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="includeme.html">Onsager</a></li>
<li class="toctree-l1"><a class="reference internal" href="includeme.html#references">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="includeme.html#contributors">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="includeme.html#support">Support</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Crystal</a></li>
<li class="toctree-l1"><a class="reference internal" href="CrystalStars.html">CrystalStars</a></li>
<li class="toctree-l1"><a class="reference internal" href="supercell.html">Supercell</a></li>
<li class="toctree-l1"><a class="reference internal" href="PowerExpansion.html">PowerExpansion</a></li>
<li class="toctree-l1"><a class="reference internal" href="GFcalc.html">GFcalc</a></li>
<li class="toctree-l1"><a class="reference internal" href="OnsagerCalc.html">OnsagerCalc</a></li>
<li class="toctree-l1"><a class="reference internal" href="automator.html">Automator</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Onsager</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Crystal</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/crystal.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="crystal">
<h1>Crystal<a class="headerlink" href="#crystal" title="Permalink to this headline">¶</a></h1>
<p>Crystal:</p>
<p>The crystal module defines the <code class="docutils literal"><span class="pre">crystal</span></code> class, and <code class="docutils literal"><span class="pre">GroupOp</span></code> for group operations.</p>
<span class="target" id="module-crystal"></span><p>Crystal class</p>
<p>Class to store definition of a crystal, along with some analysis
1. geometric analysis (nearest neighbor displacements)
2. space group operations
3. point group operations for each basis position
4. Wyckoff position generation (for interstitials)</p>
<dl class="function">
<dt id="crystal.CombineTensorBasis">
<code class="descclassname">crystal.</code><code class="descname">CombineTensorBasis</code><span class="sig-paren">(</span><em>b1</em>, <em>b2</em>, <em>symmetric=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#CombineTensorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.CombineTensorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines (intersects) two tensor spaces into one; uses SVD to compute null space.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>b1</strong> &#8211; list of tensors</li>
<li><strong>b2</strong> &#8211; list of tensors</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return tensorbasis:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">list of 2nd-rank symmetric tensors making up the basis</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="crystal.CombineVectorBasis">
<code class="descclassname">crystal.</code><code class="descname">CombineVectorBasis</code><span class="sig-paren">(</span><em>b1</em>, <em>b2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#CombineVectorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.CombineVectorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines (intersects) two vector spaces into one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>b1</strong> &#8211; (dim, vect) &#8211; dimensionality (0..3), vector defining line direction (1) or plane normal (2)</li>
<li><strong>b2</strong> &#8211; (dim, vect)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return dim:</th><td class="field-body"><p class="first">dimensionality, 0..3</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return vect:</th><td class="field-body"><p class="first last">vector defining line direction (1) or plane normal (2)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="crystal.Crystal">
<em class="property">class </em><code class="descclassname">crystal.</code><code class="descname">Crystal</code><span class="sig-paren">(</span><em>lattice</em>, <em>basis</em>, <em>chemistry=None</em>, <em>spins=None</em>, <em>NOSYM=False</em>, <em>noreduce=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal" title="Permalink to this definition">¶</a></dt>
<dd><p>A class that defines a crystal, as well as the symmetry analysis that goes along with it.
Now includes optional spins. These can be vectors or &#8220;scalar&#8221; spins, for which we need
to consider a phase factor. In general, they can be complex. Ideally, they should have
magnitude either 0 or 1.</p>
<p>Specified by a lattice (3 vectors), a basis (list of lists of positions in direct coordinates).
Can also name the elements (chemistry), and specify spin degrees of freedom.</p>
<dl class="classmethod">
<dt id="crystal.Crystal.BCC">
<em class="property">classmethod </em><code class="descname">BCC</code><span class="sig-paren">(</span><em>a0</em>, <em>chemistry=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.BCC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.BCC" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a body-centered cubic crystal with lattice constant a0</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>a0</strong> &#8211; lattice constant</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return BCC crystal:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="crystal.Crystal.FCC">
<em class="property">classmethod </em><code class="descname">FCC</code><span class="sig-paren">(</span><em>a0</em>, <em>chemistry=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.FCC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.FCC" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a face-centered cubic crystal with lattice constant a0</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>a0</strong> &#8211; lattice constant</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return FCC crystal:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.FullVectorBasis">
<code class="descname">FullVectorBasis</code><span class="sig-paren">(</span><em>chem=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.FullVectorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.FullVectorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate our full vector basis, using the information from our crystal</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>chem</strong> &#8211; (optional) chemical index to consider; otherwise return a list of such</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return VBfunctions:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">(list) of our unique vector basis lattice functions, normalized; each is an array
(NVbasis x Nsites x 3)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return VVouter:</th><td class="field-body">(list) of ouf VV &#8220;outer&#8221; expansion (NVbasis x NVbasis for each chemistry)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="crystal.Crystal.HCP">
<em class="property">classmethod </em><code class="descname">HCP</code><span class="sig-paren">(</span><em>a0</em>, <em>c_a=1.6329931618554521</em>, <em>chemistry=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.HCP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.HCP" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a hexagonal closed packed crystal with lattice constant a0, c/a ratio c_a</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>a0</strong> &#8211; lattice constant</li>
<li><strong>c_a</strong> &#8211; (optional) c/a ratio, default=ideal <span class="math">\(\sqrt{8/3}\)</span></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return HCP crystal:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.SymmTensorBasis">
<code class="descname">SymmTensorBasis</code><span class="sig-paren">(</span><em>ind</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.SymmTensorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.SymmTensorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the symmetric tensor basis corresponding to an atomic site</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ind</strong> &#8211; tuple index for atom</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return tensorbasis:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">list of 2nd-rank symmetric tensors making up the basis</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.VectorBasis">
<code class="descname">VectorBasis</code><span class="sig-paren">(</span><em>ind</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.VectorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.VectorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the vector basis corresponding to an atomic site</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ind</strong> &#8211; tuple index for atom</td>
</tr>
<tr class="field-even field"><th class="field-name">Return dim:</th><td class="field-body">dimensionality, 0..3</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return vect:</th><td class="field-body">vector defining line direction (1) or plane normal (2)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.Wyckoffpos">
<code class="descname">Wyckoffpos</code><span class="sig-paren">(</span><em>uvec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.Wyckoffpos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.Wyckoffpos" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates all the equivalent Wyckoff positions for a unit cell vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>uvec</strong> &#8211; 3-vector (float) vector in direct coordinates</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return Wyckofflist:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">list of equivalent Wyckoff positions</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>lattice</em>, <em>basis</em>, <em>chemistry=None</em>, <em>spins=None</em>, <em>NOSYM=False</em>, <em>noreduce=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialization; starts off with the lattice vector definition and the
basis vectors. While it does not explicitly store the specific chemical
elements involved, it does store that there are different elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lattice</strong> &#8211; array[3,3] or list of array[3]
lattice vectors; if [3,3] array, then the vectors need to be in <em>column</em> format
so that the first lattice vector is lattice[:,0]</li>
<li><strong>basis</strong> &#8211; list of array[3] or list of list of array[3]
crystalline basis vectors, in unit cell coordinates. If a list of lists, then
there are multiple chemical elements, with each list corresponding to a unique
element</li>
<li><strong>chemistry</strong> &#8211; (optional) list of names of chemical elements</li>
<li><strong>spins</strong> &#8211; (optional) list of numbers (complex) / vectors or list of list of same
spins for individual atoms; if not None, needs to match the basis. Can either be
scalars or vectors, corresponding to collinear or non-collinear magnetism</li>
<li><strong>NOSYM</strong> &#8211; turn off all symmetry finding (except identity)</li>
<li><strong>noreduce</strong> &#8211; do not attempt to reduce the atomic basis</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.__repr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>String representation of crystal (lattice + basis)</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.__str__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Human-readable version of crystal (lattice + basis)</p>
</dd></dl>

<dl class="attribute">
<dt id="crystal.Crystal.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#crystal.Crystal.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.addbasis">
<code class="descname">addbasis</code><span class="sig-paren">(</span><em>basis</em>, <em>chemistry=None</em>, <em>spins=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.addbasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.addbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Crystal object that contains additional sites (assumed to be new chemistry).
This is intended to &#8220;add in&#8221; interstitial sites. Note: if the symmetry is to be
maintained, should be the output from Wyckoffpos().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>basis</strong> &#8211; list (or list of lists) of new sites</li>
<li><strong>chemistry</strong> &#8211; (optional) list of chemistry names</li>
<li><strong>spins</strong> &#8211; (optional) list of spins</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return Crystal:</th><td class="field-body"><p class="first last">new crystal object, with additional sites</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.calcmetric">
<code class="descname">calcmetric</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.calcmetric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.calcmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the volume of the cell and the metric tensor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return volume:</th><td class="field-body">cell volume</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return metric tensor:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">3x3</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.cart2pos">
<code class="descname">cart2pos</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.cart2pos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.cart2pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the lattvec and index corresponding to an atomic position in cartesian coord.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>v</strong> &#8211; 3-vector (float) position in Cartesian coordinates</td>
</tr>
<tr class="field-even field"><th class="field-name">Return lattvec:</th><td class="field-body">3-vector (integer) lattice vector in direct coordinates,</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return (c,i):</th><td class="field-body">tuple of matching basis atom; None if no match</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.cart2unit">
<code class="descname">cart2unit</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.cart2unit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.cart2unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the lattvec and unit cell coord. corresponding to a position
in cartesian coord.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>v</strong> &#8211; 3-vector (float) position in Cartesian coordinates</td>
</tr>
<tr class="field-even field"><th class="field-name">Return lattvec:</th><td class="field-body">3-vector (integer) lattice vector in direct coordinates,</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return uvec:</th><td class="field-body">3-vector (float) inside unit cell, in direct coordinates</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.center">
<code class="descname">center</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.center"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.center" title="Permalink to this definition">¶</a></dt>
<dd><p>Center the atoms in the cell if there is an inversion operation present.</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.chemindex">
<code class="descname">chemindex</code><span class="sig-paren">(</span><em>chemistry</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.chemindex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.chemindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return index corresponding to chemistry; None if not present.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>chemistry</strong> &#8211; value to check</td>
</tr>
<tr class="field-even field"><th class="field-name">Return index:</th><td class="field-body">corresponding to chemistry</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="crystal.Crystal.fromdict">
<em class="property">classmethod </em><code class="descname">fromdict</code><span class="sig-paren">(</span><em>yamldict</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.fromdict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.fromdict" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a Crystal object from a <em>very simple</em> YAML-created dictionary</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>yamldict</strong> &#8211; dictionary; must contain &#8216;lattice&#8217; (using <em>row</em> vectors!) and &#8216;basis&#8217;;
can contain optional &#8216;lattice_constant&#8217;</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return Crystal(lattice.T, basis):</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">new crystal object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.fullkptmesh">
<code class="descname">fullkptmesh</code><span class="sig-paren">(</span><em>Nmesh</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.fullkptmesh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.fullkptmesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a k-point mesh of density given by Nmesh; does not symmetrize but does put the
k-points inside the BZ. Does not return any <em>weights</em> as every point is equally weighted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Nmesh</strong> &#8211; mesh divisions Nmesh[0] x Nmesh[1] x Nmesh[2]</td>
</tr>
<tr class="field-even field"><th class="field-name">Return kpt:</th><td class="field-body">array[Nkpt][3] of kpoints</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.g_cart">
<code class="descname">g_cart</code><span class="sig-paren">(</span><em>g</em>, <em>x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.g_cart"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.g_cart" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a space group operation to a (Cartesian) vector position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>g</strong> &#8211; group operation (GroupOp)</li>
<li><strong>x</strong> &#8211; 3-vector position in space</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return gx:</th><td class="field-body"><p class="first last">3-vector position in space (Cartesian coordinates)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="crystal.Crystal.g_direc">
<em class="property">static </em><code class="descname">g_direc</code><span class="sig-paren">(</span><em>g</em>, <em>direc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.g_direc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.g_direc" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a space group operation to a direction</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>g</strong> &#8211; group operation (GroupOp)</li>
<li><strong>direc</strong> &#8211; 3-vector direction</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return gdirec:</th><td class="field-body"><p class="first last">3-vector direction</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.g_direc_equivalent">
<code class="descname">g_direc_equivalent</code><span class="sig-paren">(</span><em>d1</em>, <em>d2</em>, <em>threshold=1e-08</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.g_direc_equivalent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.g_direc_equivalent" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells us if two directions are equivalent by according to the space group</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d1</strong> &#8211; direction one (array[3])</li>
<li><strong>d2</strong> &#8211; direction two (array[3])</li>
<li><strong>threshold</strong> &#8211; threshold for equality</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return equivalent:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">True if equivalent by a point group operation</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.g_pos">
<code class="descname">g_pos</code><span class="sig-paren">(</span><em>g</em>, <em>lattvec</em>, <em>ind</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.g_pos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.g_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a space group operation to an atom position specified by its lattice and index</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>g</strong> &#8211; group operation (GroupOp)</li>
<li><strong>lattvec</strong> &#8211; 3-vector (integer) lattice vector in direct coordinates</li>
<li><strong>ind</strong> &#8211; two-tuple index specifying the atom: (atomtype, atomindex)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return glatt:</th><td class="field-body"><p class="first">3-vector (integer) lattice vector in direct coordinates</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return gindex:</th><td class="field-body"><p class="first last">tuple of new basis atom</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="crystal.Crystal.g_tensor">
<em class="property">static </em><code class="descname">g_tensor</code><span class="sig-paren">(</span><em>g</em>, <em>tensor</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.g_tensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.g_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a space group operation to a 2nd-rank tensor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>g</strong> &#8211; group operation (GroupOp)</li>
<li><strong>tensor</strong> &#8211; 2nd-rank tensor</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return gtensor:</th><td class="field-body"><p class="first last">2nd-rank tensor</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="crystal.Crystal.g_vect">
<em class="property">static </em><code class="descname">g_vect</code><span class="sig-paren">(</span><em>g</em>, <em>lattvec</em>, <em>uvec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.g_vect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.g_vect" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a space group operation to a vector position specified by its lattice and a location
in the unit cell in direct coordinates</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>g</strong> &#8211; group operation (GroupOp)</li>
<li><strong>lattvec</strong> &#8211; 3-vector (integer) lattice vector in direct coordinates</li>
<li><strong>uvec</strong> &#8211; 3-vector (float) vector in direct coordinates</li>
<li><strong>guvec</strong> &#8211; 3-vector (float) vector in direct coordinates</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return glatt:</th><td class="field-body"><p class="first last">3-vector (integer) lattice vector in direct coordinates</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.genBZG">
<code class="descname">genBZG</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.genBZG"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.genBZG" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the reciprocal lattice G points that define the Brillouin zone.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return Garray:</th><td class="field-body">array of G vectors that define the BZ, in Cartesian coordinates</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.genWyckoffsets">
<code class="descname">genWyckoffsets</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.genWyckoffsets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.genWyckoffsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate our Wykcoff sets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Return Wyckoffsets:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">set of sets of tuples of positions that correspond to identical Wyckoff positions</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.gengroup">
<code class="descname">gengroup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.gengroup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.gengroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate all of the space group operations. Now handles spins! Doesn&#8217;t store
spin phase factors for each group operation, though.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return Gset:</th><td class="field-body">frozenset of group operations</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.genpoint">
<code class="descname">genpoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.genpoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.genpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate our point group indices. Done with crazy list comprehension due to the
structure of our basis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Return Gpointlists:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">list of lists of frozensets of point group operations that leave a site unchanged</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.inBZ">
<code class="descname">inBZ</code><span class="sig-paren">(</span><em>vec</em>, <em>BZG=None</em>, <em>threshold=1e-05</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.inBZ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.inBZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells us if vec is inside our set of defining points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>vec</strong> &#8211; array [3], vector to be tested</li>
<li><strong>BGZ</strong> &#8211; array [:,3], optional (default = self.BZG), array of vectors that define the BZ</li>
<li><strong>threshold</strong> &#8211; double, optional, threshold to use for &#8220;equality&#8221;</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return inBZ:</th><td class="field-body"><p class="first last">False if outside the BZ, True otherwise</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.jumpnetwork">
<code class="descname">jumpnetwork</code><span class="sig-paren">(</span><em>chem</em>, <em>cutoff</em>, <em>closestdistance=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.jumpnetwork"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.jumpnetwork" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the full jump network for a specific chemical index, out to a cutoff. Organized
by symmetry-unique transitions. Note that i-&gt;j and j-&gt;i are always related to one-another,
but by equivalence of transition state, not symmetry. Now updated with closest-distance
parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>chem</strong> &#8211; index corresponding to the chemistry to consider</li>
<li><strong>cutoff</strong> &#8211; distance cutoff</li>
<li><strong>closestdistance</strong> &#8211; closest distance allowed in transition (can be a list)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return jumpnetwork:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">list of symmetry-unique transitions; each is a list of tuples:
<code class="docutils literal"><span class="pre">((i,j),</span> <span class="pre">dx)</span></code> corresponding to jump from <span class="math">\(i \to j\)</span> with vector <span class="math">\(\mathbf{\delta x}\)</span></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.jumpnetwork2lattice">
<code class="descname">jumpnetwork2lattice</code><span class="sig-paren">(</span><em>chem</em>, <em>jumpnetwork</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.jumpnetwork2lattice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.jumpnetwork2lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a &#8220;standard&#8221; jumpnetwork (that specifies displacement vectors dx) into a lattice
representation, where we replace dx with the lattice vector from i to j.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>chem</strong> &#8211; index corresponding to the chemistry to consider</li>
<li><strong>jumpnetwork</strong> &#8211; list of symmetry-unique transitions; each is a list of tuples:
<code class="docutils literal"><span class="pre">((i,j),</span> <span class="pre">dx)</span></code> corresponding to jump from <span class="math">\(i \to j\)</span> with vector <span class="math">\(\mathbf{\delta x}\)</span></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return jumplattice:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">list of symmetry-unique transitions; each is a list of tuples:
<code class="docutils literal"><span class="pre">((i,j),</span> <span class="pre">R)</span></code> corresponding to jump from i in unit cell 0 -&gt; j in unit cell R</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.minlattice">
<code class="descname">minlattice</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.minlattice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.minlattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to find the optimal lattice vector definition for a crystal. Our definition of optimal
is (a) length of each lattice vector is minimal; (b) the vectors are ordered from
shortest to longest; (c) the vectors have minimal dot product; (d) the basis is right-handed.</p>
<p>Works recursively, and in-place.</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.nnlist">
<code class="descname">nnlist</code><span class="sig-paren">(</span><em>ind</em>, <em>cutoff</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.nnlist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.nnlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the nearest neighbor list for a given cutoff. Only consider
neighbor vectors for atoms of the same type. Returns a list of
cartesian vectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ind</strong> &#8211; tuple index for atom</li>
<li><strong>cutoff</strong> &#8211; distance cutoff</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return nnlist:</th><td class="field-body"><p class="first last">list of nearest neighbor vectors</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.pos2cart">
<code class="descname">pos2cart</code><span class="sig-paren">(</span><em>lattvec</em>, <em>ind</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.pos2cart"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.pos2cart" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cartesian coordinates of an atom specified by its lattice and index</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lattvec</strong> &#8211; 3-vector (integer) lattice vector in direct coordinates</li>
<li><strong>ind</strong> &#8211; two-tuple index specifying the atom: (atomtype, atomindex)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return v:</th><td class="field-body"><p class="first last">3-vector (float) in Cartesian coordinates</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.reduce">
<code class="descname">reduce</code><span class="sig-paren">(</span><em>threshold=1e-08</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.reduce"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduces the lattice and basis, if needed. Works (tail) recursively.</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.reducekptmesh">
<code class="descname">reducekptmesh</code><span class="sig-paren">(</span><em>kptfull</em>, <em>threshold=1e-08</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.reducekptmesh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.reducekptmesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a fully expanded mesh, and reduces it by symmetry. Assumes every point is
equally weighted. We would need a different (more complicated) algorithm if not true...</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>kptfull</strong> &#8211; array[Nkpt][3] of kpoints</li>
<li><strong>threshold</strong> &#8211; threshold for symmetry equality</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return kptsymm:</th><td class="field-body"><p class="first">array[Nsymm][3] of kpoints</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return weight:</th><td class="field-body"><p class="first last">array[Nsymm] of weights (integrates to 1)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.remapbasis">
<code class="descname">remapbasis</code><span class="sig-paren">(</span><em>supercell</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.remapbasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.remapbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the basis definition, and using a supercell definition, returns a new basis</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>supercell</strong> &#8211; integer array[3,3]</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return atomic basis:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">list of list of positions</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.simpleYAML">
<code class="descname">simpleYAML</code><span class="sig-paren">(</span><em>a0=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.simpleYAML"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.simpleYAML" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simplified YAML dump, in case we don&#8217;t want to output the full symmetry analysis</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return YAML:</th><td class="field-body">string dump</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.sitelist">
<code class="descname">sitelist</code><span class="sig-paren">(</span><em>chem</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.sitelist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.sitelist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of lists of Wyckoff-related sites for a given chemistry.
Done with a single list comprehension&#8211;useful as input for diffusion calculation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>chem</strong> &#8211; index corresponding to chemistry to consider</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return symmequivsites:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">list of lists of indices that are equivalent by symmetry</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.strain">
<code class="descname">strain</code><span class="sig-paren">(</span><em>eps</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.strain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.strain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Crystal object that is a strained version of the current.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>eps</strong> &#8211; strain tensor</td>
</tr>
<tr class="field-even field"><th class="field-name">Return Crystal:</th><td class="field-body">new crystal object, strained</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.unit2cart">
<code class="descname">unit2cart</code><span class="sig-paren">(</span><em>lattvec</em>, <em>uvec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.unit2cart"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.unit2cart" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cartesian coordinates of a position specified by its lattice and
unit cell coordinates</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lattvec</strong> &#8211; 3-vector (integer) lattice vector in direct coordinates</li>
<li><strong>uvec</strong> &#8211; 3-vector (float) unit cell vector in direct coordinates</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return v:</th><td class="field-body"><p class="first last">3-vector (float) in Cartesian coordinates</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="crystal.Crystal.vectlist">
<em class="property">static </em><code class="descname">vectlist</code><span class="sig-paren">(</span><em>vb</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.vectlist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.vectlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of orthonormal vectors corresponding to our vector basis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vb</strong> &#8211; (dim, v)</td>
</tr>
<tr class="field-even field"><th class="field-name">Return vlist:</th><td class="field-body">list of vectors</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="crystal.GroupOp">
<em class="property">class </em><code class="descclassname">crystal.</code><code class="descname">GroupOp</code><a class="reference internal" href="_modules/crystal.html#GroupOp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp" title="Permalink to this definition">¶</a></dt>
<dd><p>A class corresponding to a group operation. Based on namedtuple, so it is immutable.</p>
<p>Intended to be used in combination with Crystal, we have a few operations that
can be defined out-of-the-box.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rot</strong> &#8211; np.array(3,3) integer idempotent matrix</li>
<li><strong>trans</strong> &#8211; np.array(3) real vector</li>
<li><strong>cartrot</strong> &#8211; np.array(3,3) real unitary matrix</li>
<li><strong>indexmap</strong> &#8211; tuples of tuples, containing the atom mapping</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="staticmethod">
<dt id="crystal.GroupOp.GroupOp_constructor">
<em class="property">static </em><code class="descname">GroupOp_constructor</code><span class="sig-paren">(</span><em>loader</em>, <em>node</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.GroupOp_constructor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.GroupOp_constructor" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a GroupOp from YAML</p>
</dd></dl>

<dl class="staticmethod">
<dt id="crystal.GroupOp.GroupOp_representer">
<em class="property">static </em><code class="descname">GroupOp_representer</code><span class="sig-paren">(</span><em>dumper</em>, <em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.GroupOp_representer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.GroupOp_representer" title="Permalink to this definition">¶</a></dt>
<dd><p>Output a GroupOp</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.__add__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.__add__" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a translation to our group operation</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.__eq__">
<code class="descname">__eq__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.__eq__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Test for equality&#8211;we use numpy.isclose for comparison, since that&#8217;s what we usually care about</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.__hash__">
<code class="descname">__hash__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.__hash__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Hash, so that we can make sets of group operations</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.__mul__">
<code class="descname">__mul__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.__mul__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply two group operations to produce a new group operation</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.__ne__">
<code class="descname">__ne__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.__ne__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Inequality == not __eq__</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.__sane__">
<code class="descname">__sane__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.__sane__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.__sane__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if the cartrot and rot are consistent and &#8216;sane&#8217;</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.__str__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Human-readable version of groupop</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.__sub__">
<code class="descname">__sub__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.__sub__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.__sub__" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a (negative) translation to our group operation</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.eigen">
<code class="descname">eigen</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.eigen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.eigen" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the type of group operation (single integer) and eigenvectors.
1 = identity
2, 3, 4, 6 = n- fold rotation around an axis
negative = rotation + mirror operation, perpendicular to axis
&#8220;special cases&#8221;: -1 = mirror, -2 = inversion</p>
<p>eigenvect[0] = axis of rotation / mirror
eigenvect[1], eigenvect[2] = orthonormal vectors to define the plane giving a right-handed
coordinate system and where rotation around [0] is positive, and the positive imaginary
eigenvector for the complex eigenvalue is [1] + i [2].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return eigenvectors:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">list of [ev0, ev1, ev2]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="crystal.GroupOp.ident">
<em class="property">classmethod </em><code class="descname">ident</code><span class="sig-paren">(</span><em>basis</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.ident"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.ident" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a group operation corresponding to identity for a given basis</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.incell">
<code class="descname">incell</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.incell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.incell" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a version of groupop where the translation is in the unit cell</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.inhalf">
<code class="descname">inhalf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.inhalf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.inhalf" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a version of groupop where the translation is in the centered unit cell</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.inv">
<code class="descname">inv</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.inv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct and return the inverse of the group operation</p>
</dd></dl>

<dl class="staticmethod">
<dt id="crystal.GroupOp.optype">
<em class="property">static </em><code class="descname">optype</code><span class="sig-paren">(</span><em>rot</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.optype"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.optype" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the type of group operation (single integer) and eigenvectors.
1 = identity
2, 3, 4, 6 = n- fold rotation around an axis
negative = rotation + mirror operation, perpendicular to axis
&#8220;special cases&#8221;: -1 = mirror, -2 = inversion</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rot</strong> &#8211; rotation matrix (can be the integer rot)</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="crystal.ProjectTensorBasis">
<code class="descclassname">crystal.</code><code class="descname">ProjectTensorBasis</code><span class="sig-paren">(</span><em>tensor</em>, <em>basis</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#ProjectTensorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.ProjectTensorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a tensor, project it onto the basis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>tensor</strong> &#8211; tensor</li>
<li><strong>basis</strong> &#8211; list consisting of an orthonormal basis</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return tensor:</th><td class="field-body"><p class="first last">tensor, projected</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="crystal.SymmTensorBasis">
<code class="descclassname">crystal.</code><code class="descname">SymmTensorBasis</code><span class="sig-paren">(</span><em>rottype</em>, <em>eigenvect</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#SymmTensorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.SymmTensorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a symmetric second-rank tensor basis corresponding to the optype and eigenvectors
for a GroupOp</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>rottype</strong> &#8211; output from eigen()</li>
<li><strong>eigenvect</strong> &#8211; eigenvectors</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return tensorbasis:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">list of 2nd-rank symmetric tensors making up the basis</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="crystal.VectorBasis">
<code class="descclassname">crystal.</code><code class="descname">VectorBasis</code><span class="sig-paren">(</span><em>rottype</em>, <em>eigenvect</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#VectorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.VectorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector basis corresponding to the optype and eigenvectors for a GroupOp</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>rottype</strong> &#8211; output from eigen()</li>
<li><strong>eigenvect</strong> &#8211; eigenvectors</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return dim:</th><td class="field-body"><p class="first">dimensionality, 0..3</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return vect:</th><td class="field-body"><p class="first last">vector defining line direction (1) or plane normal (2)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="crystal.Voigtstrain">
<code class="descclassname">crystal.</code><code class="descname">Voigtstrain</code><span class="sig-paren">(</span><em>e1</em>, <em>e2</em>, <em>e3</em>, <em>e4</em>, <em>e5</em>, <em>e6</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Voigtstrain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Voigtstrain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a symmetric strain tensor from the Voigt reduced strain values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>e1</strong> &#8211; xx</li>
<li><strong>e2</strong> &#8211; yy</li>
<li><strong>e3</strong> &#8211; zz</li>
<li><strong>e4</strong> &#8211; yz + zx</li>
<li><strong>e5</strong> &#8211; zx + xz</li>
<li><strong>e6</strong> &#8211; xy + yx</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return strain:</th><td class="field-body"><p class="first last">symmetric strain tensor</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="crystal.incell">
<code class="descclassname">crystal.</code><code class="descname">incell</code><span class="sig-paren">(</span><em>vec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#incell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.incell" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vector inside the unit cell (in [0,1)**3)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vec</strong> &#8211; 3-vector (unit coord)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">3-vector</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="crystal.inhalf">
<code class="descclassname">crystal.</code><code class="descname">inhalf</code><span class="sig-paren">(</span><em>vec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#inhalf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.inhalf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vector inside the centered cell (in [-0.5,0.5)**3)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vec</strong> &#8211; 3-vector (unit coord)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">3-vector</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="crystal.maptranslation">
<code class="descclassname">crystal.</code><code class="descname">maptranslation</code><span class="sig-paren">(</span><em>oldpos</em>, <em>newpos</em>, <em>oldspins=None</em>, <em>newspins=None</em>, <em>threshold=1e-08</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#maptranslation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.maptranslation" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of transformed positions, identify if there&#8217;s a translation vector
that maps from the current positions to the new position.</p>
<p>The mapping specifies the index that the <em>translated</em> atom corresponds to in the
original position set. If unable to construct a mapping, the mapping return is
None; the translation vector will be meaningless.</p>
<p>If old/newspins are given then ONLY mappings that maintain spin are considered.
This means that a loop is needed to consider possible spin phase factors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>oldpos</strong> &#8211; list of list of array[3]</li>
<li><strong>newpos</strong> &#8211; list of list of array[3], same layout as oldpos</li>
<li><strong>oldspins</strong> &#8211; (optional) list of list of numbers/arrays</li>
<li><strong>newspins</strong> &#8211; (optional) list of list of numbers/arrays</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return translation:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">array[3]</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return mapping:</th><td class="field-body"><p class="first last">list of list of indices</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="crystal.ndarray_representer">
<code class="descclassname">crystal.</code><code class="descname">ndarray_representer</code><span class="sig-paren">(</span><em>dumper</em>, <em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#ndarray_representer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.ndarray_representer" title="Permalink to this definition">¶</a></dt>
<dd><p>Output a numpy array</p>
</dd></dl>

</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="CrystalStars.html" class="btn btn-neutral float-right" title="CrystalStars" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="includeme.html" class="btn btn-neutral" title="Onsager" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Dallas R. Trinkle.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>