

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Crystal &mdash; Onsager 1.3.3 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="CrystalStars" href="CrystalStars.html" />
    <link rel="prev" title="Modules" href="modules.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Onsager
          

          
          </a>

          
            
            
              <div class="version">
                1.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="includeme.html">Onsager</a></li>
<li class="toctree-l1"><a class="reference internal" href="InputOutput.html">Input and output for Onsager transport calculation</a></li>
<li class="toctree-l1"><a class="reference internal" href="notebooks.html">Example Notebooks</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">Modules</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Crystal</a></li>
<li class="toctree-l2"><a class="reference internal" href="CrystalStars.html">CrystalStars</a></li>
<li class="toctree-l2"><a class="reference internal" href="supercell.html">Supercell</a></li>
<li class="toctree-l2"><a class="reference internal" href="PowerExpansion.html">PowerExpansion</a></li>
<li class="toctree-l2"><a class="reference internal" href="GFcalc.html">GFcalc</a></li>
<li class="toctree-l2"><a class="reference internal" href="OnsagerCalc.html">OnsagerCalc</a></li>
<li class="toctree-l2"><a class="reference internal" href="automator.html">Automator</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Onsager</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="modules.html">Modules</a> &raquo;</li>
        
      <li>Crystal</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/crystal.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast,
.nboutput.nblast {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast + .nbinput {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="crystal">
<h1>Crystal<a class="headerlink" href="#crystal" title="Permalink to this headline">¶</a></h1>
<p>Crystal:</p>
<p>The crystal module defines the <code class="docutils literal notranslate"><span class="pre">crystal</span></code> class, and <code class="docutils literal notranslate"><span class="pre">GroupOp</span></code> for group operations.</p>
<span class="target" id="module-crystal"></span><p>Crystal class</p>
<p>Class to store definition of a crystal, along with some analysis
1. geometric analysis (nearest neighbor displacements)
2. space group operations
3. point group operations for each basis position
4. Wyckoff position generation (for interstitials)</p>
<dl class="function">
<dt id="crystal.CombineTensorBasis">
<code class="sig-prename descclassname">crystal.</code><code class="sig-name descname">CombineTensorBasis</code><span class="sig-paren">(</span><em class="sig-param">b1</em>, <em class="sig-param">b2</em>, <em class="sig-param">symmetric=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#CombineTensorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.CombineTensorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines (intersects) two tensor spaces into one; uses SVD to compute null space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>b1</strong> – list of tensors</p></li>
<li><p><strong>b2</strong> – list of tensors</p></li>
</ul>
</dd>
<dt class="field-even">Return tensorbasis</dt>
<dd class="field-even"><p>list of 2nd-rank symmetric tensors making up the basis</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="crystal.CombineVectorBasis">
<code class="sig-prename descclassname">crystal.</code><code class="sig-name descname">CombineVectorBasis</code><span class="sig-paren">(</span><em class="sig-param">b1</em>, <em class="sig-param">b2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#CombineVectorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.CombineVectorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines (intersects) two vector spaces into one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>b1</strong> – (dim, vect) – dimensionality (0..3), vector defining line direction (1) or plane normal (2)</p></li>
<li><p><strong>b2</strong> – (dim, vect)</p></li>
</ul>
</dd>
<dt class="field-even">Return dim</dt>
<dd class="field-even"><p>dimensionality, 0..3</p>
</dd>
<dt class="field-odd">Return vect</dt>
<dd class="field-odd"><p>vector defining line direction (1) or plane normal (2)</p>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="crystal.Crystal">
<em class="property">class </em><code class="sig-prename descclassname">crystal.</code><code class="sig-name descname">Crystal</code><span class="sig-paren">(</span><em class="sig-param">lattice</em>, <em class="sig-param">basis</em>, <em class="sig-param">chemistry=None</em>, <em class="sig-param">spins=None</em>, <em class="sig-param">NOSYM=False</em>, <em class="sig-param">noreduce=False</em>, <em class="sig-param">threshold=1e-08</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal" title="Permalink to this definition">¶</a></dt>
<dd><p>A class that defines a crystal, as well as the symmetry analysis that goes along with it.
Now includes optional spins. These can be vectors or “scalar” spins, for which we need
to consider a phase factor. In general, they can be complex. Ideally, they should have
magnitude either 0 or 1.</p>
<p>Specified by a lattice (3 vectors), a basis (list of lists of positions in direct coordinates).
Can also name the elements (chemistry), and specify spin degrees of freedom.</p>
<dl class="method">
<dt id="crystal.Crystal.BCC">
<em class="property">classmethod </em><code class="sig-name descname">BCC</code><span class="sig-paren">(</span><em class="sig-param">a0</em>, <em class="sig-param">chemistry=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.BCC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.BCC" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a body-centered cubic crystal with lattice constant a0</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>a0</strong> – lattice constant</p>
</dd>
<dt class="field-even">Return BCC crystal</dt>
<dd class="field-even"><p></p></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.FCC">
<em class="property">classmethod </em><code class="sig-name descname">FCC</code><span class="sig-paren">(</span><em class="sig-param">a0</em>, <em class="sig-param">chemistry=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.FCC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.FCC" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a face-centered cubic crystal with lattice constant a0</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>a0</strong> – lattice constant</p>
</dd>
<dt class="field-even">Return FCC crystal</dt>
<dd class="field-even"><p></p></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.FullVectorBasis">
<code class="sig-name descname">FullVectorBasis</code><span class="sig-paren">(</span><em class="sig-param">chem=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.FullVectorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.FullVectorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate our full vector basis, using the information from our crystal</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>chem</strong> – (optional) chemical index to consider; otherwise return a list of such</p>
</dd>
<dt class="field-even">Return VBfunctions</dt>
<dd class="field-even"><p>(list) of our unique vector basis lattice functions, normalized; each is an array
(NVbasis x Nsites x 3)</p>
</dd>
<dt class="field-odd">Return VVouter</dt>
<dd class="field-odd"><p>(list) of ouf VV “outer” expansion (NVbasis x NVbasis for each chemistry)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.HCP">
<em class="property">classmethod </em><code class="sig-name descname">HCP</code><span class="sig-paren">(</span><em class="sig-param">a0</em>, <em class="sig-param">c_a=1.632993161855452</em>, <em class="sig-param">chemistry=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.HCP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.HCP" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a hexagonal closed packed crystal with lattice constant a0, c/a ratio c_a</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a0</strong> – lattice constant</p></li>
<li><p><strong>c_a</strong> – (optional) c/a ratio, default=ideal <span class="math notranslate nohighlight">\(\sqrt{8/3}\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Return HCP crystal</dt>
<dd class="field-even"><p></p></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.SymmTensorBasis">
<code class="sig-name descname">SymmTensorBasis</code><span class="sig-paren">(</span><em class="sig-param">ind</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.SymmTensorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.SymmTensorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the symmetric tensor basis corresponding to an atomic site</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ind</strong> – tuple index for atom</p>
</dd>
<dt class="field-even">Return tensorbasis</dt>
<dd class="field-even"><p>list of 2nd-rank symmetric tensors making up the basis</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.VectorBasis">
<code class="sig-name descname">VectorBasis</code><span class="sig-paren">(</span><em class="sig-param">ind</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.VectorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.VectorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the vector basis corresponding to an atomic site</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ind</strong> – tuple index for atom</p>
</dd>
<dt class="field-even">Return dim</dt>
<dd class="field-even"><p>dimensionality, 0..3</p>
</dd>
<dt class="field-odd">Return vect</dt>
<dd class="field-odd"><p>vector defining line direction (1) or plane normal (2)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.Wyckoffpos">
<code class="sig-name descname">Wyckoffpos</code><span class="sig-paren">(</span><em class="sig-param">uvec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.Wyckoffpos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.Wyckoffpos" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates all the equivalent Wyckoff positions for a unit cell vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>uvec</strong> – 3-vector (float) vector in direct coordinates</p>
</dd>
<dt class="field-even">Return Wyckofflist</dt>
<dd class="field-even"><p>list of equivalent Wyckoff positions</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">lattice</em>, <em class="sig-param">basis</em>, <em class="sig-param">chemistry=None</em>, <em class="sig-param">spins=None</em>, <em class="sig-param">NOSYM=False</em>, <em class="sig-param">noreduce=False</em>, <em class="sig-param">threshold=1e-08</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialization; starts off with the lattice vector definition and the
basis vectors. While it does not explicitly store the specific chemical
elements involved, it does store that there are different elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lattice</strong> – array[3,3] or list of array[3] (or 2 if 2-dimensional)
lattice vectors; if [3,3] array, then the vectors need to be in <em>column</em> format
so that the first lattice vector is lattice[:,0]</p></li>
<li><p><strong>basis</strong> – list of array[3] or list of list of array[3] (or 2 if 2-dimensional)
crystalline basis vectors, in unit cell coordinates. If a list of lists, then
there are multiple chemical elements, with each list corresponding to a unique
element</p></li>
<li><p><strong>chemistry</strong> – (optional) list of names of chemical elements</p></li>
<li><p><strong>spins</strong> – (optional) list of numbers (complex) / vectors or list of list of same
spins for individual atoms; if not None, needs to match the basis. Can either be
scalars or vectors, corresponding to collinear or non-collinear magnetism</p></li>
<li><p><strong>NOSYM</strong> – turn off all symmetry finding (except identity)</p></li>
<li><p><strong>noreduce</strong> – do not attempt to reduce the atomic basis</p></li>
<li><p><strong>threshold</strong> – threshold for symmetry equivalence (stored in the class)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.__repr__">
<code class="sig-name descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.__repr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>String representation of crystal (lattice + basis)</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.__str__">
<code class="sig-name descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.__str__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Human-readable version of crystal (lattice + basis)</p>
</dd></dl>

<dl class="attribute">
<dt id="crystal.Crystal.__weakref__">
<code class="sig-name descname">__weakref__</code><a class="headerlink" href="#crystal.Crystal.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.addbasis">
<code class="sig-name descname">addbasis</code><span class="sig-paren">(</span><em class="sig-param">basis</em>, <em class="sig-param">chemistry=None</em>, <em class="sig-param">spins=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.addbasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.addbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Crystal object that contains additional sites (assumed to be new chemistry).
This is intended to “add in” interstitial sites. Note: if the symmetry is to be
maintained, should be the output from Wyckoffpos().</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>basis</strong> – list (or list of lists) of new sites</p></li>
<li><p><strong>chemistry</strong> – (optional) list of chemistry names</p></li>
<li><p><strong>spins</strong> – (optional) list of spins</p></li>
</ul>
</dd>
<dt class="field-even">Return Crystal</dt>
<dd class="field-even"><p>new crystal object, with additional sites</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.calcmetric">
<code class="sig-name descname">calcmetric</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.calcmetric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.calcmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the volume of the cell and the metric tensor</p>
<dl class="field-list simple">
<dt class="field-odd">Return volume</dt>
<dd class="field-odd"><p>cell volume</p>
</dd>
<dt class="field-even">Return metric tensor</dt>
<dd class="field-even"><p>3x3</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.cart2pos">
<code class="sig-name descname">cart2pos</code><span class="sig-paren">(</span><em class="sig-param">v</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.cart2pos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.cart2pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the lattvec and index corresponding to an atomic position in cartesian coord.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> – 3-vector (float) position in Cartesian coordinates</p>
</dd>
<dt class="field-even">Return lattvec</dt>
<dd class="field-even"><p>3-vector (integer) lattice vector in direct coordinates,</p>
</dd>
<dt class="field-odd">Return (c,i)</dt>
<dd class="field-odd"><p>tuple of matching basis atom; None if no match</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.cart2unit">
<code class="sig-name descname">cart2unit</code><span class="sig-paren">(</span><em class="sig-param">v</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.cart2unit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.cart2unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the lattvec and unit cell coord. corresponding to a position
in cartesian coord.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> – 3-vector (float) position in Cartesian coordinates</p>
</dd>
<dt class="field-even">Return lattvec</dt>
<dd class="field-even"><p>3-vector (integer) lattice vector in direct coordinates,</p>
</dd>
<dt class="field-odd">Return uvec</dt>
<dd class="field-odd"><p>3-vector (float) inside unit cell, in direct coordinates</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.center">
<code class="sig-name descname">center</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.center"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.center" title="Permalink to this definition">¶</a></dt>
<dd><p>Center the atoms in the cell if there is an inversion operation present.</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.chemindex">
<code class="sig-name descname">chemindex</code><span class="sig-paren">(</span><em class="sig-param">chemistry</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.chemindex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.chemindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return index corresponding to chemistry; None if not present.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>chemistry</strong> – value to check</p>
</dd>
<dt class="field-even">Return index</dt>
<dd class="field-even"><p>corresponding to chemistry</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.fromdict">
<em class="property">classmethod </em><code class="sig-name descname">fromdict</code><span class="sig-paren">(</span><em class="sig-param">yamldict</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.fromdict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.fromdict" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a Crystal object from a <em>very simple</em> YAML-created dictionary</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>yamldict</strong> – dictionary; must contain ‘lattice’ (using <em>row</em> vectors!) and ‘basis’;
can contain optional ‘lattice_constant’</p>
</dd>
<dt class="field-even">Return Crystal(lattice.T, basis)</dt>
<dd class="field-even"><p>new crystal object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.fullkptmesh">
<code class="sig-name descname">fullkptmesh</code><span class="sig-paren">(</span><em class="sig-param">Nmesh</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.fullkptmesh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.fullkptmesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a k-point mesh of density given by Nmesh; does not symmetrize but does put the
k-points inside the BZ. Does not return any <em>weights</em> as every point is equally weighted.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>Nmesh</strong> – mesh divisions Nmesh[0] x Nmesh[1] x Nmesh[2]</p>
</dd>
<dt class="field-even">Return kpt</dt>
<dd class="field-even"><p>array[Nkpt][3] of kpoints</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.g_cart">
<code class="sig-name descname">g_cart</code><span class="sig-paren">(</span><em class="sig-param">g</em>, <em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.g_cart"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.g_cart" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a space group operation to a (Cartesian) vector position</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>g</strong> – group operation (GroupOp)</p></li>
<li><p><strong>x</strong> – 3-vector position in space</p></li>
</ul>
</dd>
<dt class="field-even">Return gx</dt>
<dd class="field-even"><p>3-vector position in space (Cartesian coordinates)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.g_direc">
<em class="property">static </em><code class="sig-name descname">g_direc</code><span class="sig-paren">(</span><em class="sig-param">g</em>, <em class="sig-param">direc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.g_direc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.g_direc" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a space group operation to a direction</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>g</strong> – group operation (GroupOp)</p></li>
<li><p><strong>direc</strong> – 3-vector direction</p></li>
</ul>
</dd>
<dt class="field-even">Return gdirec</dt>
<dd class="field-even"><p>3-vector direction</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.g_direc_equivalent">
<code class="sig-name descname">g_direc_equivalent</code><span class="sig-paren">(</span><em class="sig-param">d1</em>, <em class="sig-param">d2</em>, <em class="sig-param">threshold=1e-08</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.g_direc_equivalent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.g_direc_equivalent" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells us if two directions are equivalent by according to the space group</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d1</strong> – direction one (array[3])</p></li>
<li><p><strong>d2</strong> – direction two (array[3])</p></li>
<li><p><strong>threshold</strong> – threshold for equality</p></li>
</ul>
</dd>
<dt class="field-even">Return equivalent</dt>
<dd class="field-even"><p>True if equivalent by a point group operation</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.g_pos">
<code class="sig-name descname">g_pos</code><span class="sig-paren">(</span><em class="sig-param">g</em>, <em class="sig-param">lattvec</em>, <em class="sig-param">ind</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.g_pos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.g_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a space group operation to an atom position specified by its lattice and index</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>g</strong> – group operation (GroupOp)</p></li>
<li><p><strong>lattvec</strong> – 3-vector (integer) lattice vector in direct coordinates</p></li>
<li><p><strong>ind</strong> – two-tuple index specifying the atom: (atomtype, atomindex)</p></li>
</ul>
</dd>
<dt class="field-even">Return glatt</dt>
<dd class="field-even"><p>3-vector (integer) lattice vector in direct coordinates</p>
</dd>
<dt class="field-odd">Return gindex</dt>
<dd class="field-odd"><p>tuple of new basis atom</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.g_tensor">
<em class="property">static </em><code class="sig-name descname">g_tensor</code><span class="sig-paren">(</span><em class="sig-param">g</em>, <em class="sig-param">tensor</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.g_tensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.g_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a space group operation to a 2nd-rank tensor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>g</strong> – group operation (GroupOp)</p></li>
<li><p><strong>tensor</strong> – 2nd-rank tensor</p></li>
</ul>
</dd>
<dt class="field-even">Return gtensor</dt>
<dd class="field-even"><p>2nd-rank tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.g_vect">
<em class="property">static </em><code class="sig-name descname">g_vect</code><span class="sig-paren">(</span><em class="sig-param">g</em>, <em class="sig-param">lattvec</em>, <em class="sig-param">uvec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.g_vect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.g_vect" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a space group operation to a vector position specified by its lattice and a location
in the unit cell in direct coordinates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>g</strong> – group operation (GroupOp)</p></li>
<li><p><strong>lattvec</strong> – 3-vector (integer) lattice vector in direct coordinates</p></li>
<li><p><strong>uvec</strong> – 3-vector (float) vector in direct coordinates</p></li>
<li><p><strong>guvec</strong> – 3-vector (float) vector in direct coordinates</p></li>
</ul>
</dd>
<dt class="field-even">Return glatt</dt>
<dd class="field-even"><p>3-vector (integer) lattice vector in direct coordinates</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.genBZG">
<code class="sig-name descname">genBZG</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.genBZG"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.genBZG" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the reciprocal lattice G points that define the Brillouin zone.</p>
<dl class="field-list simple">
<dt class="field-odd">Return Garray</dt>
<dd class="field-odd"><p>array of G vectors that define the BZ, in Cartesian coordinates</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.genWyckoffsets">
<code class="sig-name descname">genWyckoffsets</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.genWyckoffsets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.genWyckoffsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate our Wykcoff sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Return Wyckoffsets</dt>
<dd class="field-odd"><p>set of sets of tuples of positions that correspond to identical Wyckoff positions</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.gengroup">
<code class="sig-name descname">gengroup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.gengroup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.gengroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate all of the space group operations. Now handles spins! Doesn’t store
spin phase factors for each group operation, though.</p>
<dl class="field-list simple">
<dt class="field-odd">Return Gset</dt>
<dd class="field-odd"><p>frozenset of group operations</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.genpoint">
<code class="sig-name descname">genpoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.genpoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.genpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate our point group indices. Done with crazy list comprehension due to the
structure of our basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Return Gpointlists</dt>
<dd class="field-odd"><p>list of lists of frozensets of point group operations that leave a site unchanged</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.inBZ">
<code class="sig-name descname">inBZ</code><span class="sig-paren">(</span><em class="sig-param">vec</em>, <em class="sig-param">BZG=None</em>, <em class="sig-param">threshold=1e-05</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.inBZ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.inBZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells us if vec is inside our set of defining points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> – array [3], vector to be tested</p></li>
<li><p><strong>BGZ</strong> – array [:,3], optional (default = self.BZG), array of vectors that define the BZ</p></li>
<li><p><strong>threshold</strong> – double, optional, threshold to use for “equality”</p></li>
</ul>
</dd>
<dt class="field-even">Return inBZ</dt>
<dd class="field-even"><p>False if outside the BZ, True otherwise</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.jumpnetwork">
<code class="sig-name descname">jumpnetwork</code><span class="sig-paren">(</span><em class="sig-param">chem</em>, <em class="sig-param">cutoff</em>, <em class="sig-param">closestdistance=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.jumpnetwork"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.jumpnetwork" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the full jump network for a specific chemical index, out to a cutoff. Organized
by symmetry-unique transitions. Note that i-&gt;j and j-&gt;i are always related to one-another,
but by equivalence of transition state, not symmetry. Now updated with closest-distance
parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chem</strong> – index corresponding to the chemistry to consider</p></li>
<li><p><strong>cutoff</strong> – distance cutoff</p></li>
<li><p><strong>closestdistance</strong> – closest distance allowed in transition (can be a list)</p></li>
</ul>
</dd>
<dt class="field-even">Return jumpnetwork</dt>
<dd class="field-even"><p>list of symmetry-unique transitions; each is a list of tuples:
<code class="docutils literal notranslate"><span class="pre">((i,j),</span> <span class="pre">dx)</span></code> corresponding to jump from <span class="math notranslate nohighlight">\(i \to j\)</span> with vector <span class="math notranslate nohighlight">\(\mathbf{\delta x}\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.jumpnetwork2lattice">
<code class="sig-name descname">jumpnetwork2lattice</code><span class="sig-paren">(</span><em class="sig-param">chem</em>, <em class="sig-param">jumpnetwork</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.jumpnetwork2lattice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.jumpnetwork2lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a “standard” jumpnetwork (that specifies displacement vectors dx) into a lattice
representation, where we replace dx with the lattice vector from i to j.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chem</strong> – index corresponding to the chemistry to consider</p></li>
<li><p><strong>jumpnetwork</strong> – list of symmetry-unique transitions; each is a list of tuples:
<code class="docutils literal notranslate"><span class="pre">((i,j),</span> <span class="pre">dx)</span></code> corresponding to jump from <span class="math notranslate nohighlight">\(i \to j\)</span> with vector <span class="math notranslate nohighlight">\(\mathbf{\delta x}\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Return jumplattice</dt>
<dd class="field-even"><p>list of symmetry-unique transitions; each is a list of tuples:
<code class="docutils literal notranslate"><span class="pre">((i,j),</span> <span class="pre">R)</span></code> corresponding to jump from i in unit cell 0 -&gt; j in unit cell R</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.minlattice">
<code class="sig-name descname">minlattice</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.minlattice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.minlattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to find the optimal lattice vector definition for a crystal. Our definition of optimal
is (a) length of each lattice vector is minimal; (b) the vectors are ordered from
shortest to longest; (c) the vectors have minimal dot product; (d) the basis is right-handed.</p>
<p>Works recursively, and in-place.</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.nnlist">
<code class="sig-name descname">nnlist</code><span class="sig-paren">(</span><em class="sig-param">ind</em>, <em class="sig-param">cutoff</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.nnlist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.nnlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the nearest neighbor list for a given cutoff. Only consider
neighbor vectors for atoms of the same type. Returns a list of
cartesian vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ind</strong> – tuple index for atom</p></li>
<li><p><strong>cutoff</strong> – distance cutoff</p></li>
</ul>
</dd>
<dt class="field-even">Return nnlist</dt>
<dd class="field-even"><p>list of nearest neighbor vectors</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.pos2cart">
<code class="sig-name descname">pos2cart</code><span class="sig-paren">(</span><em class="sig-param">lattvec</em>, <em class="sig-param">ind</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.pos2cart"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.pos2cart" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cartesian coordinates of an atom specified by its lattice and index</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lattvec</strong> – 3-vector (integer) lattice vector in direct coordinates</p></li>
<li><p><strong>ind</strong> – two-tuple index specifying the atom: (atomtype, atomindex)</p></li>
</ul>
</dd>
<dt class="field-even">Return v</dt>
<dd class="field-even"><p>3-vector (float) in Cartesian coordinates</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.reduce">
<code class="sig-name descname">reduce</code><span class="sig-paren">(</span><em class="sig-param">threshold=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.reduce"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduces the lattice and basis, if needed. Works (tail) recursively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>threshold</strong> – threshold for symmetry comparison; default = self.threshold</p>
</dd>
</dl>
<p>Algorithm is slightly complicated: we attempt to identify if there is a internal
translation symmetry in the crystal (called <cite>t</cite>) that applies to all sites. Once identified,
we transform the lattice vectors and basis into the “reduced” form of the cell. We use
tail recursion to continue until no further reduction is possible. Will usually require
some “polishing” on the unit cell after the fact.</p>
<p>We try to do this efficiently: we check the GCD of the site counts (called <cite>M</cite>); if it’s 1,
we kick out. We check translations against the smallest site set first.</p>
<p>We try to do this carefully: We make sure that our translation can be expressed rationally
with <cite>M</cite> as the denominator; this helps protect against roundoff error. When we reduce the
atomic basis, we <em>average</em> the values that match. Finally, as we reduce, we also change the
<cite>self.threshold</cite> value accordingly so that recursion uses the same “effective” threshold.</p>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.reducekptmesh">
<code class="sig-name descname">reducekptmesh</code><span class="sig-paren">(</span><em class="sig-param">kptfull</em>, <em class="sig-param">threshold=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.reducekptmesh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.reducekptmesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a fully expanded mesh, and reduces it by symmetry. Assumes every point is
equally weighted. We would need a different (more complicated) algorithm if not true…</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kptfull</strong> – array[Nkpt][3] of kpoints</p></li>
<li><p><strong>threshold</strong> – threshold for symmetry equality</p></li>
</ul>
</dd>
<dt class="field-even">Return kptsymm</dt>
<dd class="field-even"><p>array[Nsymm][3] of kpoints</p>
</dd>
<dt class="field-odd">Return weight</dt>
<dd class="field-odd"><p>array[Nsymm] of weights (integrates to 1)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.remapbasis">
<code class="sig-name descname">remapbasis</code><span class="sig-paren">(</span><em class="sig-param">supercell</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.remapbasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.remapbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the basis definition, and using a supercell definition, returns a new basis</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>supercell</strong> – integer array[3,3]</p>
</dd>
<dt class="field-even">Return atomic basis</dt>
<dd class="field-even"><p>list of list of positions</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.simpleYAML">
<code class="sig-name descname">simpleYAML</code><span class="sig-paren">(</span><em class="sig-param">a0=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.simpleYAML"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.simpleYAML" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simplified YAML dump, in case we don’t want to output the full symmetry analysis</p>
<dl class="field-list simple">
<dt class="field-odd">Return YAML</dt>
<dd class="field-odd"><p>string dump</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.sitelist">
<code class="sig-name descname">sitelist</code><span class="sig-paren">(</span><em class="sig-param">chem</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.sitelist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.sitelist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of lists of Wyckoff-related sites for a given chemistry.
Done with a single list comprehension–useful as input for diffusion calculation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>chem</strong> – index corresponding to chemistry to consider</p>
</dd>
<dt class="field-even">Return symmequivsites</dt>
<dd class="field-even"><p>list of lists of indices that are equivalent by symmetry</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.strain">
<code class="sig-name descname">strain</code><span class="sig-paren">(</span><em class="sig-param">eps</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.strain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.strain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Crystal object that is a strained version of the current.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>eps</strong> – strain tensor</p>
</dd>
<dt class="field-even">Return Crystal</dt>
<dd class="field-even"><p>new crystal object, strained</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.unit2cart">
<code class="sig-name descname">unit2cart</code><span class="sig-paren">(</span><em class="sig-param">lattvec</em>, <em class="sig-param">uvec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.unit2cart"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.unit2cart" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cartesian coordinates of a position specified by its lattice and
unit cell coordinates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lattvec</strong> – 3-vector (integer) lattice vector in direct coordinates</p></li>
<li><p><strong>uvec</strong> – 3-vector (float) unit cell vector in direct coordinates</p></li>
</ul>
</dd>
<dt class="field-even">Return v</dt>
<dd class="field-even"><p>3-vector (float) in Cartesian coordinates</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.Crystal.vectlist">
<em class="property">static </em><code class="sig-name descname">vectlist</code><span class="sig-paren">(</span><em class="sig-param">vb</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Crystal.vectlist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Crystal.vectlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of orthonormal vectors corresponding to our vector basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vb</strong> – (dim, v)</p>
</dd>
<dt class="field-even">Return vlist</dt>
<dd class="field-even"><p>list of vectors</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="crystal.FourthRankIsotropic">
<code class="sig-prename descclassname">crystal.</code><code class="sig-name descname">FourthRankIsotropic</code><span class="sig-paren">(</span><em class="sig-param">F</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#FourthRankIsotropic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.FourthRankIsotropic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the average and shear values from orientational averaging of a symmetric fourth-rank
tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>F</strong><strong>[</strong><strong>a</strong><strong>,</strong><strong>b</strong><strong>,</strong><strong>c</strong><strong>,</strong><strong>d</strong><strong>]</strong> – symmetric fourth-rank tensor (F[abcd]=F[abcd]=F[bacd]=F[cdab])</p>
</dd>
<dt class="field-even">Return average</dt>
<dd class="field-even"><p>average value = (F11+2F12)/3, orientationally averaged</p>
</dd>
<dt class="field-odd">Return shear</dt>
<dd class="field-odd"><p>shear value = F44, orientationally averaged</p>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="crystal.GroupOp">
<em class="property">class </em><code class="sig-prename descclassname">crystal.</code><code class="sig-name descname">GroupOp</code><a class="reference internal" href="_modules/crystal.html#GroupOp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp" title="Permalink to this definition">¶</a></dt>
<dd><p>A class corresponding to a group operation. Based on namedtuple, so it is immutable.</p>
<p>Intended to be used in combination with Crystal, we have a few operations that
can be defined out-of-the-box.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rot</strong> – np.array(3,3) integer idempotent matrix</p></li>
<li><p><strong>trans</strong> – np.array(3) real vector</p></li>
<li><p><strong>cartrot</strong> – np.array(3,3) real unitary matrix</p></li>
<li><p><strong>indexmap</strong> – tuples of tuples, containing the atom mapping</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="crystal.GroupOp.GroupOp_constructor">
<em class="property">static </em><code class="sig-name descname">GroupOp_constructor</code><span class="sig-paren">(</span><em class="sig-param">loader</em>, <em class="sig-param">node</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.GroupOp_constructor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.GroupOp_constructor" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a GroupOp from YAML</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.GroupOp_representer">
<em class="property">static </em><code class="sig-name descname">GroupOp_representer</code><span class="sig-paren">(</span><em class="sig-param">dumper</em>, <em class="sig-param">data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.GroupOp_representer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.GroupOp_representer" title="Permalink to this definition">¶</a></dt>
<dd><p>Output a GroupOp</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.__add__">
<code class="sig-name descname">__add__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.__add__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.__add__" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a translation to our group operation</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.__eq__">
<code class="sig-name descname">__eq__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.__eq__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Test for equality–we use numpy.isclose for comparison, since that’s what we usually care about</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.__hash__">
<code class="sig-name descname">__hash__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.__hash__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Hash, so that we can make sets of group operations</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.__mul__">
<code class="sig-name descname">__mul__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.__mul__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply two group operations to produce a new group operation</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.__ne__">
<code class="sig-name descname">__ne__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.__ne__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Inequality == not __eq__</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.__sane__">
<code class="sig-name descname">__sane__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.__sane__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.__sane__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if the cartrot and rot are consistent and ‘sane’</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.__str__">
<code class="sig-name descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.__str__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Human-readable version of groupop</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.__sub__">
<code class="sig-name descname">__sub__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.__sub__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.__sub__" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a (negative) translation to our group operation</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.eigen">
<code class="sig-name descname">eigen</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.eigen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.eigen" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the type of group operation (single integer) and eigenvectors.
1 = identity
2, 3, 4, 6 = n- fold rotation around an axis
negative = rotation + mirror operation, perpendicular to axis
“special cases”: -1 = mirror, -2 = inversion</p>
<p>eigenvect[0] = axis of rotation / mirror
eigenvect[1], eigenvect[2] = orthonormal vectors to define the plane giving a right-handed
coordinate system and where rotation around [0] is positive, and the positive imaginary
eigenvector for the complex eigenvalue is [1] + i [2].</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>integer</p>
</dd>
<dt class="field-even">Return eigenvectors</dt>
<dd class="field-even"><p>list of [ev0, ev1, ev2]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.ident">
<em class="property">classmethod </em><code class="sig-name descname">ident</code><span class="sig-paren">(</span><em class="sig-param">basis</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.ident"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.ident" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a group operation corresponding to identity for a given basis</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.incell">
<code class="sig-name descname">incell</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.incell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.incell" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a version of groupop where the translation is in the unit cell</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.inhalf">
<code class="sig-name descname">inhalf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.inhalf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.inhalf" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a version of groupop where the translation is in the centered unit cell</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.inv">
<code class="sig-name descname">inv</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.inv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct and return the inverse of the group operation</p>
</dd></dl>

<dl class="method">
<dt id="crystal.GroupOp.optype">
<em class="property">static </em><code class="sig-name descname">optype</code><span class="sig-paren">(</span><em class="sig-param">rot</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#GroupOp.optype"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.GroupOp.optype" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the type of group operation (single integer):
1 = identity
2, 3, 4, 6 = n- fold rotation around an axis
negative = rotation + mirror operation, perpendicular to axis
“special cases”: -1 = mirror, -2 = inversion</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rot</strong> – rotation matrix (can be the integer rot)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>integer</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="crystal.ProjectTensorBasis">
<code class="sig-prename descclassname">crystal.</code><code class="sig-name descname">ProjectTensorBasis</code><span class="sig-paren">(</span><em class="sig-param">tensor</em>, <em class="sig-param">basis</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#ProjectTensorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.ProjectTensorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a tensor, project it onto the basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensor</strong> – tensor</p></li>
<li><p><strong>basis</strong> – list consisting of an orthonormal basis</p></li>
</ul>
</dd>
<dt class="field-even">Return tensor</dt>
<dd class="field-even"><p>tensor, projected</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="crystal.SymmTensorBasis">
<code class="sig-prename descclassname">crystal.</code><code class="sig-name descname">SymmTensorBasis</code><span class="sig-paren">(</span><em class="sig-param">rottype</em>, <em class="sig-param">eigenvect</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#SymmTensorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.SymmTensorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a symmetric second-rank tensor basis corresponding to the optype and eigenvectors
for a GroupOp</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rottype</strong> – output from eigen()</p></li>
<li><p><strong>eigenvect</strong> – eigenvectors</p></li>
</ul>
</dd>
<dt class="field-even">Return tensorbasis</dt>
<dd class="field-even"><p>list of 2nd-rank symmetric tensors making up the basis</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="crystal.VectorBasis">
<code class="sig-prename descclassname">crystal.</code><code class="sig-name descname">VectorBasis</code><span class="sig-paren">(</span><em class="sig-param">rottype</em>, <em class="sig-param">eigenvect</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#VectorBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.VectorBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector basis corresponding to the optype and eigenvectors for a GroupOp</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rottype</strong> – output from eigen()</p></li>
<li><p><strong>eigenvect</strong> – eigenvectors</p></li>
</ul>
</dd>
<dt class="field-even">Return dim</dt>
<dd class="field-even"><p>dimensionality, 0..3</p>
</dd>
<dt class="field-odd">Return vect</dt>
<dd class="field-odd"><p>vector defining line direction (1) or plane normal (2)</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="crystal.Voigtstrain">
<code class="sig-prename descclassname">crystal.</code><code class="sig-name descname">Voigtstrain</code><span class="sig-paren">(</span><em class="sig-param">e1</em>, <em class="sig-param">e2</em>, <em class="sig-param">e3</em>, <em class="sig-param">e4</em>, <em class="sig-param">e5</em>, <em class="sig-param">e6</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#Voigtstrain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.Voigtstrain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a symmetric strain tensor from the Voigt reduced strain values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>e1</strong> – xx</p></li>
<li><p><strong>e2</strong> – yy</p></li>
<li><p><strong>e3</strong> – zz</p></li>
<li><p><strong>e4</strong> – yz + zx</p></li>
<li><p><strong>e5</strong> – zx + xz</p></li>
<li><p><strong>e6</strong> – xy + yx</p></li>
</ul>
</dd>
<dt class="field-even">Return strain</dt>
<dd class="field-even"><p>symmetric strain tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="crystal.gcdlist">
<code class="sig-prename descclassname">crystal.</code><code class="sig-name descname">gcdlist</code><span class="sig-paren">(</span><em class="sig-param">lis</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#gcdlist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.gcdlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the GCD of a list of integers</p>
</dd></dl>

<dl class="function">
<dt id="crystal.incell">
<code class="sig-prename descclassname">crystal.</code><code class="sig-name descname">incell</code><span class="sig-paren">(</span><em class="sig-param">vec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#incell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.incell" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vector inside the unit cell (in [0,1)**3)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vec</strong> – 3-vector (unit coord)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>3-vector</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="crystal.inhalf">
<code class="sig-prename descclassname">crystal.</code><code class="sig-name descname">inhalf</code><span class="sig-paren">(</span><em class="sig-param">vec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#inhalf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.inhalf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vector inside the centered cell (in [-0.5,0.5)**3)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vec</strong> – 3-vector (unit coord)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>3-vector</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="crystal.isotropicFourthRank">
<code class="sig-prename descclassname">crystal.</code><code class="sig-name descname">isotropicFourthRank</code><span class="sig-paren">(</span><em class="sig-param">average</em>, <em class="sig-param">shear</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#isotropicFourthRank"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.isotropicFourthRank" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a symmetrized, isotropic fourth-rank tensor based on an average value and “shear” value</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>average</strong> – averaged value = (F11+2F12)/3</p></li>
<li><p><strong>shear</strong> – shear value = F44 = (F11-F12)/2</p></li>
</ul>
</dd>
<dt class="field-even">Return F[a,b,c,d]</dt>
<dd class="field-even"><p>isotropic fourth-rank tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="crystal.maptranslation">
<code class="sig-prename descclassname">crystal.</code><code class="sig-name descname">maptranslation</code><span class="sig-paren">(</span><em class="sig-param">oldpos</em>, <em class="sig-param">newpos</em>, <em class="sig-param">oldspins=None</em>, <em class="sig-param">newspins=None</em>, <em class="sig-param">threshold=1e-08</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#maptranslation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.maptranslation" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of transformed positions, identify if there’s a translation vector
that maps from the current positions to the new position.</p>
<p>The mapping specifies the index that the <em>translated</em> atom corresponds to in the
original position set. If unable to construct a mapping, the mapping return is
None; the translation vector will be meaningless.</p>
<p>If old/newspins are given then ONLY mappings that maintain spin are considered.
This means that a loop is needed to consider possible spin phase factors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>oldpos</strong> – list of list of array[3]</p></li>
<li><p><strong>newpos</strong> – list of list of array[3], same layout as oldpos</p></li>
<li><p><strong>oldspins</strong> – (optional) list of list of numbers/arrays</p></li>
<li><p><strong>newspins</strong> – (optional) list of list of numbers/arrays</p></li>
</ul>
</dd>
<dt class="field-even">Return translation</dt>
<dd class="field-even"><p>array[3]</p>
</dd>
<dt class="field-odd">Return mapping</dt>
<dd class="field-odd"><p>list of list of indices</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="crystal.ndarray_representer">
<code class="sig-prename descclassname">crystal.</code><code class="sig-name descname">ndarray_representer</code><span class="sig-paren">(</span><em class="sig-param">dumper</em>, <em class="sig-param">data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/crystal.html#ndarray_representer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#crystal.ndarray_representer" title="Permalink to this definition">¶</a></dt>
<dd><p>Output a numpy array</p>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="CrystalStars.html" class="btn btn-neutral float-right" title="CrystalStars" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="modules.html" class="btn btn-neutral float-left" title="Modules" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Dallas R. Trinkle

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>